<!DOCTYPE html>
<html>
    <head>
        <title>Idle Pomodoro Adventure</title>
        <link rel="stylesheet" href="../css/mvp.css">
    </head>
    <body>
        <script src="../scripts/html_tools.js"></script>
        <script src="../scripts/ipa_area_generator.js"></script>
        <script>
            //TODO: some notes
            /* 
             * Definitely need a favicon.
             * Possibly have an achievement system? A card per achievement, and a whole array of cards to scroll through?
             */
            const appTitle = `Idle Pomodoro Adventure`;
            const gameWidth = 800;
            const rateOfAdvancement = 0.07;
            const levelUpDifficulty = 2;
            const xpToLevel = (xp) => {
                switch (levelUpDifficulty) {
                    case 2:
                        return Math.floor(rateOfAdvancement * Math.sqrt(xp));
                    
                    case 3:
                        return Math.floor(rateOfAdvancement * Math.cbrt(xp));
                    
                    default:
                        return Math.floor(rateOfAdvancement * Math.pow(xp, 1/levelUpDifficulty));
                }
            };
            const levelToXp = (level) => {
                return Math.ceil(Math.pow(level / rateOfAdvancement, levelUpDifficulty));
            };

            const getRelativeXpReport = (xp) => {
                const level = xpToLevel(xp);
                const baseLevelXp = levelToXp(level);
                const nextLevelXp = levelToXp(level + 1);
                return {
                    value: xp - baseLevelXp,
                    max: nextLevelXp - baseLevelXp,
                };
            };

            const getHealthMax = (xp) => {
                const level = xpToLevel(xp);
                return 90 + (level * 10);
            };

            const levelOneXp = levelToXp(1);

            const themeColors = {
                progressBarBackground: `rgba(0,0,0,.25)`,
                progressBarForeground: `rgba(35,255,155,1)`,
                selectedActivityCardBackground: `rgba(10,150,70,.75)`,
            };

            const stateKeys = {
                workPeriod: `workPeriod`,
                restPeriod: `restPeriod`,
                displayRemainingTime: `displayRemainingTime`,
                inventory: `inventory`,
                areas: `areas`,
            };

            const defaultValues = {
                workPeriod: 45 * 60,
                restPeriod: 15 * 60,
                displayRemainingTime: true,
                inventory: [],
                areas: {},
            };

            const skills = {
                strength: {
                    keyValue: `strength`,
                    displayValue: `Strength`,
                },
                toolUse: {
                    keyValue: `toolUse`,
                    displayValue: `Tool Use`,
                },
                fire: {
                    keyValue: `fire`,
                    displayValue: `Fire`,
                },
                combat: {
                    keyValue: `combat`,
                    displayValue: `Combat`,
                },
                health: {
                    keyValue: `health`,
                    displayValue: `Health`,
                },
                intelligence: {
                    keyValue: `intelligence`,
                    displayValue: `Intelligence`,
                },
                navigation: {
                    keyValue: `navigation`,
                    displayValue: `Navigation`,
                },
            };

            const getPlayerLevel = (state) => {
                let xp = 0;
                let d = 0;
                for (const n in skills) {
                    const skillXp = state.get(skills[n].xpKey);
                    if (skillXp) {
                        xp += skillXp;
                        d++;
                    }
                }
                const avg = xp / d;
                return Math.floor((xpToLevel(xp) + xpToLevel(avg)) / 2);
            };

            for (const n in skills) {
                const xpKey = skills[n].keyValue + `Xp`;
                skills[n].xpKey = xpKey;
                stateKeys[xpKey] = xpKey;
                defaultValues[xpKey] = levelOneXp;
            }

            const itemTypes = {
                rawFood: `Raw Food`, //<- required for cooking, for example
                preppedFood: `Prepped Food`,
                axe: `Axe`, //<- required for wood chopping
                pickaxe: `Pickaxe`,
                fishingPole: `Fishing Pole`, //<- required for fishing
                flint: `Flint`, //<- required for cooking and smithing
                wood: `Wood`, //<- required for cooking
                weapon: `Weapon`, //<- required for hunting or dungeon crawling
                rawOre: `Raw Ores`, //<- required for smithing
                ingot: `Forged Ingots`, //<- required for smithing some tools
                junk: `Junk`, //<- useless lol
            };

            const newItem = (itemName, itemTypes, qty) => {
                return {
                    name: itemName,
                    types: Array.from(itemTypes),
                    quantity: qty,
                };
            };

            //TODO: loot tables and other data are procedurally generated based on biome and level.
            const biomes = {
                desert: `Desert`,
                mountain: `Mountain`,
                forest: `Forest`,
                jungle: `Jungle`,
                grassland: `Grassland`,
                swamp: `Swamp`,
                tundra: `Tundra`,
                volcano: `Volcano`,
                beach: `Beach`,
            };

            const getBiomeKey = (biomeName) => {
                for (const biomeKey in biomes) {
                    if (biomes[biomeKey] === biomeName) {
                        return biomeKey;
                    }
                }
                return null;
            };

            const biomeCounts = {};
            for (const biome in biomes) {
                biomeCounts[biome] = 0;
            }

            //These are the activities a player can do during sessions.
            //Each one should appropriate XP toward a set of associated skills.
            //Requirements searches the inventory for required materials/tools.
            //Exploration has a chance to reveal a new region (procedurally generated).
            //Each new region contributes 1-5% toward total world exploration. Ensure procedural generation includes a minimum of one of each kind of biome.
            //Possible to discover regions that are much higher than current level (5-10 levels higher maybe more?).
            //While exploring might encounter baddies, take damage, etc.
            //Additional activities/skills for the future could include crafting and building, but that is getting into stretch goal territory. Watch the scope!
            const getExplorationPercentage = (state) => {
                const areas = state.get(stateKeys.areas);
                let value = 0;
                for (const area in areas) {
                    value += area.level;
                }
                return value;
            };

            const meetsMinSkillLevel = (area, activity, state) => {
                for (const skill of activity.skills) {
                    if (xpToLevel(state.get(skill.xpKey)) < activity.minSkillLevelCalc(area)) {
                        return false;
                    }
                }
                return true;
            };

            const meetsInventoryRequirements = (activity, state) => {
                const inventory = state.get(stateKeys.inventory);
                for (const type of activity.inventoryRequirements) {
                    const goodItem = inventory.find(x => x.types.indexOf(type) > -1);
                    if (!goodItem || goodItem.quantity < 1) {
                        return false;
                    }
                }
                return true;
            };

            const activityResult = (msg, lootItems) => {
                return {
                    message: msg,
                    loot: Array.from(lootItems),
                };
            };

            const activities = {
                cooking: {
                    title: `Cooking`,
                    areaDependent: false,
                    skills: [skills.toolUse, skills.fire, skills.intelligence],
                    inventoryRequirements: [itemTypes.rawFood, itemTypes.wood, itemTypes.flint],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => 1,
                    evaluateComplete: (area, state) => {
                        const rewards = lootTable.getLoot(`cooking`, area, state);
                        //TODO: list the cooked recipes here, or use the loot content on the results screen?
                        const message = rewards.length > 0
                            ? `You cooked some food!`
                            : `You failed to cook anything at all!`; //TODO: randomize failure messages?
                        return activityResult(message, rewards);
                    },
                },
                smithing: {
                    title: `Smithing`,
                    areaDependent: false,
                    skills: [skills.strength, skills.toolUse, skills.fire],
                    inventoryRequirements: [itemTypes.wood, itemTypes.flint, itemTypes.rawOre],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => 1,
                    evaluateComplete: (area, state) => {
                        //TODO: similar to cooking, pull raw ores from inventory and return forged ingots, weapons, tools, treasures, etc.
                    },
                },
                exploration: {
                    title: `Exploration`,
                    areaDependent: false,
                    skills: [skills.navigation, skills.intelligence],
                    inventoryRequirements: [itemTypes.preppedFood],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => 2,
                    evaluateComplete: (area, state) => {
                        //TODO: depending on time and level, randomly possible to unlock a new area (this is set in the state)
                        //Small chance of returning some foraged items as well?
                        const explorationPercentage = getExplorationPercentage(state);
                        if (explorationPercentage === 100) {
                            //can't do more exploration!
                        }
                        //TODO: also need to make sure the number arrives exactly at 100 by taking 100 - current percentage and making that the max level
                        //for the new area (though the current max area level needs to be taken into account as well!).
                        //TODO: remove some of the food from their inventory. The amount of food available should affect chance to discover a new place:
                        //for example, if only have like 5 food, it should be way less likely to find a place. But if the food quantity available to consume
                        //exceeds the number of minutes worked, then discovery chances should be "normal" but still based on player level and the level of the
                        //next area to be discovered.
                        return activityResult(`After wandering around for a long time, you return home defeated. Perhaps the developer has not yet added any new areas to discover?`, []);
                    },
                },
                woodChopping: {
                    title: `Wood Chopping`,
                    areaDependent: true,
                    skills: [skills.toolUse, skills.strength],
                    inventoryRequirements: [itemTypes.axe],
                    unavailableInArea: (area) => {
                        const notAvailable = [biomes.desert, biomes.tundra, biomes.volcano];
                        return !(notAvailable.find(x => x === area.biome) === undefined);
                    },
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        const rewards = lootTable.getLoot(`woodChopping`, area, state);
                        const message = rewards.length > 0
                            ? `You chopped some wood!`
                            : `You failed to get any wood at all!`; //TODO: randomize failure messages?
                        return activityResult(message, rewards);
                    },
                },
                foraging: {
                    title: `Foraging`,
                    areaDependent: true,
                    skills: [skills.intelligence, skills.navigation],
                    inventoryRequirements: [],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        const rewards = lootTable.getLoot(`foraging`, area, state);
                        const message = rewards.length > 0
                            ? `You foraged some things!`
                            : `You didn't find anything at all!`; //TODO: randomize failure messages?
                        return activityResult(message, rewards);
                    },
                },
                fishing: {
                    title: `Fishing`,
                    areaDependent: true,
                    skills: [skills.intelligence, skills.toolUse],
                    inventoryRequirements: [itemTypes.fishingPole],
                    unavailableInArea: (area) => {
                        const notAvailable = [biomes.desert, biomes.volcano];
                        return !(notAvailable.find(x => x === area.biome) === undefined);
                    },
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        //TODO: random raw fish based on the area
                    },
                },
                hunting: {
                    title: `Hunting`,
                    areaDependent: true,
                    skills: [skills.combat, skills.intelligence],
                    inventoryRequirements: [itemTypes.weapon],
                    unavailableInArea: (area) => {
                        const notAvailable = [biomes.volcano];
                        return !(notAvailable.find(x => x === area.biome) === undefined);
                    },
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        //TODO: random game meat based on the area (bore, deer, rabbit, etc.)
                    },
                },
                mining: {
                    title: `Mining`,
                    areaDependent: true,
                    skills: [skills.strength, skills.toolUse],
                    inventoryRequirements: [itemTypes.pickaxe],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        //TODO: random raw ores based on level and area
                    },
                },
                dungeonCrawling: {
                    title: `Dungeon Crawling`,
                    areaDependent: true,
                    skills: [skills.strength, skills.combat, skills.health, skills.intelligence],
                    inventoryRequirements: [itemTypes.weapon, itemTypes.preppedFood],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        //TODO: random prize loot based on the area (including special weapons?)
                    },
                },
            };

            function StateManager() {
                const stateKey = `IdlePomodoroAdventureState`;
                const myState = localStorage.hasOwnProperty(stateKey)
                    ? JSON.parse(localStorage[stateKey])
                    : {};

                const save = () => {
                    localStorage[stateKey] = JSON.stringify(myState);
                };

                this.get = (key) => {
                    if (!myState.hasOwnProperty(key)) {
                        this.set(key, defaultValues.hasOwnProperty(key) ? defaultValues[key] : null);
                    }
                    return myState[key];
                };

                this.set = (key, value) => {
                    myState[key] = value;
                    save();
                };

                this.addToInventory = (newItems) => {
                    const inv = this.get(stateKeys.inventory);
                    for (const item of newItems) {
                        const existingItem = inv.find(x => x.name === item.name);
                        if (existingItem) {
                            existingItem.quantity += item.quantity;
                        }
                        else {
                            inv.push(item);
                        }
                    }
                    this.set(stateKeys.inventory, inv.filter(x => x.quantity > 0));
                };

                this.addXp = (xpKey, amt) => {
                    const test = this.get(xpKey);
                    if (!isNaN(test)) {
                        myState[xpKey] += amt;
                        save();
                    }
                };
            }

            function TimerWorker() {
                let failoverMode = true;
                let curTimer = null;
                if (window.Worker) {
                    try {
                        curTimer = new Worker(`../scripts/pomodoro_timer_worker.js`);
                        curTimer.onmessage = (e) => {
                            this.onmessage(e);
                        };
                        failoverMode = false;
                    }
                    catch (e) {
                        failoverMode = true;
                    }
                }

                this.onmessage = (e) => {
                    console.log(e);
                };

                this.postMessage = (data) => {
                    if (!failoverMode) {
                        curTimer = new Worker(`../scripts/pomodoro_timer_worker.js`);
                        curTimer.onmessage = (e) => {
                            this.onmessage(e);
                        };
                        curTimer.postMessage(data);
                    }
                    else {
                        if (curTimer !== null) {
                            clearInterval(curTimer);
                            curTimer = null;
                        }
                        const d0 = data;
                        const countUpTimer = (d0) => {
                            const d = new Date();
                            const diff = d - d0;
                            this.onmessage({data: Math.floor(diff/1000)});
                        };
                        curTimer = setInterval(() => {countUpTimer(d0)}, 1000);
                    }
                };

                this.terminate = () => {
                    if (!failoverMode) {
                        curTimer.terminate();
                    }
                    else {
                        clearInterval(curTimer);
                        curTimer = null;
                    }
                };
            }

            const screenTypes = {
                welcome: `Welcome`,
                setup: `Setup`,
                activitySelection: `Activity Selection`,
                activityWorkTimer: `Working`,
                activityResults: `Adventure Results`,
                postActivityRest: `Resting`,
            };

            const displaySeconds = (seconds) => {
                if (isNaN(seconds) || seconds <= 0) {
                    return `Time is up!`;
                }
                const minutes = Math.floor(seconds / 60);
                seconds -= minutes * 60;

                const m = minutes + ' ' + (minutes === 1 ? 'minute' : 'minutes');
                const s = seconds + ' ' + (seconds === 1 ? 'second': 'seconds');
                if (minutes <= 0) {
                    return s;
                }
                if (seconds <= 0) {
                    return m;
                }

                return m + ' ' + s;
            };

            function WelcomeScreen(p, a) {
                const parent = p;
                const myApp = a;
                const myContainer = createElement('div', {'style': `display:flex;flex-direction:column;align-items:center;`}, null);
                let showing = false;

                const populate = () => {
                    const goButtonText = `Begin`;
                    myContainer.innerHTML = '';
                    //TODO: replace with a nice, big graphic?
                    const title = createElement('h1', {}, 'Welcome!');
                    myContainer.appendChild(title);

                    const workTimerSeconds = myApp.getStateData(stateKeys.workPeriod);
                    const restTimerSeconds = myApp.getStateData(stateKeys.restPeriod);

                    const texts = [
                        `Welcome to ${appTitle}! Embark on adventures, complete tasks, level up, and conquer your work!`,
                        `Currently, the work period is set for ${displaySeconds(workTimerSeconds)} and the rest period is set for ${displaySeconds(restTimerSeconds)}. If you would like to adjust these times, go to setup. Otherwise, click '${goButtonText}' and get started on your adventure.`,
                        `Good luck, adventurer!`,
                    ];
                    for (const text of texts) {
                        const p = createElement('p', {}, text);
                        myContainer.appendChild(p);
                    }

                    const button = createElement('button', {'type': 'submit'}, goButtonText);
                    button.addEventListener('click', () => myApp.switchToScreen(screenTypes.activitySelection));
                    myContainer.appendChild(button);

                    //TODO: gear icon?
                    const setup = createElement('input', {'type': 'button', 'value': 'Setup'}, null);
                    setup.addEventListener('click', () => myApp.switchToScreen(screenTypes.setup));
                    myContainer.appendChild(setup);
                };
                
                this.show = () => {
                    if (!showing) {
                        populate();
                        parent.appendChild(myContainer);
                        showing = true;
                    }
                };

                this.hide = () => {
                    if (showing) {
                        parent.removeChild(myContainer);
                        showing = false;
                    }
                };
            }

            function SetupScreen(p, a) {
                const parent = p;
                const myApp = a;
                const myContainer = createElement('div', {'style': `display:flex;flex-direction:column;align-items:center;`}, null);
                let showing = false;

                //TODO: maybe remove the five and ten second options later?
                const timerValues = {
                    '5': 'Five Second Test',
                    '10': 'Ten Second Test',
                    '60': 'One Minute',
                    '300': 'Five Minutes',
                    '600': 'Ten Minutes',
                    '900': 'Fifteen Minutes',
                    '1200': 'Twenty Minutes',
                    '1500': 'Twenty-Five Minutes',
                    '1800': 'Thirty Minutes',
                    '2100': 'Thirty-Five Minutes',
                    '2400': 'Forty Minutes',
                    '2700': 'Forty-Five Minutes',
                    '3000': 'Fifty Minutes',
                    '3300': 'Fifty-Five Minutes',
                    '3600': 'Sixty Minutes',
                    '4500': 'Seventy-Five Minutes',
                    '5400': 'Ninety Minutes',
                };

                const showHideValues = {
                    'true': 'Show',
                    'false': 'Hide',
                };

                //TODO: replace with a nice, big graphic?
                const title = createElement('h1', {}, 'App Setup');
                myContainer.appendChild(title);

                const workPeriodLabel = createElement('label', { 'for': stateKeys.workPeriod }, 'Work Period');
                const workPeriodSelect = makeSelect(stateKeys.workPeriod, timerValues);
                workPeriodSelect.addEventListener('change', () => setTimerValue(stateKeys.workPeriod, workPeriodSelect));
                myContainer.appendChild(workPeriodLabel);
                myContainer.appendChild(workPeriodSelect);

                const restPeriodLabel = createElement('label', { 'for': stateKeys.restPeriod }, 'Rest Period');
                const restPeriodSelect = makeSelect(stateKeys.restPeriod, timerValues);
                restPeriodSelect.addEventListener('change', () => setTimerValue(stateKeys.restPeriod, restPeriodSelect));
                myContainer.appendChild(restPeriodLabel);
                myContainer.appendChild(restPeriodSelect);
                
                const showRemainingTimeLabel = createElement('label', { 'for': stateKeys.displayRemainingTime }, 'Remaining Time');
                const showRemainingTimeSelect = makeSelect(stateKeys.displayRemainingTime, showHideValues);
                showRemainingTimeSelect.addEventListener('change', () => setShowHideValue(stateKeys.displayRemainingTime, showRemainingTimeSelect));
                myContainer.appendChild(showRemainingTimeLabel);
                myContainer.appendChild(showRemainingTimeSelect);

                const button = createElement('button', {'type': 'submit'}, `Back`);
                button.addEventListener('click', () => myApp.goBack());
                myContainer.appendChild(button);

                const setTimerValue = (key, select) => {
                    const value = parseInt(select.options[select.selectedIndex].value);
                    const state = myApp.getState();
                    state.set(key, value);
                };

                const setShowHideValue = (key, select) => {
                    const value = select.options[select.selectedIndex].value === 'true';
                    const state = myApp.getState();
                    state.set(key, value);
                };

                const getOptionIndex = (options, val) => {
                    for (let i=0; i<options.length; i++) {
                        if (options[i].value === val.toString()) {
                            return i;
                        }
                    }
                    return -1;
                };
                
                this.show = () => {
                    if (!showing) {
                        const currentWorkPeriod = myApp.getStateData(stateKeys.workPeriod);
                        const currentRestPeriod = myApp.getStateData(stateKeys.restPeriod);
                        const currentDisplayRemainingTime = myApp.getStateData(stateKeys.displayRemainingTime);
                        
                        const selectedWorkPeriod = getOptionIndex(workPeriodSelect.options, currentWorkPeriod);
                        workPeriodSelect.selectedIndex = selectedWorkPeriod;

                        const selectedRestPeriod = getOptionIndex(restPeriodSelect.options, currentRestPeriod);
                        restPeriodSelect.selectedIndex = selectedRestPeriod;
                        
                        const selectedShowHideRemainingTime = getOptionIndex(showRemainingTimeSelect.options, currentDisplayRemainingTime);
                        showRemainingTimeSelect.selectedIndex = selectedShowHideRemainingTime;

                        parent.appendChild(myContainer);
                        showing = true;
                    }
                };

                this.hide = () => {
                    if (showing) {
                        parent.removeChild(myContainer);
                        showing = false;
                    }
                };
            }

            function ActivitySelectScreen(p, a, picker) {
                const parent = p;
                const myApp = a;
                const activitySelector = picker;
                const myContainer = createElement('div', {'style': `display:flex;flex-direction:column;align-items:center;`}, null);
                const selectorContainer = createElement('div', {}, null);
                let showing = false;

                //TODO: replace with a nice, big graphic?
                const title = createElement('h1', {}, 'Select an Activity');
                myContainer.appendChild(title);

                myContainer.appendChild(selectorContainer);

                //TODO: can make the button inactive until an activity is selected?
                const button = createElement('button', {'type': 'submit'}, `Go!`);
                button.addEventListener('click', () => myApp.switchToScreen(screenTypes.activityWorkTimer));
                myContainer.appendChild(button);

                //TODO: gear icon?
                const setup = createElement('input', {'type': 'button', 'value': 'Setup'}, null);
                setup.addEventListener('click', () => myApp.switchToScreen(screenTypes.setup));
                myContainer.appendChild(setup);
                
                this.show = () => {
                    if (!showing) {
                        activitySelector.init();
                        activitySelector.attach(selectorContainer);
                        parent.appendChild(myContainer);
                        showing = true;
                    }
                };

                this.hide = () => {
                    if (showing) {
                        parent.removeChild(myContainer);
                        showing = false;
                    }
                };
            }

            function WorkingScreen(p, a) {
                const parent = p;
                const myApp = a;
                const myContainer = createElement('div', {'style': `display:flex;flex-direction:column;align-items:center;`}, null);
                let showing = false;

                //TODO: replace with a nice, big graphic?
                const title = createElement('h1', {}, 'Working');
                myContainer.appendChild(title);

                const activityTitle = createElement('h3', {}, null);
                myContainer.appendChild(activityTitle);

                const timeRemainingDisplay = createElement('div', {}, null);
                myContainer.appendChild(timeRemainingDisplay);

                //TODO: randomize subtitle?
                const subtitle = createElement('h2', {}, 'Focus!');
                myContainer.appendChild(subtitle);

                //TODO: maybe include some kind of graphics based on the current acitivy?
                //If so, how to get current activity data to the screen? Maybe use myApp and a getter?
                
                this.show = () => {
                    if (!showing) {
                        parent.appendChild(myContainer);
                        showing = true;
                        const activityText = myApp.getCurrentActivityTitle();
                        activityTitle.innerHTML = activityText;
                        if (myApp.getStateData(stateKeys.displayRemainingTime)) {
                            timeRemainingDisplay.innerHTML = '';
                            const remainingDisplay = makeFieldset('Work Time Remaining', {'style': `border-radius: 5px; width: ${Math.floor(gameWidth/2)}px;`});
                            timeRemainingDisplay.appendChild(remainingDisplay);
                            const timeDisplay = createElement('span', {'style': `font-weight:bold;font-size:1.25em;`}, 'Ready?'); //TODO: mess with the font more?
                            remainingDisplay.appendChild(timeDisplay);
                            myApp.onTick = () => {
                                timeDisplay.innerHTML = myApp.getRemainingTimeDisplay();
                            };
                        }
                    }
                };

                this.hide = () => {
                    if (showing) {
                        parent.removeChild(myContainer);
                        showing = false;
                    }
                };
            }

            function ResultsScreen(p, a, picker) {
                const parent = p;
                const myApp = a;
                const activitySelector = picker;
                const myContainer = createElement('div', {'style': `display:flex;flex-direction:column;align-items:center;`}, null);
                const selectorContainer = createElement('div', {}, null);
                let showing = false;
                
                //TODO: replace with a nice, big graphic?
                const title = createElement('h1', {}, 'Results!');
                myContainer.appendChild(title);
                
                const resultsContainer = makeFieldset('Results', {'style': `border-radius: 5px;`});
                myContainer.appendChild(resultsContainer);

                const resultsDisplay = createElement('div', {}, null);
                resultsContainer.appendChild(resultsDisplay);

                myContainer.appendChild(selectorContainer);

                //TODO: can make the button inactive until an activity is selected?
                const button = createElement('button', {'type': 'submit'}, `Rest!`);
                button.addEventListener('click', () => myApp.switchToScreen(screenTypes.postActivityRest));
                myContainer.appendChild(button);

                //TODO: gear icon?
                const setup = createElement('input', {'type': 'button', 'value': 'Setup'}, null);
                setup.addEventListener('click', () => myApp.switchToScreen(screenTypes.setup));
                myContainer.appendChild(setup);
                
                this.show = () => {
                    if (!showing) {
                        activitySelector.init();
                        activitySelector.attach(selectorContainer);
                        parent.appendChild(myContainer);
                        showing = true;
                        resultsDisplay.innerHTML = '';
                        const results = myApp.getLatestActivityResult();
                        
                        resultsDisplay.appendChild(createElement('h3', {}, results.message));
                        const lootDisplay = makeFieldset('Loot', {'style': `border-radius: 5px;`});
                        resultsDisplay.appendChild(lootDisplay);
                        const lootList = createElement('ul', {}, null);
                        lootDisplay.appendChild(lootList);

                        const loot = {};
                        for (const item of results.loot) {
                            if (!loot.hasOwnProperty(item.name)) {
                                loot[item.name] = 0;
                            }
                            loot[item.name] += item.quantity;
                        }

                        for (const name in loot) {
                            lootList.appendChild(createElement('li', {}, `${name} x ${loot[name]}`));
                        }
                        //TODO: data about experience gained?
                    }
                };

                this.hide = () => {
                    if (showing) {
                        parent.removeChild(myContainer);
                        showing = false;
                    }
                };
            }

            function RestingScreen(p, a) {
                const parent = p;
                const myApp = a;
                const myContainer = createElement('div', {'style': `display:flex;flex-direction:column;align-items:center;`}, null);
                let showing = false;

                //TODO: replace with a nice, big graphic?
                const title = createElement('h1', {}, 'Resting');
                myContainer.appendChild(title);

                const timeRemainingDisplay = createElement('div', {}, null);
                myContainer.appendChild(timeRemainingDisplay);

                //TODO: randomize subtitle?
                const subtitle = createElement('h2', {}, 'Take a meaningful break!');
                myContainer.appendChild(subtitle);

                //TODO: maybe show what upcoming activity will be executed during the next work period?
                //If so, how to get current activity data to the screen? Maybe use myApp and a getter?
                
                this.show = () => {
                    if (!showing) {
                        parent.appendChild(myContainer);
                        showing = true;
                        if (myApp.getStateData(stateKeys.displayRemainingTime)) {
                            timeRemainingDisplay.innerHTML = '';
                            const remainingDisplay = makeFieldset('Break Time Remaining', {'style': `border-radius: 5px; width: ${Math.floor(gameWidth/2)}px;`});
                            timeRemainingDisplay.appendChild(remainingDisplay);
                            const timeDisplay = createElement('span', {'style': `font-weight:bold;font-size:1.25em;`}, 'Ready?'); //TODO: mess with the font more?
                            remainingDisplay.appendChild(timeDisplay);
                            myApp.onTick = () => {
                                timeDisplay.innerHTML = myApp.getRemainingTimeDisplay();
                            };
                        }
                    }
                };

                this.hide = () => {
                    if (showing) {
                        parent.removeChild(myContainer);
                        showing = false;
                    }
                };
            }

            function IdlePomodoroAdventureApp() {
                const state = new StateManager();

                const starterAreaName = `Novicewood Forest`;

                const timerWorker = new TimerWorker();
                timerWorker.onmessage = (e) => {
                    evalTimer(e.data);
                };

                const workDoneSound = new Audio('../audio-clips/work-done.ogg');
                const restDoneSound = new Audio('../audio-clips/rest-done.ogg');

                const activityPicker = new ActivityPicker(this);

                //TODO: should any of these be stored in state in case of accidental refresh?
                //maybe clear all values if too much time has passed since timer start?
                //Possibly, we can save the last save date/time in the state and reset certain values if it's been too long?
                let timerStart = new Date();
                let timerTarget = 0;
                let remainingSeconds = 0;
                let currentTimerKey = '';

                let currentAreaData = null;
                let currentActivityKey = null;
                let currentActivityResult = null;

                let currentScreen = screenTypes.welcome;
                const currentScreenContainer = createElement('div', {}, null);
                const screens = {};
                screens[screenTypes.welcome] = new WelcomeScreen(currentScreenContainer, this);
                screens[screenTypes.setup] = new SetupScreen(currentScreenContainer, this);
                screens[screenTypes.activitySelection] = new ActivitySelectScreen(currentScreenContainer, this, activityPicker);
                screens[screenTypes.activityWorkTimer] = new WorkingScreen(currentScreenContainer, this);
                screens[screenTypes.activityResults] = new ResultsScreen(currentScreenContainer, this, activityPicker);
                screens[screenTypes.postActivityRest] = new RestingScreen(currentScreenContainer, this);

                //TODO: attach and detach available, probably in some kind of footer or extra container?
                const playerDisplayCard = new PlayerDisplayCard(state);
                playerDisplayCard.update();

                const mainDiv = createElement('div', {'style': `width:${gameWidth}px;height:100%;padding:0px;margin:0px auto;display:flex;flex-wrap:wrap;flex-direction:column;`}, null);
                document.body.appendChild(mainDiv);

                const headerDiv = createElement('div', {'style': `width:100%;display:flex;flex-direction:row;gap:8px;padding:0px;margin:0px;`}, null);
                mainDiv.appendChild(headerDiv);

                const title = createElement('h1', {'style': `display:block;`}, `Idle Pomodoro Adventure`); //TODO: make this a pixel art image?
                headerDiv.appendChild(title);
                const timerBarContainer = createElement('div', {'style': `margin-block-start:0.67em;display:flex;align-items:center;`}, null);
                headerDiv.appendChild(timerBarContainer);
                const timerBar = new ProgressBar(timerBarContainer, 400, 32);
                timerBar.update({value: 0, max: 100});

                mainDiv.appendChild(currentScreenContainer);
                
                const showPlayerDisplay = () => {
                    playerDisplayCard.attach(mainDiv);
                };
                showPlayerDisplay();

                const hidePlayerDisplay = () => {
                    playerDisplayCard.detach(mainDiv);
                };

                this.getStateData = (key) => state.get(key);
                this.getState = () => state;

                let returnToScreen = null;
                this.switchToScreen = (newScreen) => {
                    for (const screen in screens) {
                        screens[screen].hide();
                    }
                    
                    switch (newScreen) {
                        case screenTypes.activitySelection:
                            //This ensures the tab can play these sounds later even if the tab is not showing.
                            workDoneSound.play();
                            restDoneSound.play();
                            break;
                            
                        case screenTypes.activityWorkTimer:
                            const data = activityPicker.getSelection();
                            currentActivityResult = null;
                            currentAreaData = data.area;
                            currentActivityKey = data.activityKey;
                            hidePlayerDisplay();
                            startWorkPeriod();
                            break;
                        
                        case screenTypes.activityResults:
                            showPlayerDisplay();
                            break;

                        case screenTypes.postActivityRest:
                            startRestPeriod();
                            break;

                        case screenTypes.setup:
                            returnToScreen = currentScreen;
                            break;
                    }
                    currentScreen = newScreen;
                    screens[currentScreen].show();
                    document.title = `${appTitle}: [${currentScreen}]`;
                };

                this.goBack = () => {
                    if (returnToScreen !== null) {
                        this.switchToScreen(returnToScreen);
                        returnToScreen = null;
                    }
                };

                this.getLatestActivityResult = () => currentActivityResult;
                this.getCurrentActivityTitle = () => {
                    if (currentAreaData === null || currentActivityKey === null) {
                        return 'No Activity Selected';
                    }
                    let title = activities[currentActivityKey].title;
                    if (activities[currentActivityKey].areaDependent) {
                        title += ': ' + currentAreaData.name;
                    }
                    return title;
                };

                this.getRemainingTimeDisplay = () => {
                    if (state.get(stateKeys.displayRemainingTime)) {
                        return displaySeconds(remainingSeconds);
                    }
                    return null;
                };

                this.onTick = null;

                const startWorkPeriod = () => {
                    startTimer(stateKeys.workPeriod);
                };

                const startRestPeriod = () => {
                    startTimer(stateKeys.restPeriod);
                };

                const startTimer = (timerKey) => {
                    currentTimerKey = timerKey;
                    timerTarget = state.get(currentTimerKey);
                    timerStart = new Date();
                    timerWorker.postMessage(timerStart);
                };

                const evalTimer = (timerValue) => {
                    if (timerValue > timerTarget) {
                        timerValue = 0;
                        remainingSeconds = 0;
                        timerWorker.terminate();
                        switch (currentTimerKey) {
                            case stateKeys.workPeriod:
                                workDoneSound.load();
                                workDoneSound.play();
                                if (currentActivityKey === null) {
                                    currentActivityResult = activityResult('No activity selected!', []);
                                    this.switchToScreen(screenTypes.activityResults);
                                    break;
                                }
                                currentActivityResult = activities[currentActivityKey].evaluateComplete(currentAreaData, state);
                                state.addToInventory(currentActivityResult.loot);
                                //TODO: need a "dev mode" to allow an override here I think!
                                const xpGained = Math.max(10, Math.floor(timerTarget/60)) * currentAreaData.level; //TODO: tell the player how much XP was gained?
                                for (const skill of activities[currentActivityKey].skills) {
                                    state.addXp(skill.xpKey, xpGained);
                                }
                                currentActivityKey = null;
                                currentAreaData = null;
                                playerDisplayCard.update();
                                this.switchToScreen(screenTypes.activityResults);
                                break;

                            case stateKeys.restPeriod:
                                restDoneSound.load();
                                restDoneSound.play();
                                //TODO: if the player has health missing, should it be restored at the end of the rest period according to the food they have available?
                                //TODO: do not go to work timer immediately? Let the user acknowledge the end of break time?
                                this.switchToScreen(screenTypes.activityWorkTimer);
                                break;
                        }
                    }
                    remainingSeconds = timerTarget - timerValue;
                    if (this.onTick) {
                        this.onTick();
                    }
                    const timerBarValues = {
                        value: timerValue,
                        max: timerTarget,
                    };
                    timerBar.update(timerBarValues);
                };

                const addArea = (lvl, bio, nm) => {
                    const areas = state.get(stateKeys.areas);
                    if (!areas.hasOwnProperty(nm)) {
                        const newArea = areaGenerator.generate(lvl, bio, nm);
                        areas[newArea.name] = newArea;
                        state.set(stateKeys.areas, areas);
                    }
                };

                const equipNewPlayer = () => {
                    const inv = state.get(stateKeys.inventory);
                    const loot = [];
                    if (!meetsInventoryRequirements(activities.woodChopping, state)) {
                        loot.push(newItem('Woodcutting Axe', [itemTypes.axe], 1));
                    }
                    //TODO: can keep populating loot based on requirements not met for basic activities.
                    //Might want to have the player earn/create the tools for other activities though.
                    state.addToInventory(loot);
                };

                //Setup:
                //Add the starter area
                addArea(1, biomes.forest, starterAreaName); //Will skip if area already exists.
                equipNewPlayer();

                //Show welcome screen
                this.switchToScreen(screenTypes.welcome);
                
            }
            
            function ActivityPicker(myApp) {
                const theApp = myApp;
                const myContainer = createElement('div', {}, null);
                let activityCollection = [];
                //TODO: format with a scrollbar so it doesn't get too big in late game?
                const activityListDisplay = createElement('div', {}, null);
                myContainer.appendChild(activityListDisplay);

                this.attach = (parent) => {
                    parent.appendChild(myContainer);
                };

                this.detach = (parent) => {
                    parent.removeChild(myContainer);
                };

                this.init = () => {
                    const state = theApp.getState();
                    activityCollection = [];
                    activityListDisplay.innerHTML = '';
                    const areas = state.get(stateKeys.areas);
                    const explorationPercentage = getExplorationPercentage(state);
                    const doneOnce = {};
                    for (const area in areas) {
                        //evaluate each activity in every area
                        for (const activity in activities) {
                            if (!activities[activity].areaDependent && !doneOnce.hasOwnProperty(activity)) {
                                doneOnce[activity] = false;
                            }
                            if (activity === 'exploration' && explorationPercentage >= 100) {
                                continue;
                            }
                            if (activities[activity].unavailableInArea(areas[area])) {
                                continue;
                            }
                            if (doneOnce.hasOwnProperty(activity) && doneOnce[activity]) {
                                continue;
                            }
                            const meetsSkillLevelRequirement = meetsMinSkillLevel(areas[area], activities[activity], state);
                            const meetsInventoryRequirement = meetsInventoryRequirements(activities[activity], state);
                            const card = new ActivityCard(areas[area], activity, activityListDisplay, this, meetsSkillLevelRequirement, meetsInventoryRequirement);
                            activityCollection.push(card);
                            if (!activities[activity].areaDependent) {
                                doneOnce[activity] = true;
                            }
                        }
                    }
                };

                this.deselectAll = () => {
                    for (const activity of activityCollection) {
                        activity.deselect();
                    }
                };

                this.getSelection = () => {
                    let selected = activityCollection.find(x => x.isSelected());
                    if (!selected) {
                        const options = activityCollection.filter(x => !x.isDisabled());
                        selected = options[Math.floor(Math.random() * options.length)];
                    }
                    return selected.getData();
                };
            }

            function ActivityCard(areaData, activityId, parent, picker, meetsSkillLevelRequirement, meetsInventoryRequirement) {
                const areaName = areaData.name;
                const area = areaData;
                const activityKey = activityId;
                const activity = activities[activityKey];
                const activityName = activity.title;
                const myParentPicker = picker;
                const skillOk = meetsSkillLevelRequirement;
                const inventoryOk = meetsInventoryRequirement;
                const disabled = !skillOk || !inventoryOk;
                const myContainer = createElement('div', {}, null);
                parent.appendChild(myContainer);
                let selected = false;

                let legendText = activityName
                if (activity.areaDependent){
                    legendText += ': ' + areaName;
                }
                if (disabled) {
                    legendText += ' (unavailable)';
                }
                const cardContents = createElement('div', {}, null);
                const card = makeDetail(legendText, cardContents, !disabled);
                myContainer.appendChild(card);
                
                //TODO: need to individually identify each skill or item that is missing rather than just marking the whole line as the problem.
                const lvl = activity.minSkillLevelCalc(area);
                const skillsAttributes = {};
                if (!skillOk) {
                    skillsAttributes['style'] = `color: red;`;
                }
                cardContents.appendChild(createElement('p', skillsAttributes, 'Skills: ' + activity.skills.map(x => x.displayValue + ` (${lvl})`).join(', ')));

                if (activity.inventoryRequirements.length > 0) {
                    const inventoryAttributes = {};
                    if (!inventoryOk) {
                        inventoryAttributes['style'] = `color: red;`;
                    }
                    cardContents.appendChild(createElement('p', inventoryAttributes, 'Items: ' + activity.inventoryRequirements.join(', ')));
                }

                const buttonAttributes = {'type': 'button', 'value': 'Select'};
                if (disabled) {
                    buttonAttributes['disabled'] = true;
                }
                const selectButton = createElement('input', buttonAttributes, null);
                selectButton.addEventListener('click', () => select());
                cardContents.appendChild(selectButton);

                this.isSelected = () => selected;
                this.isDisabled = () => disabled;
                this.getData = () => {
                    return {
                        area: area,
                        activityKey: activityKey,
                    };
                };

                const select = () => {
                    myParentPicker.deselectAll();
                    selected = true;
                    selectButton.value = 'Selected!';
                    card.style.backgroundColor = themeColors.selectedActivityCardBackground;
                };

                this.deselect = () => {
                    selected = false;
                    selectButton.value = 'Select';
                    card.style.backgroundColor = '';
                };
            }

            function ProgressBar(parent, width, height) {
                const borderRadius = '5';
                const barContainer = createElement('div', { 'style': `background-color: ${themeColors.progressBarBackground}; border: 1px solid black; border-radius: ${borderRadius}px; width: ${width}px; height: ${height}px;` }, null);
                const bar = createElement('div', { 'style': `border-radius: ${borderRadius}px; text-align: center; background-color: ${themeColors.progressBarForeground}; height:100%; width:50%` }, null);
                barContainer.appendChild(bar);
                parent.appendChild(barContainer);
                
                this.update = (data) => {
                    bar.style.width = `${Math.floor((Math.min(data.value, data.max)/data.max) * 100)}%`;
                };
            }

            function PlayerDisplayCard(s) {
                const state = s;
                const myContainer = createElement('div', {}, null);
                const skillContainer = createElement('div', {}, null);
                const skillFieldset = makeFieldset('Skills', {'style': `border-radius:5px;`});
                skillFieldset.appendChild(skillContainer);
                const inventoryContainer = createElement('div', {}, null);
                const inventoryFieldset = makeFieldset('Inventory', {'style': `border-radius:5px;flex-grow:2;`});
                inventoryFieldset.appendChild(inventoryContainer);
                const statDisplays = {};
                for (const stat in skills) {
                    statDisplays[skills[stat].xpKey] = new PlayerStatDisplay(skills[stat].displayValue, skillContainer);
                }
                const inventoryDisplay = new PlayerInventoryDisplay(inventoryContainer);
                //TODO: the rest of the owl

                //TODO: populate the container, maybe with a fieldset first?
                //Then fill the statDisplays array.
                
                const cardFieldset = makeFieldset('Player Info', {'style': `border-radius:5px;`});
                myContainer.appendChild(cardFieldset);
                const cardContents = createElement('div', {'style': `display:flex;flex-direction:row;align-items:stretch;align-content:stretch;`}, null);
                cardFieldset.appendChild(cardContents);
                cardContents.appendChild(skillFieldset);
                cardContents.appendChild(inventoryFieldset);

                this.update = () => {
                    const newInventoryData = state.get(stateKeys.inventory);
                    inventoryDisplay.update(newInventoryData);

                    for (const stat in statDisplays) {
                        statDisplays[stat].update(state.get(stat));
                    }
                };

                this.attach = (parent) => {
                    parent.appendChild(myContainer);
                };

                this.detach = (parent) => {
                    parent.removeChild(myContainer);
                };
            }

            function PlayerStatDisplay(statName, parent) {
                const displayName = statName;
                const myContainer = createElement('div', {}, null);
                let previousXp = null;
                parent.appendChild(myContainer);
                const myLabel = createElement('span', {}, null);
                myContainer.appendChild(myLabel);
                const myBar = new ProgressBar(myContainer, 256, 16);
                //TODO: better formatting?
                this.update = (xp) => {
                    myLabel.style.fontWeight = '';
                    const lvl = xpToLevel(xp);
                    let increasedXp = false;
                    let leveledUp = false;
                    if (previousXp === null) {
                        previousXp = xp;
                    }
                    if (xp > previousXp) {
                        increasedXp = true;
                        myLabel.style.fontWeight = 'bold';
                        const previousLevel = xpToLevel(previousXp);
                        if (lvl > previousLevel) {
                            leveledUp = true;
                        }
                    }
                    let text = `${statName}: (${lvl})`;
                    if (increasedXp) {
                        text = `+${(xp - previousXp)}xp ` + text;
                    }
                    if (leveledUp) {
                        text += ` LEVEL UP!`;
                    }
                    myLabel.innerHTML = text;
                    previousXp = xp;
                    const nextLvlProgress = getRelativeXpReport(xp);
                    myBar.update(nextLvlProgress);
                };
            }

            function PlayerInventoryDisplay(parent) {
                const myContainer = createElement('div', {'style': `display:flex;flex-direction:row;flex-wrap:wrap;gap:5px;`}, null);
                parent.appendChild(myContainer);
                this.update = (inventoryData) => {
                    myContainer.innerHTML = '';
                    //TODO: might want icons/graphics for each inventory item type?
                    for (const item of inventoryData) {
                        //TODO: once there are icons for the item types, I should incorporate those into the design.
                        if (item.quantity > 0) {
                            const text = `${item.name} x ${item.quantity}`;
                            const itemTile = createElement('div', {'style': `border:1px solid black; border-radius: 5px; padding: 5px;`}, text);
                            myContainer.appendChild(itemTile);
                        }
                    }
                };
            }

            function LootTable() {
                const lootTables = {
                    cooking: {},
                    smithing: {},
                    exploration: {},
                    woodChopping: {
                        mountain: {
                            bountiful: [
                                {n: `Pine Wood`, t: [itemTypes.wood]},
                                {n: `Spruce Wood`, t: [itemTypes.wood]},
                            ],
                            common: [
                                {n: `Oak Wood`, t: [itemTypes.wood]},
                                {n: `Walnut Wood`, t: [itemTypes.wood]},
                            ],
                            rare: [
                                {n: `Cedar Wood`, t: [itemTypes.wood]},
                            ],
                        },
                        forest: {
                            bountiful: [
                                {n: `Pine Wood`, t: [itemTypes.wood]},
                                {n: `Spruce Wood`, t: [itemTypes.wood]},
                            ],
                            common: [
                                {n: `Oak Wood`, t: [itemTypes.wood]},
                                {n: `Maple Wood`, t: [itemTypes.wood]},
                            ],
                            rare: [
                                {n: `Cherry Wood`, t: [itemTypes.wood]},
                            ],
                        },
                        jungle: {
                            bountiful: [
                                {n: `Kapok Wood`, t: [itemTypes.wood]}, //lightweight and useless, except for burning
                            ],
                            common: [
                                {n: `Mahogany Wood`, t: [itemTypes.wood]},
                            ],
                            rare: [
                                {n: `Rosewood`, t: [itemTypes.wood]},
                            ],
                        },
                        grassland: {
                            bountiful: [
                                {n: `Acacia Wood`, t: [itemTypes.wood]},
                            ],
                            common: [
                                {n: `Birch Wood`, t: [itemTypes.wood]},
                            ],
                            rare: [
                                {n: `Applewood`, t: [itemTypes.wood]},
                            ],
                        },
                        swamp: {
                            bountiful: [
                                {n: `Willow Wood`, t: [itemTypes.wood]},
                            ],
                            common: [
                                {n: `Cottonwood`, t: [itemTypes.wood]}, //lightweight and useless, except for burning
                            ],
                            rare: [
                                {n: `Cypress Wood`, t: [itemTypes.wood]},
                            ],
                        },
                        beach: {
                            bountiful: [
                                {n: `Palmwood`, t: [itemTypes.wood]}, //lightweight and useless, except for burning
                            ],
                            common: [
                                {n: `Oak Wood`, t: [itemTypes.wood]},
                            ],
                            rare: [
                                {n: `Black Palmwood`, t: [itemTypes.wood]},
                            ],
                        },
                    },
                    foraging: {
                        desert: {
                            bountiful: [
                                {n: `Dead Twig`, t: [itemTypes.junk]},
                            ],
                            common: [
                                {n: `Cactus Fruit`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                            ],
                            rare: [
                                {n: `Coconut`, t: [itemTypes.preppedFood]},
                            ],
                        },
                        mountain: {
                            bountiful: [
                                {n: `Blackberry`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                                {n: `Stick`, t: [itemTypes.wood]},
                                {n: `Rock`, t: [itemTypes.junk]},
                            ],
                            common: [
                                {n: `Iron Ore`, t: [itemTypes.rawOre]},
                                {n: `Strawberry`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                                {n: `Cap Mushroom`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                            ],
                            rare: [
                                {n: `Flint`, t: [itemTypes.flint]},
                            ],
                        },
                        forest: {
                            bountiful: [
                                {n: `Button Mushroom`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                                {n: `Stick`, t: [itemTypes.wood]},
                                {n: `Rock`, t: [itemTypes.junk]},
                            ],
                            common: [
                                {n: `Blueberry`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                                {n: `Onion`, t: [itemTypes.rawFood]},
                                {n: `Strawberry`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                                {n: `Apple`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                            ],
                            rare: [
                                {n: `Flint`, t: [itemTypes.flint]},
                                {n: `Iron Ore`, t: [itemTypes.rawOre]},
                                {n: `Honeycomb`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                            ],
                        },
                        jungle: {
                            bountiful: [
                                {n: `Stick`, t: [itemTypes.wood]},
                                {n: `Rock`, t: [itemTypes.junk]},
                            ],
                            common: [
                                {n: `Vine`, t: [itemTypes.junk]},
                                {n: `Banana`, t: [itemTypes.preppedFood]},
                                {n: `Acai`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                            ],
                            rare: [
                                {n: `Coconut`, t: [itemTypes.preppedFood]},
                                {n: `Onion`, t: [itemTypes.rawFood]},
                                {n: `Iron Ore`, t: [itemTypes.rawOre]},
                                {n: `Raw Cashew Nut`, t: [itemTypes.rawFood]},
                            ],
                        },
                        grassland: {
                            bountiful: [
                                {n: `Cowpie`, t: [itemTypes.junk]},
                                {n: `Strawberry`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                                {n: `Rock`, t: [itemTypes.junk]},
                                {n: `Stick`, t: [itemTypes.wood]},
                            ],
                            common: [
                                {n: `Potato`, t: [itemTypes.rawFood]},
                                {n: `Grape`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                                {n: `Carrot`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                                {n: `Onion`, t: [itemTypes.rawFood]},
                                {n: `Blueberry`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                            ],
                            rare: [
                                {n: `Flint`, t: [itemTypes.flint]},
                                {n: `Iron Ore`, t: [itemTypes.rawOre]},
                                {n: `Honeycomb`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                            ],
                        },
                        swamp: {
                            bountiful: [
                                {n: `Raspberry`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                                {n: `Rock`, t: [itemTypes.junk]},
                            ],
                            common: [
                                {n: `Edlerberry`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                                {n: `Cattail`, t: [itemTypes.rawFood]},
                                {n: `Iron Ore`, t: [itemTypes.rawOre]},
                                {n: `Chalk`, t: [itemTypes.junk]},
                            ],
                            rare: [
                                {n: `Onion`, t: [itemTypes.rawFood]},
                                {n: `Blueberry`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                            ],
                        },
                        tundra: {
                            bountiful: [
                                {n: `Rock`, t: [itemTypes.junk]},
                            ],
                            common: [
                                {n: `Dead Twig`, t: [itemTypes.junk]},
                                {n: `Haskap Berry`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                            ],
                            rare: [
                                {n: `Fossil`, t: [itemTypes.junk]},
                                {n: `Iron Ore`, t: [itemTypes.rawOre]},
                                {n: `Honeyberry`, t: [itemTypes.preppedFood, itemTypes.rawFood]},
                            ],
                        },
                        volcano: {
                            bountiful: [
                                {n: `Volcanic Rock`, t: [itemTypes.junk]},
                            ],
                            common: [
                                {n: `Obsidian`, t: [itemTypes.junk]},
                            ],
                            rare: [
                                {n: `Diamond`, t: [itemTypes.junk]},
                                {n: `Iron Ore`, t: [itemTypes.rawOre]},
                            ],
                        },
                        beach: {
                            bountiful: [
                                {n: `Seaweed`, t: [itemTypes.rawFood]},
                            ],
                            common: [
                                {n: `Seashell`, t: [itemTypes.junk]},
                                {n: `Driftwood`, t: [itemTypes.wood]},
                                {n: `Coconut`, t: [itemTypes.preppedFood]},
                            ],
                            rare: [
                                {n: `Seaglass`, t: [itemTypes.junk]},
                                {n: `Mermaid's Shell`, t: [itemTypes.junk]},
                                {n: `Pirate's Boot`, t: [itemTypes.junk]},
                            ],
                        },
                    },
                    fishing: {
                        mountain: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        forest: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        jungle: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        grassland: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        swamp: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        tundra: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        beach: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                    },
                    hunting: {
                        desert: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        mountain: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        forest: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        jungle: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        grassland: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        swamp: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        tundra: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        beach: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                    },
                    mining: {
                        desert: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        mountain: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        forest: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        jungle: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        grassland: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        swamp: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        tundra: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        volcano: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        beach: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                    },
                    dungeonCrawling: {
                        desert: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        mountain: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        forest: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        jungle: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        grassland: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        swamp: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        tundra: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        volcano: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                        beach: {
                            bountiful: [],
                            common: [],
                            rare: [],
                        },
                    },
                };

                //Seasonal or temporal items:
                const today = new Date();
                if (today.getMonth() === 2 || today.getMonth === 3) {
                    //This is a special item for the `Love Potion Number Nine` recipe. :)
                    //other ingredients include strawberries and who knows what else!
                    lootTables.foraging.grassland.rare.push({n: `Cherry Blossom Petal`, t: [itemTypes.rawFood]});
                }

                //TODO: need a ton more recipes. The "promise" right now is that all you need is raw food in order to cook.
                //So I need at least one recipe per raw food probably, right?
                //Maybe a catch-all recipe that randomly grabs any raw food and produces something that maybe isn't super useful?
                //Or see the note below where I wonder if the cooking activity can be made unavailable when there are no recipes supported by current inventory.
                const cookingRecipes = [
                    {
                        n: `Bittersweet Bread`,
                        ingredients: [
                            {n: [`Cattail`], qty: 5},
                            {n: [`Honeycomb`], qty: 1},
                        ],
                        yeild: 1,
                        t: [itemTypes.preppedFood],
                    },
                    {
                        n: `Cashew Nut`,
                        ingredients: [
                            {n: [`Raw Cashew Nut`], qty: 1},
                        ],
                        yeild: 1,
                        t: [itemTypes.preppedFood],
                    },
                    {
                        n: `Honey Roasted Cashew Nut`,
                        ingredients: [
                            {n: [`Raw Cashew Nut`], qty: 10},
                            {n: [`Honeycomb`], qty: 1},
                        ],
                        yeild: 10,
                        t: [itemTypes.preppedFood],
                    },
                    {
                        n: `Baked Potato`,
                        ingredients: [
                            {n: [`Potato`], qty: 1},
                        ],
                        yeild: 1,
                        t: [itemTypes.preppedFood],
                    },
                    {
                        n: `Mashed Potatoes`,
                        ingredients: [
                            {n: [`Potato`], qty: 4},
                        ],
                        yeild: 1,
                        t: [itemTypes.preppedFood],
                    },
                    {
                        n: `Simple Mushroom Soup`,
                        ingredients: [
                            {n: [`Cap Mushroom`, `Button Mushroom`], qty: 5},
                            {n: [`Carrot`, `Potato`, `Onion`], qty: 3},
                        ],
                        yeild: 1,
                        t: [itemTypes.preppedFood],
                    },
                    {
                        n: `Vegetable Soup`,
                        ingredients: [
                            {n: [`Cap Mushroom`, `Button Mushroom`], qty: 6},
                            {n: [`Potato`], qty: 2},
                            {n: [`Carrot`], qty: 3},
                            {n: [`Onion`], qty: 1},
                        ],
                        yeild: 1,
                        t: [itemTypes.preppedFood],
                    },
                    {
                        n: `Vegetable Stew`,
                        ingredients: [
                            {n: [`Cattail`], qty: 3},
                            {n: [`Cap Mushroom`, `Button Mushroom`], qty: 6},
                            {n: [`Potato`], qty: 2},
                            {n: [`Carrot`], qty: 3},
                            {n: [`Onion`], qty: 1},
                        ],
                        yeild: 1,
                        t: [itemTypes.preppedFood],
                    },
                ];

                //Programatic Recipes because sometimes hand-typing them all is a pain.
                const jams = [
                    `Acai`,
                    `Apple`,
                    `Blackberry`,
                    `Blueberry`,
                    `Cactus Fruit`,
                    `Edlerberry`,
                    `Grape`,
                    `Haskap Berry`,
                    `Honeyberry`,
                    `Raspberry`,
                    `Strawberry`,
                ];
                for (const fruit of jams) {
                    cookingRecipes.push({
                        n: fruit + ' Jam',
                        ingredients: [
                            {n: [fruit], qty: 5},
                            {n: [`Honeycomb`], qty: 1},
                        ],
                        yeild: 1,
                        t: [itemTypes.preppedFood],
                    });
                }

                //TODO: use this later when calculating how food contributes to exploration and combat.
                const getFoodValue = (foodName) => {
                    const recipe = cookingRecipes.find(x => x.n === foodName);
                    if (recipe) {
                        return Math.floor(recipe.ingredients.map(x => x.qty / recipe.yeild).reduce((a, x) => a + x, recipe.ingredients.length));
                    }
                    return 1;
                };

                cookingRecipes.sort((a, b) => getFoodValue(b.n) - getFoodValue(a.n));

                //TODO: remove later, for now it's good for viewing the recipes and their values
                //for (const recipe of cookingRecipes) {
                //    console.log(recipe.n, getFoodValue(recipe.n));
                //}

                const rollDie = (faces) => {
                    return Math.floor(Math.random() * faces) + 1;
                };

                const pickFromArray = (collection) => {
                    return collection[Math.floor(Math.random() * collection.length)];
                };

                const getFromTable = (table) => {
                    const dieRoll = rollDie(20);
                    if (dieRoll > 18) {
                        return pickFromArray(table.rare);
                    }
                    if (dieRoll >= 10) {
                        return pickFromArray(table.common);
                    }
                    return pickFromArray(table.bountiful);
                };

                //TODO: is there any way to leverage this to make the cooking activity unavailable when there are no recipes supported by the player inventory?
                const getCookableRecipes = (rawIngredients) => {
                    const cookable = [];
                    for (const recipe of cookingRecipes) {
                        let ok = true;
                        for (const ingredient of recipe.ingredients) {
                            const total = rawIngredients.filter(x => ingredient.n.indexOf(x.name) > -1).map(x => x.quantity).reduce((a, x) => a + x, 0);
                            if (total < ingredient.qty) {
                                ok = false;
                                break;
                            }
                        }
                        if (ok) {
                            cookable.push(recipe);
                        }
                    }
                    return cookable;
                };

                //TODO: keeping console.logs for now just because cooking has so much potential for bugs!
                //Remove console logs after much testing and rejoicing.
                const attemptToCook = (recipe, rawIngredients, maxItems) => {
                    const ingredientsUsed = [];
                    let numCooked = 0;
                    let min = 9999999999999;
                    for (const ingredient of recipe.ingredients) {
                        const totalAvailable = rawIngredients.filter(x => ingredient.n.indexOf(x.name) > -1).map(x => x.quantity).reduce((a, x) => a + x, 0);
                        const canMake = Math.floor(totalAvailable / ingredient.qty);
                        if (canMake < min) {
                            min = canMake;
                            if (canMake <= 1) {
                                break;
                            }
                        }
                    }

                    if (min > 0) {
                        numCooked = Math.min(maxItems, min);
                        for (const ingredient of recipe.ingredients) {
                            const numUsed = numCooked * ingredient.qty;
                            let consumed = 0;
                            const correctItems = rawIngredients.filter(x => ingredient.n.indexOf(x.name) > -1);
                            for (const item of correctItems) {
                                const toConsume = Math.min((numUsed - consumed), item.quantity);
                                ingredientsUsed.push(newItem(item.name, item.types, -toConsume));
                                consumed += toConsume;
                                if (consumed >= numUsed) {
                                    break;
                                }
                            }
                        }
                    }

                    console.log('recipe', recipe);
                    console.log('rawIngredientsAvailable', rawIngredients);
                    console.log('numCooked', numCooked);
                    console.log('ingredientsUsed', ingredientsUsed);

                    return {
                        usedIngredients: numCooked > 0 ? ingredientsUsed : [],
                        dishCooked: newItem(recipe.n, recipe.t, numCooked),
                    };
                };

                this.getLoot = (activityKey, area, state) => {
                    const activity = activities[activityKey];
                    const averageSkillLevel = activity.skills.map(x => xpToLevel(state.get(x.xpKey))).reduce((a, x) => a + x, 0) / activity.skills.length;
                    const playerLevel = getPlayerLevel(state);
                    const workEffort = Math.max(10, state.get(stateKeys.workPeriod) / 60);

                    const loot = [];
                    if (!activity.areaDependent) {
                        //TODO: also need to do one for smithing and probably one for exploration (though that may be handled differently?)
                        switch (activity.title) {
                            case 'Cooking':
                                const itemsPerLog = 1; //TODO: store as a global variable somewhere? Not even needed in the calculation?
                                const inventory = state.get(stateKeys.inventory);
                                let rawIngredients = inventory.filter(x => x.types.indexOf(itemTypes.rawFood) > -1);
                                const fuel = inventory.filter(x => x.types.indexOf(itemTypes.wood) > -1);
                                const canCook = getCookableRecipes(rawIngredients);
                                const fireSkill = xpToLevel(state.get(skills.fire.xpKey));
                                const consumptionRate = (1) / (itemsPerLog * fireSkill);
                                const numFuelAvailable = fuel.map(x => x.quantity).reduce((a, x) => a + x, 0);
                                const numLoot = Math.floor(Math.random() * workEffort * .2) + Math.floor(Math.random() * averageSkillLevel);
                                const targetNumDishes = Math.min(numLoot, Math.floor(numFuelAvailable / consumptionRate));
                                let numItemsCooked = 0;
                                for (let i = 0; i < canCook.length; i++) {
                                    const result = attemptToCook(canCook[i], rawIngredients, targetNumDishes - numItemsCooked);
                                    loot.push(result.dishCooked);
                                    state.addToInventory(result.usedIngredients);
                                    rawIngredients = state.get(stateKeys.inventory).filter(x => x.types.indexOf(itemTypes.rawFood) > -1);
                                    numItemsCooked += result.dishCooked.quantity;
                                    if (numItemsCooked >= targetNumDishes) {
                                        break;
                                    }
                                }
                                //TODO: break woodburning into a separate function to use with smithing as well?
                                //Also, have a chance to break a flint, lower chance with a higher fire skill?
                                const woodUsed = Math.min(Math.ceil(numItemsCooked * consumptionRate), numFuelAvailable);
                                let woodConsumed = 0;
                                console.log('woodConsumed', woodConsumed);
                                while (woodConsumed < woodUsed) {
                                    const nextWood = state.get(stateKeys.inventory).find(x => x.types.indexOf(itemTypes.wood) > -1);
                                    const numBurned = Math.min((woodUsed - woodConsumed), nextWood.quantity);
                                    const burned = newItem(nextWood.name, nextWood.types, -numBurned);
                                    console.log('burned', burned);
                                    state.addToInventory([burned]);
                                    woodConsumed += numBurned;
                                }
                                break;
                        }
                        return loot;
                    }
                    const biomeName = area.biome;
                    const biomeKey = getBiomeKey(biomeName);
                    const table = lootTables[activityKey][biomeKey];

                    if (!table) {
                        return loot;
                    }

                    const maxLoot = Math.floor(workEffort  * .2) + (area.level * averageSkillLevel);
                    const minLoot = Math.min(maxLoot, area.level + playerLevel);
                    const numLoot = Math.floor(Math.random() * (maxLoot - minLoot)) + minLoot;

                    for (let x = 0; x < numLoot; x++) {
                        const selection = getFromTable(table);
                        const num = Math.floor(Math.random() * area.level * playerLevel) + 1;
                        if (selection && selection.hasOwnProperty('n') & num > 0) {
                            loot.push(newItem(selection.n, selection.t, num));
                        }
                    }

                    return loot;
                };
            }

            const lootTable = new LootTable();

            const app = new IdlePomodoroAdventureApp();
        </script>
    </body>
</html>