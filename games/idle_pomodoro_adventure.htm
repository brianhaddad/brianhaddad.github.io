<!DOCTYPE html>
<html>
    <head>
        <title>Idle Pomodoro Adventure</title>
        <link rel="stylesheet" href="../css/mvp.css">
    </head>
    <body>
        <script src="../scripts/html_tools.js"></script>
        <script>
            //TODO: some notes
            /* 
             * Possibly have an achievement system? A card per achievement, and a whole array of cards to scroll through?
             * Use separate externally linked files for the new area generator and the achievement system (at a bare minimum).
             * 
             */
            const gameWidth = 800;
            const rateOfAdvancement = 0.07;
            const levelUpDifficulty = 2;
            const xpToLevel = (xp) => {
                switch (levelUpDifficulty) {
                    case 2:
                        return Math.floor(rateOfAdvancement * Math.sqrt(xp));
                    
                    case 3:
                        return Math.floor(rateOfAdvancement * Math.cbrt(xp));
                    
                    default:
                        return Math.floor(rateOfAdvancement * Math.pow(xp, 1/levelUpDifficulty));
                }
            };
            const levelToXp = (level) => {
                return Math.ceil(Math.pow(level / rateOfAdvancement, levelUpDifficulty));
            };

            const getRelativeXpReport = (xp) => {
                const level = xpToLevel(xp);
                const baseLevelXp = levelToXp(level);
                const nextLevelXp = levelToXp(level + 1);
                return {
                    value: xp - baseLevelXp,
                    max: nextLevelXp - baseLevelXp,
                };
            };

            const getHealthMax = (xp) => {
                const level = xpToLevel(xp);
                return 90 + (level * 10);
            };

            const levelOneXp = levelToXp(1);

            const themeColors = {
                progressBarBackground: `rgba(0,0,0,.25)`,
                progressBarForeground: `rgba(35,255,155,1)`,
            };

            const stateKeys = {
                workPeriod: `workPeriod`,
                restPeriod: `restPeriod`,
                inventory: `inventory`,
            };

            const defaultValues = {
                workPeriod: 45 * 60,
                restPeriod: 15 * 60,
                inventory: [],
            };

            const skills = {
                strength: {
                    keyValue: `strength`,
                    displayValue: `Strength`,
                },
                toolUse: {
                    keyValue: `toolUse`,
                    displayValue: `Tool Use`,
                },
                fire: {
                    keyValue: `fire`,
                    displayValue: `Fire`,
                },
                combat: {
                    keyValue: `combat`,
                    displayValue: `Combat`,
                },
                health: {
                    keyValue: `health`,
                    displayValue: `Health`,
                },
                intelligence: {
                    keyValue: `intelligence`,
                    displayValue: `Intelligence`,
                },
                navigation: {
                    keyValue: `navigation`,
                    displayValue: `Navigation`,
                },
            };

            const getPlayerLevel = (state) => {
                let xp = 0;
                for (const n in skills) {
                    const skillXp = state.get(skills[n].xpKey);
                    if (skillXp) {
                        xp += skillXp;
                    }
                }
                return xpToLevel(xp);
            };

            for (const n in skills) {
                const xpKey = skills[n].keyValue + `Xp`;
                skills[n].xpKey = xpKey;
                stateKeys[xpKey] = xpKey;
                defaultValues[xpKey] = levelOneXp;
            }

            const itemTypes = {
                rawFood: `Raw Food`, //<- required for cooking, for example
                preppedFood: `Prepped Food`,
                axe: `Axe`, //<- required for wood chopping
                pickaxe: `Pickaxe`,
                fishingPole: `Fishing Pole`, //<- required for fishing
                flintAndSteel: `Flint and Steel`, //<- required for cooking and smithing
                wood: `Wood`, //<- required for cooking
                weapon: `Weapon`, //<- required for hunting or dungeon crawling
                rawOre: `Raw Ores`, //<- required for smithing
            };

            const newItem = (itemName, itemTypes, qty) => {
                return {
                    name: itemName,
                    types: Array.from(itemTypes),
                    quantity: qty,
                };
            };

            const biomes = {
                desert: `Desert`,
                mountain: `Mountain`,
                forest: `Forest`,
                jungle: `Jungle`,
                grassland: `Grassland`,
                swamp: `Swamp`,
                tundra: `Tundra`,
                volcano: `Volcano`,
                beach: `Beach`,
            };

            //These are the activities a player can do during sessions.
            //Each one should appropriate XP toward a set of associated skills.
            //Requirements searches the inventory for required materials/tools.
            //Exploration has a chance to reveal a new region (procedurally generated).
            //Each new region contributes 1-5% toward total world exploration. Ensure procedural generation includes a minimum of one of each kind of biome.
            //Possible to discover regions that are much higher than current level (5-10 levels higher maybe more?).
            //While exploring might encounter baddies, take damage, etc.
            //Additional activities/skills for the future could include crafting and building, but that is getting into stretch goal territory. Watch the scope!
            const activityResult = (msg, lootItems) => {
                return {
                    messgae: msg,
                    loot: Array.from(lootItems),
                };
            };

            const activities = {
                woodChopping: {
                    title: `Wood Chopping`,
                    skills: [skills.toolUse, skills.strength],
                    requirements: [itemTypes.axe],
                    unavailableInArea: (area) => {
                        const notAvailable = [biomes.desert, biomes.tundra, biomes.volcano];
                        return !(notAvailable.find(x => x === area.biome) === undefined);
                    },
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        const rewards = [];
                        let itemName = `Oak Wood`;
                        switch (area.biome) {
                            case biomes.mountain:
                                itemName = `Pine Wood`;
                                break;
                            
                            case biomes.forest:
                                itemName = `Spruce Wood`;
                                break;
                            
                            case biomes.jungle:
                                itemName = `Mahogany Wood`;
                                break;
                            
                            case biomes.grassland:
                                itemName = `Acacia Wood`;
                                break;
                            
                            case biomes.swamp:
                                itemName = `Willow Wood`;
                                break;
                            
                            case biomes.beach:
                                itemName = `Palm Wood`;
                                break;
                        }
                        const workPeriod = state.get(stateKeys.workPeriod) / 60;
                        const num = Math.floor(Math.random() * area.level * workPeriod);
                        if (num > 0) {
                            rewards.push(newItem(itemName, [itemTypes.wood], num));
                        }
                        const message = rewards.length > 0
                            ? `You got some ${itemName.toLowerCase()}!`
                            : `You failed to get any wood at all!`; //TODO: randomize failure messages?
                        return activityResult(message, rewards);
                    },
                },
                foraging: {
                    title: `Foraging`,
                    skills: [skills.intelligence, skills.exploration],
                    requirements: [],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        //TODO: random loot (mostly raw ingredients) including wood and stones based on the area
                    },
                },
                fishing: {
                    title: `Fishing`,
                    skills: [skills.intelligence, skills.toolUse],
                    requirements: [itemTypes.fishingPole],
                    unavailableInArea: (area) => {
                        const notAvailable = [biomes.desert, biomes.volcano];
                        return !(notAvailable.find(x => x === area.biome) === undefined);
                    },
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        //TODO: random raw fish based on the area
                    },
                },
                hunting: {
                    title: `Hunting`,
                    skills: [skills.combat, skills.intelligence],
                    requirements: [itemTypes.weapon],
                    unavailableInArea: (area) => {
                        const notAvailable = [biomes.volcano];
                        return !(notAvailable.find(x => x === area.biome) === undefined);
                    },
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        //TODO: random game meat based on the area (bore, deer, rabbit, etc.)
                    },
                },
                mining: {
                    title: `Mining`,
                    skills: [skills.strength, skills.toolUse],
                    requirements: [itemTypes.pickaxe],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        //TODO: random raw ores based on level and area
                    },
                },
                dungeonCrawling: {
                    title: `Dungeon Crawling`,
                    skills: [skills.strength, skills.combat, skills.health, skills.intelligence],
                    requirements: [itemTypes.weapon, itemTypes.preppedFood],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        //TODO: random prize loot based on the area (including special weapons?)
                    },
                },
                cooking: {
                    title: `Cooking`,
                    skills: [skills.toolUse, skills.fire, skills.intelligence],
                    requirements: [itemTypes.rawFood, itemTypes.wood, itemTypes.flintAndSteel],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => 1,
                    evaluateComplete: (area, state) => {
                        //TODO: remove raw food from inventory (exact quantity depends on level and work time) and return prepared versions of the food
                    },
                },
                exploration: {
                    title: `Exploration`,
                    skills: [skills.exploration, skills.intelligence],
                    requirements: [itemTypes.preppedFood],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => 1,
                    evaluateComplete: (area, state) => {
                        //TODO: depending on time and level, randomly possible to unlock a new area (this is set in the state)
                        //Small chance of returning some foraged items as well?
                    },
                },
                smithing: {
                    title: `Smithing`,
                    skills: [skills.strength, skills.toolUse, skills.fire],
                    requirements: [itemTypes.wood, itemTypes.flintAndSteel, itemTypes.rawOre],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => 1,
                    evaluateComplete: (area, state) => {
                        //TODO: similar to cooking, pull raw ores from inventory and return forged ingots, weapons, tools, treasures, etc.
                    },
                },
            };

            function StateManager() {
                const stateKey = `IdlePomodoroAdventureState`;
                const myState = localStorage.hasOwnProperty(stateKey)
                    ? JSON.parse(localStorage[stateKey])
                    : {};

                const save = () => {
                    localStorage[stateKey] = JSON.stringify(myState);
                };

                this.get = (key) => {
                    if (!myState.hasOwnProperty(key)) {
                        this.set(key, defaultValues.hasOwnProperty(key) ? defaultValues[key] : null);
                    }
                    return myState[key];
                };

                this.set = (key, value) => {
                    myState[key] = value;
                    save();
                };

                this.addToInventory = (newItems) => {
                    const inv = this.get(stateKeys.inventory);
                    for (const item of newItems) {
                        const existingItem = inv.find(x => x.name === item.name);
                        if (existingItem) {
                            existingItem.quantity += item.quantity;
                        }
                        else {
                            inv.push(item);
                        }
                    }
                    this.set(stateKeys.inventory, inv);
                };
            }

            //TODO: play one sound when beginning the work timer (and thus ending the break timer), play another sound when the work timer is done.

            function ScreenManager() {
                const state = new StateManager();

                const timerWorker = new Worker(`../scripts/pomodoro_timer_worker.js`);
                timerWorker.onmessage = (e) => {
                    evalTimer(e.data);
                };

                //TODO: should any of these be stored in state in case of accidental refresh?
                //maybe clear all values if too much time has passed since timer start?
                //Possibly, we can save the last save date/time in the state and reset certain values if it's been too long?
                let timerStart = new Date();
                let timerTarget = 0;
                let currentTimerKey = '';

                const screenTypes = {
                    welcome: `Welcome`,
                    setup: `Setup`,
                    activitySelection: `Select an Activity`,
                    activityWorkTimer: `Working`, //TODO: also displays what activity they are engaged in
                    activityResults: `Congratulations!`,
                    postActivityRest: `Rest Period`,
                };
                const screens = {};

                const mainDiv = createElement('div', {'style': `width:${gameWidth}px;height:100%;padding:0px;margin:0px auto;display:flex;flex-wrap:wrap;flex-direction:column;`}, null);
                document.body.appendChild(mainDiv);

                const headerDiv = createElement('div', {'style': `width:100%;display:flex;flex-direction:row;gap:8px;padding:0px;margin:0px;`}, null);
                mainDiv.appendChild(headerDiv);

                const title = createElement('h1', {'style': `display:block;`}, `Idle Pomodoro Adventure`); //TODO: make this a pixel art image?
                headerDiv.appendChild(title);
                const timerBarContainer = createElement('div', {'style': `margin-block-start:0.67em;display:flex;align-items:center;`}, null);
                headerDiv.appendChild(timerBarContainer);
                const timerBar = new ProgressBar(timerBarContainer, 400, 32);
                timerBar.update({value: 0, max: 100});

                //TODO: for testing? These should be activated internally methinks.
                this.startWorkPeriod = () => {
                    startTimer(stateKeys.workPeriod);
                };

                this.startRestPeriod = () => {
                    startTimer(stateKeys.restPeriod);
                };

                const startTimer = (timerKey) => {
                    currentTimerKey = timerKey;
                    timerTarget = state.get(currentTimerKey);
                    timerStart = new Date();
                    timerWorker.postMessage(timerStart);
                };

                const evalTimer = (timerValue) => {
                    if (timerValue >= timerTarget) {
                        timerWorker.terminate();
                        switch (currentTimerKey) {
                            case stateKeys.workPeriod:
                                console.log('time to take a break!');
                                //TODO: evaluate the result of the selected activity
                                break;

                            case stateKeys.restPeriod:
                                console.log('get back to work!');
                                //TODO: if no activity was selected, select one of the available activities at random?
                                break;
                        }
                    }
                    const timerBarValues = {
                        value: timerValue,
                        max: timerTarget,
                    };
                    timerBar.update(timerBarValues);
                };

                //TODO: all screens need to have an add and a remove function (show/hide?)
                //They need to keep track of whether they've been added, and if asked to remove, they should remove their child and then mark their "displayed" attribute false.
                //Then when "shown" they need to mark the displayed attribute true so they know they need to remove again when switching.
            }

            //TODO: need an activity picker component that will take in the "do-able" activities and display info panels about each one.
            //The info panels should have a "SELECT" button as well that highlights that panel. The whole component should be prepared to
            //say what selection has been made, and each time a SELECT button is clicked, the other panels should all un-select.
            //Also, each selection/panel needs to know if it is selectable or not (some will be 'disabled'). Also, the control should allow
            //the code to get a selection of available (non-disabled) options to select one at random if the user fails to make a choice in time.
            function ActivityPicker() {
                //TODO: the rest of the owl.
                this.getSelection = () => {};
            }

            function ProgressBar(parent, width, height) {
                const borderRadius = '5';
                const barContainer = createElement('div', { 'style': `background-color: ${themeColors.progressBarBackground}; border: 1px solid black; border-radius: ${borderRadius}px; width: ${width}px; height: ${height}px;` }, null);
                const bar = createElement('div', { 'style': `border-radius: ${borderRadius}px; text-align: center; background-color: ${themeColors.progressBarForeground}; height:100%; width:50%` }, null);
                barContainer.appendChild(bar);
                parent.appendChild(barContainer);
                
                this.update = (data) => {
                    bar.style.width = `${Math.floor((Math.min(data.value, data.max)/data.max) * 100)}%`;
                };
            }
        </script>
    </body>
</html>