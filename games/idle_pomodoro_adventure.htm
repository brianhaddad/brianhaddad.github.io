<!DOCTYPE html>
<html>
    <head>
        <title>Idle Pomodoro Adventure</title>
        <link rel="stylesheet" href="../css/mvp.css">
    </head>
    <body>
        <script src="../scripts/html_tools.js"></script>
        <script src="../scripts/ipa_area_generator.js"></script>
        <script>
            //TODO: some notes
            /* 
             * Definitely need a favicon.
             * Possibly have an achievement system? A card per achievement, and a whole array of cards to scroll through?
             * Need a character stats/inventory display screen! Probably a modal overlay? Or maybe something at the footer?
             */
            const appTitle = `Idle Pomodoro Adventure`;
            const gameWidth = 800;
            const rateOfAdvancement = 0.07;
            const levelUpDifficulty = 2;
            const xpToLevel = (xp) => {
                switch (levelUpDifficulty) {
                    case 2:
                        return Math.floor(rateOfAdvancement * Math.sqrt(xp));
                    
                    case 3:
                        return Math.floor(rateOfAdvancement * Math.cbrt(xp));
                    
                    default:
                        return Math.floor(rateOfAdvancement * Math.pow(xp, 1/levelUpDifficulty));
                }
            };
            const levelToXp = (level) => {
                return Math.ceil(Math.pow(level / rateOfAdvancement, levelUpDifficulty));
            };

            const getRelativeXpReport = (xp) => {
                const level = xpToLevel(xp);
                const baseLevelXp = levelToXp(level);
                const nextLevelXp = levelToXp(level + 1);
                return {
                    value: xp - baseLevelXp,
                    max: nextLevelXp - baseLevelXp,
                };
            };

            const getHealthMax = (xp) => {
                const level = xpToLevel(xp);
                return 90 + (level * 10);
            };

            const levelOneXp = levelToXp(1);

            const themeColors = {
                progressBarBackground: `rgba(0,0,0,.25)`,
                progressBarForeground: `rgba(35,255,155,1)`,
            };

            const stateKeys = {
                workPeriod: `workPeriod`,
                restPeriod: `restPeriod`,
                displayRemainingTime: `displayRemainingTime`,
                inventory: `inventory`,
                areas: `areas`,
            };

            const defaultValues = {
                workPeriod: 45 * 60,
                restPeriod: 15 * 60,
                displayRemainingTime: true,
                inventory: [],
                areas: {},
            };

            //TODO: move somewhere else for dev tools.
            //dev overrides
            //defaultValues.workPeriod = 10;
            //defaultValues.restPeriod = 5;

            const skills = {
                strength: {
                    keyValue: `strength`,
                    displayValue: `Strength`,
                },
                toolUse: {
                    keyValue: `toolUse`,
                    displayValue: `Tool Use`,
                },
                fire: {
                    keyValue: `fire`,
                    displayValue: `Fire`,
                },
                combat: {
                    keyValue: `combat`,
                    displayValue: `Combat`,
                },
                health: {
                    keyValue: `health`,
                    displayValue: `Health`,
                },
                intelligence: {
                    keyValue: `intelligence`,
                    displayValue: `Intelligence`,
                },
                navigation: {
                    keyValue: `navigation`,
                    displayValue: `Navigation`,
                },
            };

            const getPlayerLevel = (state) => {
                let xp = 0;
                for (const n in skills) {
                    const skillXp = state.get(skills[n].xpKey);
                    if (skillXp) {
                        xp += skillXp;
                    }
                }
                return xpToLevel(xp);
            };

            for (const n in skills) {
                const xpKey = skills[n].keyValue + `Xp`;
                skills[n].xpKey = xpKey;
                stateKeys[xpKey] = xpKey;
                defaultValues[xpKey] = levelOneXp;
            }

            const itemTypes = {
                rawFood: `Raw Food`, //<- required for cooking, for example
                preppedFood: `Prepped Food`,
                axe: `Axe`, //<- required for wood chopping
                pickaxe: `Pickaxe`,
                fishingPole: `Fishing Pole`, //<- required for fishing
                flintAndSteel: `Flint and Steel`, //<- required for cooking and smithing
                wood: `Wood`, //<- required for cooking
                weapon: `Weapon`, //<- required for hunting or dungeon crawling
                rawOre: `Raw Ores`, //<- required for smithing
            };

            const newItem = (itemName, itemTypes, qty) => {
                return {
                    name: itemName,
                    types: Array.from(itemTypes),
                    quantity: qty,
                };
            };

            //TODO: loot tables and other data are procedurally generated based on biome and level.
            const biomes = {
                desert: `Desert`,
                mountain: `Mountain`,
                forest: `Forest`,
                jungle: `Jungle`,
                grassland: `Grassland`,
                swamp: `Swamp`,
                tundra: `Tundra`,
                volcano: `Volcano`,
                beach: `Beach`,
            };

            const biomeCounts = {};
            for (const biome in biomes) {
                biomeCounts[biome] = 0;
            }

            //These are the activities a player can do during sessions.
            //Each one should appropriate XP toward a set of associated skills.
            //Requirements searches the inventory for required materials/tools.
            //Exploration has a chance to reveal a new region (procedurally generated).
            //Each new region contributes 1-5% toward total world exploration. Ensure procedural generation includes a minimum of one of each kind of biome.
            //Possible to discover regions that are much higher than current level (5-10 levels higher maybe more?).
            //While exploring might encounter baddies, take damage, etc.
            //Additional activities/skills for the future could include crafting and building, but that is getting into stretch goal territory. Watch the scope!
            const getExplorationPercentage = (state) => {
                const areas = state.get(stateKeys.areas);
                let value = 0;
                for (const area in areas) {
                    value += area.level;
                }
                return value;
            };

            const meetsMinSkillLevel = (area, activity, state) => {
                for (const skill of activity.skills) {
                    if (state.get(skill.xpKey) < activity.minSkillLevelCalc(area)) {
                        return false;
                    }
                }
                return true;
            };

            const meetsInventoryRequirements = (activity, state) => {
                const inventory = state.get(stateKeys.inventory);
                for (const type of activity.inventoryRequirements) {
                    const goodItem = inventory.find(x => x.types.indexOf(type) > -1);
                    if (!goodItem || goodItem.quantity < 1) {
                        return false;
                    }
                }
                return true;
            };

            const activityResult = (msg, lootItems) => {
                return {
                    message: msg,
                    loot: Array.from(lootItems),
                };
            };

            const activities = {
                cooking: {
                    title: `Cooking`,
                    areaDependent: false,
                    skills: [skills.toolUse, skills.fire, skills.intelligence],
                    inventoryRequirements: [itemTypes.rawFood, itemTypes.wood, itemTypes.flintAndSteel],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => 1,
                    evaluateComplete: (area, state) => {
                        //TODO: remove raw food from inventory (exact quantity depends on level and work time) and return prepared versions of the food
                    },
                },
                smithing: {
                    title: `Smithing`,
                    areaDependent: false,
                    skills: [skills.strength, skills.toolUse, skills.fire],
                    inventoryRequirements: [itemTypes.wood, itemTypes.flintAndSteel, itemTypes.rawOre],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => 1,
                    evaluateComplete: (area, state) => {
                        //TODO: similar to cooking, pull raw ores from inventory and return forged ingots, weapons, tools, treasures, etc.
                    },
                },
                exploration: {
                    title: `Exploration`,
                    areaDependent: false,
                    skills: [skills.navigation, skills.intelligence],
                    inventoryRequirements: [itemTypes.preppedFood],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => 1,
                    evaluateComplete: (area, state) => {
                        //TODO: depending on time and level, randomly possible to unlock a new area (this is set in the state)
                        //Small chance of returning some foraged items as well?
                        const explorationPercentage = getExplorationPercentage(state);
                        if (explorationPercentage === 100) {
                            //can't do more exploration!
                        }
                        //TODO: also need to make sure the number arrives exactly at 100 by taking 100 - current percentage and making that the max level
                        //for the new area (though the current max area level needs to be taken into account as well!).
                    },
                },
                woodChopping: {
                    title: `Wood Chopping`,
                    areaDependent: true,
                    skills: [skills.toolUse, skills.strength],
                    inventoryRequirements: [itemTypes.axe],
                    unavailableInArea: (area) => {
                        const notAvailable = [biomes.desert, biomes.tundra, biomes.volcano];
                        return !(notAvailable.find(x => x === area.biome) === undefined);
                    },
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        //TODO: loot tables go somewhere else
                        const rewards = [];
                        let itemName = `Oak Wood`;
                        switch (area.biome) {
                            case biomes.mountain:
                                itemName = `Pine Wood`;
                                break;
                            
                            case biomes.forest:
                                itemName = `Spruce Wood`;
                                break;
                            
                            case biomes.jungle:
                                itemName = `Mahogany Wood`;
                                break;
                            
                            case biomes.grassland:
                                itemName = `Acacia Wood`;
                                break;
                            
                            case biomes.swamp:
                                itemName = `Willow Wood`;
                                break;
                            
                            case biomes.beach:
                                itemName = `Palm Wood`;
                                break;
                        }
                        const workPeriod = state.get(stateKeys.workPeriod) / 60;
                        const num = Math.floor(Math.random() * area.level * workPeriod);
                        if (num > 0) {
                            rewards.push(newItem(itemName, [itemTypes.wood], num));
                        }
                        const message = rewards.length > 0
                            ? `You got some ${itemName.toLowerCase()}!`
                            : `You failed to get any wood at all!`; //TODO: randomize failure messages?
                        return activityResult(message, rewards);
                    },
                },
                foraging: {
                    title: `Foraging`,
                    areaDependent: true,
                    skills: [skills.intelligence, skills.navigation],
                    inventoryRequirements: [],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        //TODO: random loot (mostly raw ingredients) including wood and stones based on the area
                        return activityResult(`You found nothing. Maybe that's because the developer hasn't programmed in anything to find!`, []);
                    },
                },
                fishing: {
                    title: `Fishing`,
                    areaDependent: true,
                    skills: [skills.intelligence, skills.toolUse],
                    inventoryRequirements: [itemTypes.fishingPole],
                    unavailableInArea: (area) => {
                        const notAvailable = [biomes.desert, biomes.volcano];
                        return !(notAvailable.find(x => x === area.biome) === undefined);
                    },
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        //TODO: random raw fish based on the area
                    },
                },
                hunting: {
                    title: `Hunting`,
                    areaDependent: true,
                    skills: [skills.combat, skills.intelligence],
                    inventoryRequirements: [itemTypes.weapon],
                    unavailableInArea: (area) => {
                        const notAvailable = [biomes.volcano];
                        return !(notAvailable.find(x => x === area.biome) === undefined);
                    },
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        //TODO: random game meat based on the area (bore, deer, rabbit, etc.)
                    },
                },
                mining: {
                    title: `Mining`,
                    areaDependent: true,
                    skills: [skills.strength, skills.toolUse],
                    inventoryRequirements: [itemTypes.pickaxe],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        //TODO: random raw ores based on level and area
                    },
                },
                dungeonCrawling: {
                    title: `Dungeon Crawling`,
                    areaDependent: true,
                    skills: [skills.strength, skills.combat, skills.health, skills.intelligence],
                    inventoryRequirements: [itemTypes.weapon, itemTypes.preppedFood],
                    unavailableInArea: (area) => false,
                    minSkillLevelCalc: (area) => area.level,
                    evaluateComplete: (area, state) => {
                        //TODO: random prize loot based on the area (including special weapons?)
                    },
                },
            };

            function StateManager() {
                const stateKey = `IdlePomodoroAdventureState`;
                const myState = localStorage.hasOwnProperty(stateKey)
                    ? JSON.parse(localStorage[stateKey])
                    : {};

                const save = () => {
                    localStorage[stateKey] = JSON.stringify(myState);
                };

                this.get = (key) => {
                    if (!myState.hasOwnProperty(key)) {
                        this.set(key, defaultValues.hasOwnProperty(key) ? defaultValues[key] : null);
                    }
                    return myState[key];
                };

                this.set = (key, value) => {
                    myState[key] = value;
                    save();
                };

                this.addToInventory = (newItems) => {
                    const inv = this.get(stateKeys.inventory);
                    for (const item of newItems) {
                        const existingItem = inv.find(x => x.name === item.name);
                        if (existingItem) {
                            existingItem.quantity += item.quantity;
                        }
                        else {
                            inv.push(item);
                        }
                    }
                    this.set(stateKeys.inventory, inv);
                };

                this.addXp = (xpKey, amt) => {
                    const test = this.get(xpKey);
                    if (!isNaN(test)) {
                        myState[xpKey] += amt;
                        save();
                    }
                };
            }

            function TimerWorker() {
                let failoverMode = true;
                let curTimer = null;
                if (window.Worker) {
                    try {
                        curTimer = new Worker(`../scripts/pomodoro_timer_worker.js`);
                        curTimer.onmessage = (e) => {
                            this.onmessage(e);
                        };
                        failoverMode = false;
                    }
                    catch (e) {
                        failoverMode = true;
                    }
                }

                this.onmessage = (e) => {
                    console.log(e);
                };

                this.postMessage = (data) => {
                    if (!failoverMode) {
                        curTimer = new Worker(`../scripts/pomodoro_timer_worker.js`);
                        curTimer.onmessage = (e) => {
                            this.onmessage(e);
                        };
                        curTimer.postMessage(data);
                    }
                    else {
                        if (curTimer !== null) {
                            clearInterval(curTimer);
                            curTimer = null;
                        }
                        const d0 = data;
                        const countUpTimer = (d0) => {
                            const d = new Date();
                            const diff = d - d0;
                            this.onmessage({data: Math.floor(diff/1000)});
                        };
                        curTimer = setInterval(() => {countUpTimer(d0)}, 1000);
                    }
                };

                this.terminate = () => {
                    if (!failoverMode) {
                        curTimer.terminate();
                    }
                    else {
                        clearInterval(curTimer);
                        curTimer = null;
                    }
                };
            }

            const screenTypes = {
                welcome: `Welcome`,
                setup: `Setup`,
                activitySelection: `Activity Selection`,
                activityWorkTimer: `Working`,
                activityResults: `Adventure Results`,
                postActivityRest: `Resting`,
            };

            const displaySeconds = (seconds) => {
                if (isNaN(seconds) || seconds <= 0) {
                    return `Time is up!`;
                }
                const minutes = Math.floor(seconds / 60);
                seconds -= minutes * 60;

                const m = minutes + ' ' + (minutes === 1 ? 'minute' : 'minutes');
                const s = seconds + ' ' + (seconds === 1 ? 'second': 'seconds');
                if (minutes <= 0) {
                    return s;
                }
                if (seconds <= 0) {
                    return m;
                }

                return m + ' ' + s;
            };

            function WelcomeScreen(p, a) {
                const parent = p;
                const myApp = a;
                const myContainer = createElement('div', {'style': `display:flex;flex-direction:column;align-items:center;`}, null);
                let showing = false;

                const populate = () => {
                    const goButtonText = `Begin`;
                    myContainer.innerHTML = '';
                    //TODO: replace with a nice, big graphic?
                    const title = createElement('h1', {}, 'Welcome!');
                    myContainer.appendChild(title);

                    const workTimerSeconds = myApp.getStateData(stateKeys.workPeriod);
                    const restTimerSeconds = myApp.getStateData(stateKeys.restPeriod);

                    const texts = [
                        `Welcome to ${appTitle}! Embark on adventures, complete tasks, level up, and conquer your work!`,
                        `Currently, the work period is set for ${displaySeconds(workTimerSeconds)} and the rest period is set for ${displaySeconds(restTimerSeconds)}. If you would like to adjust these times, go to setup. Otherwise, click '${goButtonText}' and get started on your adventure.`,
                        `Good luck, adventurer!`,
                    ];
                    for (const text of texts) {
                        const p = createElement('p', {}, text);
                        myContainer.appendChild(p);
                    }

                    const button = createElement('button', {'type': 'submit'}, goButtonText);
                    button.addEventListener('click', () => myApp.switchToScreen(screenTypes.activitySelection));
                    myContainer.appendChild(button);

                    //TODO: gear icon?
                    const setup = createElement('input', {'type': 'button', 'value': 'Setup'}, null);
                    setup.addEventListener('click', () => myApp.switchToScreen(screenTypes.setup));
                    myContainer.appendChild(setup);
                };
                
                this.show = () => {
                    if (!showing) {
                        populate();
                        parent.appendChild(myContainer);
                        showing = true;
                    }
                };

                this.hide = () => {
                    if (showing) {
                        parent.removeChild(myContainer);
                        showing = false;
                    }
                };
            }

            function SetupScreen(p, a) {
                const parent = p;
                const myApp = a;
                const myContainer = createElement('div', {'style': `display:flex;flex-direction:column;align-items:center;`}, null);
                let showing = false;

                //TODO: replace with a nice, big graphic?
                const title = createElement('h1', {}, 'App Setup');
                myContainer.appendChild(title);

                //TODO: need controls for editing the settings, especially the timer values
                //might use pre-made list of timer values (5 min, 10, min, 15 min, etc...)
                //maybe an advanced mode that allows a number of seconds to be entered manually
                const placeholder = createElement('p', {}, 'Coming soon! lol');
                myContainer.appendChild(placeholder);

                const button = createElement('button', {'type': 'submit'}, `Done`);
                button.addEventListener('click', () => myApp.goBack());
                myContainer.appendChild(button);
                
                this.show = () => {
                    if (!showing) {
                        parent.appendChild(myContainer);
                        showing = true;
                    }
                };

                this.hide = () => {
                    if (showing) {
                        parent.removeChild(myContainer);
                        showing = false;
                    }
                };
            }

            function ActivitySelectScreen(p, a) {
                const parent = p;
                const myApp = a;
                const myContainer = createElement('div', {'style': `display:flex;flex-direction:column;align-items:center;`}, null);
                let showing = false;

                //TODO: replace with a nice, big graphic?
                const title = createElement('h1', {}, 'Select an Activity');
                myContainer.appendChild(title);

                const activitySelector = new ActivityPicker(myContainer, myApp);

                //TODO: can make the button inactive until an activity is selected?
                const button = createElement('button', {'type': 'submit'}, `Go!`);
                button.addEventListener('click', () => myApp.switchToScreen(screenTypes.activityWorkTimer));
                myContainer.appendChild(button);

                //TODO: gear icon?
                const setup = createElement('input', {'type': 'button', 'value': 'Setup'}, null);
                setup.addEventListener('click', () => myApp.switchToScreen(screenTypes.setup));
                myContainer.appendChild(setup);
                
                this.show = () => {
                    if (!showing) {
                        activitySelector.init();
                        parent.appendChild(myContainer);
                        showing = true;
                    }
                };

                this.hide = () => {
                    if (showing) {
                        parent.removeChild(myContainer);
                        showing = false;
                    }
                };
            }

            function WorkingScreen(p, a) {
                const parent = p;
                const myApp = a;
                const myContainer = createElement('div', {'style': `display:flex;flex-direction:column;align-items:center;`}, null);
                let showing = false;

                //TODO: replace with a nice, big graphic?
                const title = createElement('h1', {}, 'Working');
                myContainer.appendChild(title);

                const activityTitle = createElement('h3', {}, null);
                myContainer.appendChild(activityTitle);

                const timeRemainingDisplay = createElement('div', {}, null);
                myContainer.appendChild(timeRemainingDisplay);

                //TODO: randomize subtitle?
                const subtitle = createElement('h2', {}, 'Focus!');
                myContainer.appendChild(subtitle);

                //TODO: maybe include some kind of graphics based on the current acitivy?
                //If so, how to get current activity data to the screen? Maybe use myApp and a getter?
                
                this.show = () => {
                    if (!showing) {
                        parent.appendChild(myContainer);
                        showing = true;
                        const activityText = myApp.getCurrentActivityTitle();
                        activityTitle.innerHTML = activityText;
                        if (myApp.getStateData(stateKeys.displayRemainingTime)) {
                            timeRemainingDisplay.innerHTML = '';
                            const remainingDisplay = makeFieldset('Work Time Remaining', {'style': `border-radius: 5px; width: ${Math.floor(gameWidth/2)}px;`});
                            timeRemainingDisplay.appendChild(remainingDisplay);
                            const timeDisplay = createElement('span', {'style': `font-weight:bold;font-size:1.25em;`}, 'Ready?'); //TODO: mess with the font more?
                            remainingDisplay.appendChild(timeDisplay);
                            myApp.onTick = () => {
                                timeDisplay.innerHTML = myApp.getRemainingTimeDisplay();
                            };
                        }
                    }
                };

                this.hide = () => {
                    if (showing) {
                        parent.removeChild(myContainer);
                        showing = false;
                    }
                };
            }

            function ResultsScreen(p, a) {
                const parent = p;
                const myApp = a;
                const myContainer = createElement('div', {'style': `display:flex;flex-direction:column;align-items:center;`}, null);
                let showing = false;

                
                //TODO: replace with a nice, big graphic?
                const title = createElement('h1', {}, 'Results!');
                myContainer.appendChild(title);
                
                const resultsContainer = makeFieldset('Results', {'style': `border-radius: 5px;`});
                myContainer.appendChild(resultsContainer);

                const resultsDisplay = createElement('div', {}, null);
                resultsContainer.appendChild(resultsDisplay);

                const activitySelector = new ActivityPicker(myContainer, myApp);

                //TODO: can make the button inactive until an activity is selected?
                const button = createElement('button', {'type': 'submit'}, `Rest!`);
                button.addEventListener('click', () => myApp.switchToScreen(screenTypes.postActivityRest));
                myContainer.appendChild(button);

                //TODO: gear icon?
                const setup = createElement('input', {'type': 'button', 'value': 'Setup'}, null);
                setup.addEventListener('click', () => myApp.switchToScreen(screenTypes.setup));
                myContainer.appendChild(setup);
                
                this.show = () => {
                    if (!showing) {
                        activitySelector.init();
                        parent.appendChild(myContainer);
                        showing = true;
                        resultsDisplay.innerHTML = '';
                        const results = myApp.getLatestActivityResult();
                        resultsDisplay.appendChild(createElement('h3', {}, results.message));
                        //TODO: also display the loot and data about experience gained, level increases, etc.
                    }
                };

                this.hide = () => {
                    if (showing) {
                        parent.removeChild(myContainer);
                        showing = false;
                    }
                };
            }

            function RestingScreen(p, a) {
                const parent = p;
                const myApp = a;
                const myContainer = createElement('div', {'style': `display:flex;flex-direction:column;align-items:center;`}, null);
                let showing = false;

                //TODO: replace with a nice, big graphic?
                const title = createElement('h1', {}, 'Resting');
                myContainer.appendChild(title);

                const timeRemainingDisplay = createElement('div', {}, null);
                myContainer.appendChild(timeRemainingDisplay);

                //TODO: randomize subtitle?
                const subtitle = createElement('h2', {}, 'Take a meaningful break!');
                myContainer.appendChild(subtitle);

                //TODO: maybe show what upcoming activity will be executed during the next work period?
                //If so, how to get current activity data to the screen? Maybe use myApp and a getter?
                
                this.show = () => {
                    if (!showing) {
                        parent.appendChild(myContainer);
                        showing = true;
                        if (myApp.getStateData(stateKeys.displayRemainingTime)) {
                            timeRemainingDisplay.innerHTML = '';
                            const remainingDisplay = makeFieldset('Break Time Remaining', {'style': `border-radius: 5px; width: ${Math.floor(gameWidth/2)}px;`});
                            timeRemainingDisplay.appendChild(remainingDisplay);
                            const timeDisplay = createElement('span', {'style': `font-weight:bold;font-size:1.25em;`}, 'Ready?'); //TODO: mess with the font more?
                            remainingDisplay.appendChild(timeDisplay);
                            myApp.onTick = () => {
                                timeDisplay.innerHTML = myApp.getRemainingTimeDisplay();
                            };
                        }
                    }
                };

                this.hide = () => {
                    if (showing) {
                        parent.removeChild(myContainer);
                        showing = false;
                    }
                };
            }

            function IdlePomodoroAdventureApp() {
                const state = new StateManager();

                const starterAreaName = `Novicewood Forest`;

                const timerWorker = new TimerWorker();
                timerWorker.onmessage = (e) => {
                    evalTimer(e.data);
                };

                const workDoneSound = new Audio('../audio-clips/work-done.ogg');
                const restDoneSound = new Audio('../audio-clips/rest-done.ogg');

                //TODO: should any of these be stored in state in case of accidental refresh?
                //maybe clear all values if too much time has passed since timer start?
                //Possibly, we can save the last save date/time in the state and reset certain values if it's been too long?
                let timerStart = new Date();
                let timerTarget = 0;
                let remainingSeconds = 0;
                let currentTimerKey = '';

                let currentAreaData = null;
                let currentActivityKey = null;
                let currentActivityResult = null;

                let currentScreen = screenTypes.welcome;
                const currentScreenContainer = createElement('div', {}, null);
                const screens = {};
                screens[screenTypes.welcome] = new WelcomeScreen(currentScreenContainer, this);
                screens[screenTypes.setup] = new SetupScreen(currentScreenContainer, this);
                screens[screenTypes.activitySelection] = new ActivitySelectScreen(currentScreenContainer, this);
                screens[screenTypes.activityWorkTimer] = new WorkingScreen(currentScreenContainer, this);
                screens[screenTypes.activityResults] = new ResultsScreen(currentScreenContainer, this);
                screens[screenTypes.postActivityRest] = new RestingScreen(currentScreenContainer, this);

                //TODO: attach and detach available, probably in some kind of footer or extra container?
                const playerDisplayCard = new PlayerDisplayCard(state);
                playerDisplayCard.update();

                const mainDiv = createElement('div', {'style': `width:${gameWidth}px;height:100%;padding:0px;margin:0px auto;display:flex;flex-wrap:wrap;flex-direction:column;`}, null);
                document.body.appendChild(mainDiv);

                const headerDiv = createElement('div', {'style': `width:100%;display:flex;flex-direction:row;gap:8px;padding:0px;margin:0px;`}, null);
                mainDiv.appendChild(headerDiv);

                const title = createElement('h1', {'style': `display:block;`}, `Idle Pomodoro Adventure`); //TODO: make this a pixel art image?
                headerDiv.appendChild(title);
                const timerBarContainer = createElement('div', {'style': `margin-block-start:0.67em;display:flex;align-items:center;`}, null);
                headerDiv.appendChild(timerBarContainer);
                const timerBar = new ProgressBar(timerBarContainer, 400, 32);
                timerBar.update({value: 0, max: 100});

                mainDiv.appendChild(currentScreenContainer);

                this.getStateData = (key) => state.get(key);
                this.getState = () => state;

                let returnToScreen = null;
                this.switchToScreen = (newScreen) => {
                    for (const screen in screens) {
                        screens[screen].hide();
                    }
                    screens[newScreen].show();
                    document.title = `${appTitle}: [${newScreen}]`;
                    switch (newScreen) {
                        case screenTypes.activitySelection:
                            //This ensures the tab can play these sounds later even if the tab is not showing.
                            workDoneSound.play();
                            restDoneSound.play();
                            break;
                            
                        case screenTypes.activityWorkTimer:
                            startWorkPeriod();
                            break;

                        case screenTypes.postActivityRest:
                            startRestPeriod();
                            break;

                        case screenTypes.setup:
                            returnToScreen = currentScreen;
                            break;
                    }
                    currentScreen = newScreen;
                };

                this.goBack = () => {
                    if (returnToScreen !== null) {
                        this.switchToScreen(returnToScreen);
                        returnToScreen = null;
                    }
                };

                this.setActivity = (area, activityKey) => {
                    currentActivityResult = null;
                    currentAreaData = area;
                    currentActivityKey = activityKey;
                };

                this.getLatestActivityResult = () => currentActivityResult;
                this.getCurrentActivityTitle = () => {
                    if (currentAreaData === null || currentActivityKey === null) {
                        return 'No Activity Selected';
                    }
                    let title = activities[currentActivityKey].title;
                    if (activities[currentActivityKey].areaDependent) {
                        title += ': ' + currentAreaData.name;
                    }
                    return title;
                };

                this.getRemainingTimeDisplay = () => {
                    if (state.get(stateKeys.displayRemainingTime)) {
                        return displaySeconds(remainingSeconds);
                    }
                    return null;
                };

                this.onTick = null;

                const startWorkPeriod = () => {
                    startTimer(stateKeys.workPeriod);
                };

                const startRestPeriod = () => {
                    startTimer(stateKeys.restPeriod);
                };

                const startTimer = (timerKey) => {
                    currentTimerKey = timerKey;
                    timerTarget = state.get(currentTimerKey);
                    timerStart = new Date();
                    timerWorker.postMessage(timerStart);
                };

                const evalTimer = (timerValue) => {
                    if (timerValue > timerTarget) {
                        timerValue = 0;
                        remainingSeconds = 0;
                        timerWorker.terminate();
                        switch (currentTimerKey) {
                            case stateKeys.workPeriod:
                                workDoneSound.load();
                                workDoneSound.play();
                                //TODO: if no activity was selected, this crashes.
                                if (currentActivityKey === null) {
                                    currentActivityResult = activityResult('No activity selected!', []);
                                    this.switchToScreen(screenTypes.activityResults);
                                    break;
                                }
                                currentActivityResult = activities[currentActivityKey].evaluateComplete(currentAreaData, state);
                                state.addToInventory(currentActivityResult.loot);
                                for (const skill of activities[currentActivityKey].skills) {
                                    state.addXp(skill.xpKey, timerTarget);
                                }
                                currentActivityKey = null;
                                currentAreaData = null;
                                playerDisplayCard.update();
                                this.switchToScreen(screenTypes.activityResults);
                                break;

                            case stateKeys.restPeriod:
                                restDoneSound.load();
                                restDoneSound.play();
                                //TODO: if no activity was selected, select one of the available activities at random?
                                //TODO: do not go to work timer immediately? Let the user acknowledge the end of break time?
                                this.switchToScreen(screenTypes.activityWorkTimer);
                                break;
                        }
                    }
                    remainingSeconds = timerTarget - timerValue;
                    if (this.onTick) {
                        this.onTick();
                    }
                    const timerBarValues = {
                        value: timerValue,
                        max: timerTarget,
                    };
                    timerBar.update(timerBarValues);
                };

                const addArea = (lvl, bio, nm) => {
                    const areas = state.get(stateKeys.areas);
                    if (!areas.hasOwnProperty(nm)) {
                        const newArea = areaGenerator.generate(lvl, bio, nm);
                        areas[newArea.name] = newArea;
                        state.set(stateKeys.areas, areas);
                    }
                };

                const equipNewPlayer = () => {
                    const inv = state.get(stateKeys.inventory);
                    const loot = [];
                    if (!meetsInventoryRequirements(activities.woodChopping, state)) {
                        loot.push(newItem('Woodcutting Axe', [itemTypes.axe], 1));
                    }
                    //TODO: can keep populating loot based on requirements not met for basic activities.
                    //Might want to have the player earn/create the tools for other activities though.
                    state.addToInventory(loot);
                };

                //Setup:
                //Add the starter area
                addArea(1, biomes.forest, starterAreaName); //Will skip if area already exists.
                equipNewPlayer();

                //Show welcome screen
                this.switchToScreen(screenTypes.welcome);
                
            }
            
            function ActivityPicker(parent, myApp) {
                const theApp = myApp;
                const myContainer = createElement('div', {}, null);
                let activityCollection = [];
                parent.appendChild(myContainer);
                //TODO: format with a scrollbar so it doesn't get too big in late game?
                const activityListDisplay = createElement('div', {}, null);
                myContainer.appendChild(activityListDisplay);

                this.init = () => {
                    const state = theApp.getState();
                    activityCollection = [];
                    activityListDisplay.innerHTML = '';
                    const areas = state.get(stateKeys.areas);
                    const explorationPercentage = getExplorationPercentage(state);
                    const doneOnce = {};
                    for (const area in areas) {
                        //evaluate each activity in every area
                        for (const activity in activities) {
                            if (!activities[activity].areaDependent && !doneOnce.hasOwnProperty(activity)) {
                                doneOnce[activity] = false;
                            }
                            if (activity === 'exploration' && explorationPercentage >= 100) {
                                continue;
                            }
                            if (activities[activity].unavailableInArea(areas[area])) {
                                continue;
                            }
                            if (doneOnce.hasOwnProperty(activity) && doneOnce[activity]) {
                                continue;
                            }
                            const meetsSkillLevelRequirement = meetsMinSkillLevel(areas[area], activities[activity], state);
                            const meetsInventoryRequirement = meetsInventoryRequirements(activities[activity], state);
                            const card = new ActivityCard(areas[area], activity, activityListDisplay, this, meetsSkillLevelRequirement, meetsInventoryRequirement);
                            activityCollection.push(card);
                            if (!activities[activity].areaDependent) {
                                doneOnce[activity] = true;
                            }
                        }
                    }
                };

                this.deselectAll = () => {
                    for (const activity of activityCollection) {
                        activity.deselect();
                    }
                };

                this.setSelection = (area, activityKey) => {
                    theApp.setActivity(area, activityKey);
                };
            }

            function ActivityCard(areaData, activityId, parent, picker, meetsSkillLevelRequirement, meetsInventoryRequirement) {
                const areaName = areaData.name;
                const area = areaData;
                const activityKey = activityId;
                const activity = activities[activityKey];
                const activityName = activity.title;
                const myParentPicker = picker;
                const skillOk = meetsSkillLevelRequirement;
                const inventoryOk = meetsInventoryRequirement;
                const disabled = !skillOk || !inventoryOk;
                const myContainer = createElement('div', {}, null);
                parent.appendChild(myContainer);

                let legendText = activityName
                if (activity.areaDependent){
                    legendText += ': ' + areaName;
                }
                if (disabled) {
                    legendText += ' (disabled)';
                }
                const cardContents = createElement('div', {}, null);
                const card = makeDetail(legendText, cardContents, !disabled);
                myContainer.appendChild(card);
                
                //TODO: need to individually identify each skill or item that is missing rather than just marking the whole line as the problem.
                const lvl = activity.minSkillLevelCalc(area);
                const skillsAttributes = {};
                if (!skillOk) {
                    skillsAttributes['style'] = `color: red;`;
                }
                cardContents.appendChild(createElement('p', skillsAttributes, 'Skills: ' + activity.skills.map(x => x.displayValue + ` (${lvl})`).join(', ')));

                if (activity.inventoryRequirements.length > 0) {
                    const inventoryAttributes = {};
                    if (!inventoryOk) {
                        inventoryAttributes['style'] = `color: red;`;
                    }
                    cardContents.appendChild(createElement('p', inventoryAttributes, 'Items: ' + activity.inventoryRequirements.join(', ')));
                }

                const buttonAttributes = {'type': 'button', 'value': 'Select'};
                if (disabled) {
                    buttonAttributes['disabled'] = true;
                }
                const selectButton = createElement('input', buttonAttributes, null);
                selectButton.addEventListener('click', () => select());
                cardContents.appendChild(selectButton);

                let selected = false;
                this.isSelected = () => selected;

                const select = () => {
                    myParentPicker.deselectAll();
                    selected = true;
                    myParentPicker.setSelection(area, activityKey);
                    //TODO: set styling
                    selectButton.value = 'Selected!';
                };

                this.deselect = () => {
                    selected = false;
                    //TODO: set styling
                    selectButton.value = 'Select';
                };
            }

            function ProgressBar(parent, width, height) {
                const borderRadius = '5';
                const barContainer = createElement('div', { 'style': `background-color: ${themeColors.progressBarBackground}; border: 1px solid black; border-radius: ${borderRadius}px; width: ${width}px; height: ${height}px;` }, null);
                const bar = createElement('div', { 'style': `border-radius: ${borderRadius}px; text-align: center; background-color: ${themeColors.progressBarForeground}; height:100%; width:50%` }, null);
                barContainer.appendChild(bar);
                parent.appendChild(barContainer);
                
                this.update = (data) => {
                    bar.style.width = `${Math.floor((Math.min(data.value, data.max)/data.max) * 100)}%`;
                };
            }

            function PlayerDisplayCard(s) {
                const state = s;
                const myContainer = createElement('div', {}, null);
                const statDisplays = {};
                for (const stat in skills) {
                    statDisplays[skills[stat].xpKey] = new PlayerStatDisplay(skills[stat].displayValue);
                }
                const inventoryDisplay = new PlayerInventoryDisplay();
                //TODO: the rest of the owl

                //TODO: populate the container, maybe with a fieldset first?
                //Then fill the statDisplays array.
                const populate = () => {
                    //TODO: iterate over the statDisplays and update each one.
                };

                this.update = () => {
                    //TODO: populate from settings
                    const newInventoryData = state.get(stateKeys.inventory);
                    inventoryDisplay.update(newInventoryData);

                    for (const stat in statDisplays) {
                        statDisplays[stat].update(state.get(stat));
                    }
                };

                this.attach = (parent) => {
                    parent.appendChild(myContainer);
                };

                this.detach = (parent) => {
                    parent.removeChild(myContainer);
                };
            }

            function PlayerStatDisplay(statName) {
                const displayName = statName;
                //TODO: the rest of the owl.
                //When updating, can it highlight changes, such as leveling up?
                this.update = (xp) => {
                    const lvl = xpToLevel(xp);
                    const nextLvlProgress = getRelativeXpReport(xp);
                    //TODO: actually draw/display the level and progress bar.
                };
            }

            function PlayerInventoryDisplay() {
                //TODO: the rest of the owl.
                this.update = (inventoryData) => {
                    //TODO: might want icons/graphics for each inventory item type?
                };
            }

            const app = new IdlePomodoroAdventureApp();
        </script>
    </body>
</html>