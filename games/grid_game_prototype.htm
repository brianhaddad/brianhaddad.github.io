<!doctype HTML>
<html>
    <head>
        <title>Grid Game Prototype</title>
        <link rel="stylesheet" href="../css/mvp.css">
    </head>
    <body>
        <script src="../scripts/html_tools.js"></script>
        <script>
            /*******************
             * Alright, here's how this is going to go:
             * D4: (special) move 3 spaces in any direction and can jump over other pieces. Deals its health in damage even if it dies.
             * D6: (grunt) move 1 space in any direction.
             * D12: (special) take up to 5 moves during a turn, can change directions while moving but cannot jump over other pieces.
             * D20: (tank) move 1 space forward/back/left/right.
             * 
             * Except for the D4, you can only attack a die with equal or lesser face value.
             * When attacking equal, no matter the types of dice, both roll. The higher number wins (reroll for ties) and their new face value is kept.
             * Example: a D6 with a face value of 4 attacks a D4 with a face value of 4. They both roll. The D6 gets 3 and the D4 gets 2. The D4 is defeated
             * but the D6 keeps its new lower value of 3.
             * 
             * game modes: (come up with better names)
             * king of the hill: keep a piece on the center square. use special translucent D6?D12? to count down turns until victory.
             * all out war: annihilate the opponent.
             * capture the flag: protect your translucent flag/die and if someone else captures it they have to transport it back to their base.
             * 
             */
            function drawCenteredBoldText(ctx, text, x, y) {
                ctx.save();
                ctx.translate(x, y);
                ctx.font = "bold 12px Arial";
                ctx.fillStyle = "#000000";
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 0, 0);
                ctx.restore();
            }

            function drawStar(ctx, x, y, radius) {
                const innerRadius = radius * 0.382; // Inner radius for a visually pleasing star
                const outerAngle = 2 * Math.PI / 5; // Angle between outer points
                const innerAngle = Math.PI / 5; // Angle between inner and outer points

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(-Math.PI/2);

                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const outerPointX = radius * Math.cos(i * outerAngle);
                    const outerPointY = radius * Math.sin(i * outerAngle);
                    const innerPointX = innerRadius * Math.cos((i * outerAngle) + innerAngle);
                    const innerPointY = innerRadius * Math.sin((i * outerAngle) + innerAngle);

                    ctx.lineTo(outerPointX, outerPointY);
                    ctx.lineTo(innerPointX, innerPointY);
                }
                ctx.closePath();
                ctx.fill(); // Fill the star with the current fillStyle
                ctx.restore();
            }

            const cellTypes = {
                center: 'centerCell',
            };

            function D(value) {
                this.type = 'D' + value;
                this.faceValue = 1;

                const faces = [];
                for (let i = 0; i < value; i++) {
                    faces.push(i+1);
                }

                //Probably needs to be publicly exposed, but maybe through contextual/symantic methods?
                const rollMe = () => {
                    this.faceValue = faces[Math.floor(Math.random() * faces.length)];
                };
            }

            function GridCell(gX, gY, posX, posY, pxTileSize, cellType) {
                const col = gX;
                const row = gY;
                const x = Math.floor(posX);
                const y = Math.floor(posY);
                const tileSize = pxTileSize;
                const tempColors = [
                    '#f42c23',
                    '#2cf423',
                    '#2c23f4',
                    '#af50d1',
                    '#50afd1',
                    '#50d1af',
                ];

                let hoverHighlighted = false;

                const collidePoint = (px, py) => {
                    const left = x - (tileSize/2);
                    const top = y - (tileSize/2);
                    const withinHorizontal = px > left && px < left + tileSize;
                    const withinVertical = py > top && py < top + tileSize;
                    return withinHorizontal && withinVertical;
                };

                this.checkHover = (posX, posY) => {
                    hoverHighlighted = collidePoint(posX, posY);
                    return hoverHighlighted ? this : null;
                };

                this.draw = (ctx) => {
                    //TODO: maybe cell types that get drawn differently?
                    const topLayerDrawCalls = [];
                    ctx.save();

                    switch (cellType) {
                        case cellTypes.center:
                            ctx.fillStyle = '#000000';
                            ctx.fillRect(x - (tileSize/2), y - (tileSize/2), tileSize, tileSize);

                            ctx.fillStyle = '#ffff00';
                            drawStar(ctx, x, y, tileSize/3);
                            break;

                        default:
                            ctx.fillStyle = tempColors[(col + row)%tempColors.length];
                            ctx.fillRect(x - (tileSize/2), y - (tileSize/2), tileSize, tileSize);
                    }
                    //TODO: keep this for effects that need to go over the main board:
                    //if (hoverHighlighted) {
                    //    topLayerDrawCalls.push((ctx) => {
                    //    });
                    //    topLayerDrawCalls.push((ctx) => {
                    //    });
                    //}
                    ctx.restore();
                    return topLayerDrawCalls;
                };

                this.drawHoverHighlight = (ctx) => {
                    const w = 6;
                    const hw = w / 2;
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255,255,255,.75)';
                    ctx.lineWidth = w;
                    ctx.beginPath();
                    ctx.roundRect(x - (tileSize/2) - hw, y - (tileSize/2) - hw, tileSize + w, tileSize + w, 8);
                    ctx.stroke();
                    ctx.restore();
                    //TODO: optional?
                    //drawCenteredBoldText(ctx, `${col}, ${row}`, x, y);
                };
            }

            function Grid(posX, posY, numRows, numCols, pxTileSize) {
                const x = Math.floor(posX);
                const y = Math.floor(posY);
                const rows = numRows;
                const cols = numCols;
                const tileSize = pxTileSize;
                const cells = [];
                const hasCenter = (rows % 2 === 1) && (cols % 2 === 1);

                let highlightedCell = null;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        let cellType = '';
                        if (hasCenter && r === Math.floor(rows/2) && c === Math.floor(cols/2)) {
                            cellType = cellTypes.center;
                        }
                        //TODO: store a 2-d array of these points for future use!
                        const posX = x + (tileSize * (c - ((cols - 1) / 2)));
                        const posY = y + (tileSize * (r - ((rows - 1) / 2)));
                        cells.push(new GridCell(c, r, posX, posY, tileSize, cellType));
                    }
                }

                this.mouseMove = (mouseX, mouseY) => {
                    //TODO: temp? Just a proof of concept placeholder...
                    let currentlyHighlighted = null;
                    for (const cell of cells) {
                        currentlyHighlighted ??= cell.checkHover(mouseX, mouseY);
                    }
                    if (highlightedCell !== currentlyHighlighted) {
                        highlightedCell = currentlyHighlighted;
                        //TODO: events for mouse entering/leaving cells?
                        //if (highlightedCell !== null) {
                        //    console.log('entered a new cell');
                        //}
                        //else {
                        //    console.log('left a cell');
                        //}
                    }
                };

                this.update = (dt) => {
                    //
                };

                this.draw = (ctx) => {
                    //TODO: Grid needs different layers beyond the tiles/cells.
                    const topLayer = [];
                    for (const cell of cells) {
                        const newTopLayerItems = cell.draw(ctx);
                        topLayer.push(...newTopLayerItems);
                    }
                    for (const top of topLayer) {
                        top(ctx);
                    }
                    if (highlightedCell) {
                        highlightedCell.drawHoverHighlight(ctx);
                    }
                };
            }

            function Game(width, height) {
                const w = width;
                const h = height;
                const x = w / 2;
                const y = h / 2;
                const gridSize = 13;
                const grid = new Grid(x, y, gridSize, gridSize, Math.floor(Math.min(w, h) / (gridSize + 2)));

                this.mouseEvent = (mouseX, mouseY, eventType) => {
                    switch (eventType) {
                        case 'click':
                            //TODO: left click
                            //If something was already highlighted (identified as the item the mouse is over)
                            //maybe just have that item activate after confirming that the new coordinate is still
                            //inside?
                            break;

                        case 'contextmenu':
                            //TODO: this is right clicking!
                            break;

                        case 'mousemove':
                            //TODO: pass the mouse position around looking for something to highlight?
                            grid.mouseMove(mouseX, mouseY);
                            break;

                        default:
                            //TODO: lol nothing? WHO KNOWS?!?
                            console.log(eventType);
                    }
                };

                this.update = (dt) => {
                    //TODO: game logic
                    grid.update(dt);
                };

                this.draw = (ctx) => {
                    ctx.clearRect(0, 0, w, y);
                    ctx.fillStyle = '#2cb242';
                    ctx.fillRect(0, 0, w, h);
                    grid.draw(ctx);
                };
            }

            const gameWidth = 800;
            const gameHeight = 600;

            const gameDiv = createElement('div', {'style': `width:${gameWidth}px;height:100%;padding:0px;margin:0px auto;display:flex;flex-wrap:wrap;flex-direction:column;`}, null);
            document.body.appendChild(gameDiv);

            const canvas = createElement('canvas', {'width': gameWidth, 'height': gameHeight}, null);
            canvas.addEventListener('click', gameMouseEvent, false);
            canvas.addEventListener('mousemove', gameMouseEvent, false);
            canvas.addEventListener('contextmenu', gameMouseEvent, false);
            const ctx = canvas.getContext('2d');
            gameDiv.appendChild(canvas);

            function gameMouseEvent(evt) {
                var rect = canvas.getBoundingClientRect();
                evt.preventDefault();
                game.mouseEvent(evt.clientX - rect.left, evt.clientY - rect.top, evt.type);
            }

            let game = null;

            let lastUpdate = null;
            function animateGame() {
                const nowUpdate = Date.now();
                const dt = nowUpdate - lastUpdate;
                lastUpdate = nowUpdate;
                game.update(dt);
                game.draw(ctx);
                requestAnimationFrame(animateGame);
            }

            function startNewGame() {
                game = new Game(gameWidth, gameHeight);
                lastUpdate = Date.now();
                animateGame();
            }

            startNewGame();
        </script>
    </body>
<html>