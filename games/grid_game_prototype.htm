<!doctype HTML>
<html>
    <head>
        <title>Grid Game Prototype</title>
        <link rel="stylesheet" href="../css/mvp.css">
    </head>
    <body>
        <script src="../scripts/html_tools.js"></script>
        <script>
            /*******************
             * Alright, here's how this is going to go:
             * D4: (special) move 3 spaces in any direction and can jump over other pieces. Deals its health in damage even if it dies.
             * D6: (grunt) move 1 space in any direction.
             * D12: (special) take up to 5 moves during a turn, can change directions while moving but cannot jump over other pieces.
             * D20: (tank) move 1 space forward/back/left/right.
             * 
             * Except for the D4, you can only attack a die with equal or lesser face value.
             * When attacking equal, no matter the types of dice, both roll. The higher number wins (reroll for ties) and their new face value is kept.
             * Example: a D6 with a face value of 4 attacks a D4 with a face value of 4. They both roll. The D6 gets 3 and the D4 gets 2. The D4 is defeated
             * but the D6 keeps its new lower value of 3.
             * 
             * game modes: (come up with better names)
             * king of the hill: keep a piece on the center square. use special translucent D6?D12? to count down turns until victory.
             * all out war: annihilate the opponent.
             * capture the flag: protect your translucent flag/die and if someone else captures it they have to transport it back to their base.
             * 
             * game phases:
             * players build their army. each die has a value (D6 = 6, obviously) and there is a maxiumum value per army (to be determined)
             * also maximum of 2x the grid height number of dice per player (26 for 13x13)
             * once they have their armies selected then the colored dice are presented to the players to be placed in their home base (the two right-most or left-most columns)
             * once all dice are placed, the game begins. not sure if it should be like chess where one side always goes first...
             * 
             */
            //TODO: safe spots? lol
            const cellTypes = {
                center: 'centerCell',
                redBase: 'redBase',
                redHeal: 'redHeal',
                blueBase: 'blueBase',
                blueHeal: 'blueHeal',
            };

            const gameModes = {
                kingOfTheCastle: 'King of the Castle',
                annihilation: 'Annihilation',
                captureThePrincess: 'Capture the Princess',
            };

            function drawCenteredBoldText(ctx, text, x, y, color) {
                ctx.save();
                ctx.translate(x, y);
                //TODO: allow color and font size to be passed in?
                ctx.font = 'bold 12px Arial';
                ctx.fillStyle = color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 0, 0);
                ctx.restore();
            }

            function drawStar(ctx, x, y, radius) {
                const innerRadius = radius * 0.382; // Inner radius for a visually pleasing star
                const outerAngle = 2 * Math.PI / 5; // Angle between outer points
                const innerAngle = Math.PI / 5; // Angle between inner and outer points

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(-Math.PI/2);

                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const outerPointX = radius * Math.cos(i * outerAngle);
                    const outerPointY = radius * Math.sin(i * outerAngle);
                    const innerPointX = innerRadius * Math.cos((i * outerAngle) + innerAngle);
                    const innerPointY = innerRadius * Math.sin((i * outerAngle) + innerAngle);

                    ctx.lineTo(outerPointX, outerPointY);
                    ctx.lineTo(innerPointX, innerPointY);
                }
                ctx.closePath();
                ctx.fill(); // Fill the star with the current fillStyle
                ctx.restore();
            }

            function drawNgon(ctx, x, y, n, radius) {
                //TODO: option to include an outline?
                const outerAngle = 2 * Math.PI / n;
                let rotation = -Math.PI/2;
                if (n % 2 === 0) {
                    rotation = -Math.PI/4;
                }
                if (n > 3 && n % 3 === 0) {
                    rotation = -Math.PI/3;
                }

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);

                ctx.beginPath();
                ctx.moveTo(radius, 0);
                for (let i = 0; i < n; i++) {
                    const outerPointX = radius * Math.cos(i * outerAngle);
                    const outerPointY = radius * Math.sin(i * outerAngle);

                    ctx.lineTo(outerPointX, outerPointY);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }

            function drawPlus(ctx, x, y, r) {
                ctx.save();
                const w = .3;
                const p = w * r;
                ctx.translate(x, y);

                ctx.beginPath();
                
                ctx.moveTo(-p, r);
                ctx.lineTo(p, r);

                ctx.lineTo(p, p);
                ctx.lineTo(r, p);

                ctx.lineTo(r, -p);
                ctx.lineTo(p, -p);

                ctx.lineTo(p, -r);
                ctx.lineTo(-p, -r);

                ctx.lineTo(-p, -p);
                ctx.lineTo(-r, -p);
                
                ctx.lineTo(-r, p);
                ctx.lineTo(-p, p);

                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }

            function D(value, posX, posY, drawRadius) {
                const name = 'D' + value; 
                this.getType = () => name;
                let displayValue = 1;
                this.getFaceValue = () => displayValue;

                const x = Math.floor(posX);
                const y = Math.floor(posY);
                const r = Math.floor(drawRadius);

                const faces = [];
                for (let i = 0; i < value; i++) {
                    faces.push(i+1);
                }

                //TODO: methods for moving, including animating a move to a new location

                this.roll = () => {
                    displayValue = faces[Math.floor(Math.random() * faces.length)];
                };

                this.draw = (ctx) => {
                    switch (name) {
                        case 'D4':
                            drawNgon(ctx, x, y, 3, r);
                            break;

                        case 'D6':
                            drawNgon(ctx, x, y, 4, r);
                            break;

                        case 'D12':
                            drawNgon(ctx, x, y, 5, r);
                            break;

                        case 'D20':
                            drawNgon(ctx, x, y, 6, r);
                            break;
                    }
                    drawCenteredBoldText(ctx, displayValue, x, y, 'rgba(255,255,255,.7)');
                }
            }

            function GridCell(gX, gY, posX, posY, pxTileSize, cellType, makeDark) {
                const centerSquareColor = '#000000';
                const centerStarColor = '#ffff00';
                const redBaseColor = '#f83772';
                const blueBaseColor = '#7237f8';
                const boardDefaultColor = '#ffffff';
                const lightenColor = 'rgba(255,255,255,.7)';
                const darkenColor = 'rgba(0,0,0,.7)';

                const col = gX;
                const row = gY;
                const x = Math.floor(posX);
                const y = Math.floor(posY);
                const tileSize = pxTileSize;
                const dark = makeDark;

                let hoverHighlighted = false;

                const collidePoint = (px, py) => {
                    const left = x - (tileSize/2);
                    const top = y - (tileSize/2);
                    const withinHorizontal = px > left && px < left + tileSize;
                    const withinVertical = py > top && py < top + tileSize;
                    return withinHorizontal && withinVertical;
                };

                this.checkHover = (posX, posY) => {
                    hoverHighlighted = collidePoint(posX, posY);
                    return hoverHighlighted ? this : null;
                };

                const fillBaseColorRect = (ctx) => {
                    fillTileSquare(ctx);
                    darken(ctx);
                };

                const fillTileSquare = (ctx) => {
                    ctx.fillRect(x - (tileSize/2), y - (tileSize/2), tileSize, tileSize);
                };

                const darken = (ctx) => {
                    if (!dark) {
                        return;
                    }
                    ctx.save();
                    ctx.fillStyle = darkenColor;
                    fillTileSquare(ctx);
                    ctx.restore();
                };

                this.draw = (ctx) => {
                    //TODO: maybe cell types that get drawn differently?
                    const topLayerDrawCalls = [];
                    ctx.save();

                    switch (cellType) {
                        case cellTypes.center:
                            ctx.fillStyle = centerSquareColor;
                            fillBaseColorRect(ctx);

                            ctx.fillStyle = centerStarColor;
                            drawStar(ctx, x, y, tileSize/3);
                            break;

                        case cellTypes.redBase:
                            ctx.fillStyle = redBaseColor;
                            fillBaseColorRect(ctx);
                            break;

                        case cellTypes.redHeal:
                            ctx.fillStyle = redBaseColor;
                            fillBaseColorRect(ctx);
                            ctx.fillStyle = lightenColor;
                            drawPlus(ctx, x, y, tileSize/3);
                            break;

                        case cellTypes.blueBase:
                            ctx.fillStyle = blueBaseColor;
                            fillBaseColorRect(ctx);
                            break;

                        case cellTypes.blueHeal:
                            ctx.fillStyle = blueBaseColor;
                            fillBaseColorRect(ctx);
                            ctx.fillStyle = lightenColor;
                            drawPlus(ctx, x, y, tileSize/3);
                            break;

                        default:
                            ctx.fillStyle = boardDefaultColor;
                            fillBaseColorRect(ctx);
                    }
                    //TODO: keep this for effects that need to go over the main board:
                    //if (hoverHighlighted) {
                    //    topLayerDrawCalls.push((ctx) => {
                    //    });
                    //    topLayerDrawCalls.push((ctx) => {
                    //    });
                    //}
                    ctx.restore();
                    return topLayerDrawCalls;
                };

                this.drawHoverHighlight = (ctx) => {
                    //TODO: draw a different color depending on the player?
                    const w = 6;
                    const hw = w / 2;
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255,255,100,.75)';
                    ctx.lineWidth = w;
                    ctx.beginPath();
                    ctx.roundRect(x - (tileSize/2) - hw, y - (tileSize/2) - hw, tileSize + w, tileSize + w, 8);
                    ctx.stroke();
                    ctx.restore();
                    //TODO: optional?
                    //drawCenteredBoldText(ctx, `${col}, ${row}`, x, y);
                };
            }

            function Grid(posX, posY, numRows, numCols, pxTileSize) {
                //TODO: need a way to resize/scale the tileSize?
                const x = Math.floor(posX);
                const y = Math.floor(posY);
                const rows = numRows;
                const cols = numCols;
                const tileSize = pxTileSize;
                const cells = [];
                const hasCenter = (rows % 2 === 1) && (cols % 2 === 1);
                const healingSpotRowInset = 1;
                const gridPositionOffsets = [];

                const redPlayerDice = [];
                const bluePlayerDice = [];

                const isHealingRow = (r) => (r == healingSpotRowInset || r == (rows - 1) - healingSpotRowInset);

                let highlightedCell = null;

                //TODO: need to allow reflow of the layout for resizing?
                for (let r = 0; r < rows; r++) {
                    gridPositionOffsets[r] = [];
                    for (let c = 0; c < cols; c++) {
                        let cellType = '';
                        if (hasCenter && r === Math.floor(rows/2) && c === Math.floor(cols/2)) {
                            cellType = cellTypes.center;
                        }
                        if (c < 2) {
                            cellType = cellTypes.redBase;
                            if (c == 0 && isHealingRow(r)) {
                                cellType = cellTypes.redHeal;
                            }
                        }
                        if (c >= cols - 2) {
                            cellType = cellTypes.blueBase;
                            if (c == cols - 1 && isHealingRow(r)) {
                                cellType = cellTypes.blueHeal;
                            }
                        }
                        const offset = {
                            x: (c - ((cols - 1) / 2)),
                            y: (r - ((rows - 1) / 2))
                        };
                        const posX = x + (tileSize * offset.x);
                        const posY = y + (tileSize * offset.y);
                        const makeDark = (r % 2) == (c % 2);
                        cells.push(new GridCell(c, r, posX, posY, tileSize, cellType, makeDark));
                        gridPositionOffsets[r][c] = offset; //TODO: might move to using this for more things
                    }
                }

                //TODO: temp code
                //D(value, posX, posY, drawRadius)
                let pos = gridPositionOffsets[0][0];
                let die = new D(4, x + (pos.x * tileSize), y + (pos.y * tileSize), (tileSize * 2) / 5);
                die.roll();
                redPlayerDice.push(die);
                pos = gridPositionOffsets[0][1];
                die = new D(6, x + (pos.x * tileSize), y + (pos.y * tileSize), (tileSize * 2) / 5);
                die.roll();
                redPlayerDice.push(die);
                pos = gridPositionOffsets[0][2];
                die = new D(12, x + (pos.x * tileSize), y + (pos.y * tileSize), (tileSize * 2) / 5);
                die.roll();
                redPlayerDice.push(die);
                pos = gridPositionOffsets[0][3];
                die = new D(20, x + (pos.x * tileSize), y + (pos.y * tileSize), (tileSize * 2) / 5);
                die.roll();
                redPlayerDice.push(die);
                pos = gridPositionOffsets[0][11];
                die = new D(6, x + (pos.x * tileSize), y + (pos.y * tileSize), (tileSize * 2) / 5);
                die.roll();
                redPlayerDice.push(die);
                pos = gridPositionOffsets[0][12];
                die = new D(6, x + (pos.x * tileSize), y + (pos.y * tileSize), (tileSize * 2) / 5);
                die.roll();
                redPlayerDice.push(die);

                pos = gridPositionOffsets[12][12];
                die = new D(4, x + (pos.x * tileSize), y + (pos.y * tileSize), (tileSize * 2) / 5);
                die.roll();
                bluePlayerDice.push(die);
                pos = gridPositionOffsets[12][11];
                die = new D(6, x + (pos.x * tileSize), y + (pos.y * tileSize), (tileSize * 2) / 5);
                die.roll();
                bluePlayerDice.push(die);
                pos = gridPositionOffsets[12][10];
                die = new D(12, x + (pos.x * tileSize), y + (pos.y * tileSize), (tileSize * 2) / 5);
                die.roll();
                bluePlayerDice.push(die);
                pos = gridPositionOffsets[12][9];
                die = new D(20, x + (pos.x * tileSize), y + (pos.y * tileSize), (tileSize * 2) / 5);
                die.roll();
                bluePlayerDice.push(die);
                pos = gridPositionOffsets[12][1];
                die = new D(6, x + (pos.x * tileSize), y + (pos.y * tileSize), (tileSize * 2) / 5);
                die.roll();
                bluePlayerDice.push(die);
                pos = gridPositionOffsets[12][0];
                die = new D(6, x + (pos.x * tileSize), y + (pos.y * tileSize), (tileSize * 2) / 5);
                die.roll();
                bluePlayerDice.push(die);

                this.mouseMove = (mouseX, mouseY) => {
                    //TODO: temp? Just a proof of concept placeholder...
                    let currentlyHighlighted = null;
                    for (const cell of cells) {
                        currentlyHighlighted ??= cell.checkHover(mouseX, mouseY);
                    }
                    if (highlightedCell !== currentlyHighlighted) {
                        highlightedCell = currentlyHighlighted;
                        //TODO: events for mouse entering/leaving cells?
                        //if (highlightedCell !== null) {
                        //    console.log('entered a new cell');
                        //}
                        //else {
                        //    console.log('left a cell');
                        //}
                    }
                };

                this.update = (dt) => {
                    //
                };

                const redDiceColor = '#ff0000';
                const blueDiceColor = '#0000ff';

                this.draw = (ctx) => {
                    //TODO: Grid needs different layers beyond the tiles/cells.
                    const topLayer = [];
                    for (const cell of cells) {
                        const newTopLayerItems = cell.draw(ctx);
                        topLayer.push(...newTopLayerItems);
                    }
                    for (const top of topLayer) {
                        top(ctx);
                    }
                    //TODO: should dice go under or over the top layer that comes back from the grid draw call??
                    //TODO: also, draw whoever's turn it is first! maybe put these calls in their own functions.
                    
                    //TODO: move the styles into the dice themselves to allow for the special translucent "princess" die for each team.
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#000000';
                    ctx.fillStyle = redDiceColor;
                    for (const red of redPlayerDice) {
                        red.draw(ctx);
                    }
                    ctx.fillStyle = blueDiceColor;
                    for (const blue of bluePlayerDice) {
                        blue.draw(ctx);
                    }
                    //TODO: need a way to only draw highlighting when an action can be taken
                    //eventually valid moves should highlight while invalid moves should not
                    //also before selecting a piece to move, empty tiles and tiles with enemy pieces should not highlight
                    if (highlightedCell) {
                        highlightedCell.drawHoverHighlight(ctx);
                    }
                };
            }

            function Game(width, height) {
                const w = width;
                const h = height;
                const x = w / 2;
                const y = h / 2;

                let gridSize = 13;
                let grid = new Grid(x, y, gridSize, gridSize, Math.floor(Math.min(w, h) / (gridSize + 2)));

                this.setup = (gameMode) => {
                    //TODO: eventually need to pass in player army description somehow
                    switch (gameMode) {
                        case '':
                            //TODO: different modes might have different grids or at least grid sizes?
                            break;

                        default:
                            gridSize = 13;
                            grid = new Grid(x, y, gridSize, gridSize, Math.floor(Math.min(w, h) / (gridSize + 2)));
                    }
                };

                this.mouseEvent = (mouseX, mouseY, eventType) => {
                    switch (eventType) {
                        case 'click':
                            //TODO: left click
                            //If something was already highlighted (identified as the item the mouse is over)
                            //maybe just have that item activate after confirming that the new coordinate is still
                            //inside?
                            break;

                        case 'contextmenu':
                            //TODO: this is right clicking!
                            break;

                        case 'mousemove':
                            //TODO: pass the mouse position around looking for something to highlight?
                            grid.mouseMove(mouseX, mouseY);
                            break;

                        default:
                            //TODO: lol nothing? WHO KNOWS?!?
                            console.log(eventType);
                    }
                };

                this.update = (dt) => {
                    //TODO: game logic
                    grid.update(dt);
                };

                this.draw = (ctx) => {
                    ctx.clearRect(0, 0, w, y);
                    ctx.fillStyle = '#2cb242';
                    ctx.fillRect(0, 0, w, h);
                    grid.draw(ctx);
                };
            }

            const gameWidth = 800;
            const gameHeight = 600;

            const gameDiv = createElement('div', {'style': `width:${gameWidth}px;height:100%;padding:0px;margin:0px auto;display:flex;flex-wrap:wrap;flex-direction:column;`}, null);
            document.body.appendChild(gameDiv);

            const canvas = createElement('canvas', {'width': gameWidth, 'height': gameHeight}, null);
            canvas.addEventListener('click', gameMouseEvent, false);
            canvas.addEventListener('mousemove', gameMouseEvent, false);
            canvas.addEventListener('contextmenu', gameMouseEvent, false);
            const ctx = canvas.getContext('2d');
            gameDiv.appendChild(canvas);

            const gameSetupControls = makeFieldset('Game Setup');

            function gameMouseEvent(evt) {
                var rect = canvas.getBoundingClientRect();
                evt.preventDefault();
                game.mouseEvent(evt.clientX - rect.left, evt.clientY - rect.top, evt.type);
            }

            let game = null;

            let lastUpdate = null;
            function animateGame() {
                const nowUpdate = Date.now();
                const dt = nowUpdate - lastUpdate;
                lastUpdate = nowUpdate;
                game.update(dt);
                game.draw(ctx);
                requestAnimationFrame(animateGame);
            }

            function startNewGame() {
                game = new Game(gameWidth, gameHeight);
                gameDiv.appendChild(gameSetupControls);
                //on submit with the start buton, do this:
                //gameDiv.removeChild(gameSetupControls);
                lastUpdate = Date.now();
                animateGame();
            }

            startNewGame();
        </script>
    </body>
<html>