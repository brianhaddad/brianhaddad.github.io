<!doctype HTML>
<html>
    <head>
        <title>Pirates vs. Mermaids</title>
        <link rel="stylesheet" href="../css/mvp.css">
    </head>
    <body>
        <script src="../scripts/html_tools.js"></script>
        <script>
            //TODO: it's getting kind of long... maybe start thinking about separate files?
            //TODO: need a way to show the rules for the player?
            /*******************
             * Alright, here's how this is going to go:
             * D4: (spy) move 3 spaces in any? (limit to diagonals?) direction and can jump over other pieces. deals its health in damage even if it dies.
             * D6: (grunt) move 2 spaces in any direction.
             * D12: (general? commander?) take up to 5 moves during a turn, can change directions while moving but cannot jump over other pieces.
             * D20: (armored unit) move 1 space forward/back/left/right. failed attacks simply mean the die does not move. only removed from the board by failing to defend.
             * 
             * Except for the D4, you can only attack a die with equal or lesser face value.
             * When attacking equal values, no matter the types of dice, both roll. higher value wins (reroll for ties) and their new face value is kept while the loser is removed from play.
             * Example: a D6 with a face value of 4 attacks a D4 with a face value of 4. They both roll. The D6 gets 3 and the D4 gets 2. The D4 is defeated
             * but the D6 keeps its new lower value of 3.
             * 
             * The game will come with one each of a special translucent, colored D12 to match the rest of the team dice.
             * This special die is the "princess" die used for capture the princess and king of the bay.
             * When used in Annihilation mode she has the following special ability:
             * Her movement can be like a normal D12 or she has the option to move as far as she wants in any straight line (think Queen in chess)
             * 
             * game modes: (come up with better names, each has a different point allotment)
             * conquer the bay: keep a piece on the center square. use special translucent D6?D12? to count down turns until victory.
             * annihilate: annihilate the opponent. princess-die is able to participate.
             *   perhaps this has the highest point allotment?
             * capture the princess: protect your translucent princess-die and if someone else captures it they have to transport it back to their base. (her point display doesn't matter)
             *   maybe this mode has smaller armies? max 45 points? 64?
             *   can the player ever move the princess in this mode? should it operate basically like chess where the princess is the "king"?
             * 
             * questions:
             * does the center square do anything special in annihilate or capture the flag modes?
             * 
             * game phases:
             * players build their army. each die has a value (D6 = 6, obviously) and there is a maxiumum value per army (to be determined)
             * also maximum of 2x the grid height number of dice per player (26 for 13x13)
             * once they have their armies selected then the colored dice are presented to the players to be placed in their home base (the two right-most or left-most columns)
             * players take turns positioning dice, and if one player has many more to position they just keep going until all are placed.
             * (simple click to select and click to place, no repositioning allowed!)
             * once all dice are placed, the game begins. not sure if it should be like chess where one side always goes first...
             * 
             * junior version:
             * 7x7 board, no D4 or D12 (just D6 and D20), one base column
             * 
             */
            //TODO: safe spots?
            const cellTypes = {
                center: 'centerCell',
                leftBase: 'leftBase',
                leftHeal: 'leftHeal',
                rightBase: 'rightBase',
                rightHeal: 'rightHeal',
            };

            const dieNames = {
                leftD4: `Pirate Spy`,
                rightD4: `Mermaid Spy`,
                leftD6: `Pirate`,
                rightD6: `Mermaid`,
                leftD12: `Pirate Captain`,
                rightD12: `Mermaid Queen`,
                leftD20: `Pirate Brute`,
                rightD20: `Mermaid Warrior`,
                leftSpecialD12: `Pirate Princess`,
                rightSpecialD12: `Mermaid Princess`,
            };

            const dieDescriptions = {
                leftD4: dieNames.leftD4 + ' (D4)',
                rightD4: dieNames.rightD4 + ' (D4)',
                leftD6: dieNames.leftD6 + ' (D6)',
                rightD6: dieNames.rightD6 + ' (D6)',
                leftD12: dieNames.leftD12 + ' (D12)',
                rightD12: dieNames.rightD12 + ' (D12)',
                leftD20: dieNames.leftD20 + ' (D20)',
                rightD20: dieNames.rightD20 + ' (D20)',
                leftSpecialD12: dieNames.leftSpecialD12 + ' (Special D12)',
                rightSpecialD12: dieNames.rightSpecialD12 + ' (Special D12)',
            };

            const numDiceIncluded = {
                leftD4: 16,
                rightD4: 16,
                leftD6: 13,
                rightD6: 13,
                leftD12: 8,
                rightD12: 8,
                leftD20: 2,
                rightD20: 2,
                leftSpecialD12: 1,
                rightSpecialD12: 1,
            };

            const dieValues = {
                leftD4: 4,
                rightD4: 4,
                leftD6: 6,
                rightD6: 6,
                leftD12: 12,
                rightD12: 12,
                leftD20: 20,
                rightD20: 20,
                leftSpecialD12: 15,
                rightSpecialD12: 15,
            };

            const dieFaces = {
                leftD4: 4,
                rightD4: 4,
                leftD6: 6,
                rightD6: 6,
                leftD12: 12,
                rightD12: 12,
                leftD20: 20,
                rightD20: 20,
                leftSpecialD12: 12,
                rightSpecialD12: 12,
            };

            function validMove(xPos, yPos, isAnAttack) {
                return {
                    x: xPos,
                    y: yPos,
                    isAttack: isAnAttack,
                };
            }

            function addMove(validMoves, newMove) {
                if (!validMoves.find(m => m.x === newMove.x && m.y === newMove.y)) {
                    validMoves.push(newMove);
                }
            }

            function evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle) {
                const enemy = enemyPositions.find(e => e.x === nx && e.y === ny);
                if (enemy && (enemy.value <= myValue || canAttackLosingBattle)) {
                    const attackMove = validMove(nx, ny, true);
                    if (!validBoardPosEvaluation(attackMove)) {
                        return false;
                    }
                    addMove(validMoves, attackMove);
                    if (!canPassToken) {
                        return false;
                    }
                }
                if (enemy && enemy.value > myValue && !canAttackLosingBattle) {
                    return canPassToken;
                }
                const friend = friendlyPositions.find(f => f.x === nx && f.y === ny);
                if (friend) {
                    return canPassToken;
                }
                const newMove = validMove(nx, ny);
                if (!validBoardPosEvaluation(newMove)) {
                    return false;
                }
                addMove(validMoves, newMove);
                return true;
            }

            function floodMoveStep(startPos, enemyPositions, friendlyPositions, validBoardPosEvaluation, moveDist, canPassToken, canAttackLosingBattle, validMoves) {
                if (moveDist <= 0) {
                    return;
                }
                const x = startPos.x;
                const y = startPos.y;
                const myValue = startPos.value;
                for (let ox = -1; ox <= 1; ox++) {
                    for (let oy = -1; oy <= 1; oy++) {
                        const nx = x + ox;
                        const ny = y + oy;
                        const newMove = {x: nx, y: ny, value: myValue};
                        if (validBoardPosEvaluation(newMove)
                            && evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                            floodMoveStep(newMove, enemyPositions, friendlyPositions, validBoardPosEvaluation, moveDist - 1, canPassToken, canAttackLosingBattle, validMoves);
                        }
                    }
                }
            }

            function trueOmnidirectionalMovement(startPos, enemyPositions, friendlyPositions, validBoardPosEvaluation, moveDist, canPassToken, canAttackLosingBattle) {
                const validMoves = [];
                floodMoveStep(startPos, enemyPositions, friendlyPositions, validBoardPosEvaluation, moveDist, canPassToken, canAttackLosingBattle, validMoves);
                return validMoves.filter(m => !(m.x === startPos.x && m.y === startPos.y));
            }

            function orthogonalMovement(startPos, enemyPositions, friendlyPositions, validBoardPosEvaluation, moveDist, canPassToken, canAttackLosingBattle) {
                const validMoves = [];
                const x = startPos.x;
                const y = startPos.y;
                const myValue = startPos.value;

                //right
                for (let ox = 1; ox <= moveDist; ox++) {
                    const nx = x + ox;
                    const ny = y;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }
                
                //left
                for (let ox = -1; ox >= -moveDist; ox--) {
                    const nx = x + ox;
                    const ny = y;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }
                
                //down
                for (let oy = 1; oy <= moveDist; oy++) {
                    const nx = x;
                    const ny = y + oy;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }
                
                //up
                for (let oy = -1; oy >= -moveDist; oy--) {
                    const nx = x;
                    const ny = y + oy;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }

                return validMoves;
            }

            function diagonalMovement(startPos, enemyPositions, friendlyPositions, validBoardPosEvaluation, moveDist, canPassToken, canAttackLosingBattle) {
                const validMoves = [];
                const x = startPos.x;
                const y = startPos.y;
                const myValue = startPos.value;

                //down/right
                for (let o = 1; o <= moveDist; o++) {
                    const nx = x + o;
                    const ny = y + o;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }

                //up/left
                for (let o = 1; o <= moveDist; o++) {
                    const nx = x - o;
                    const ny = y - o;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }

                //up/right
                for (let o = 1; o <= moveDist; o++) {
                    const nx = x + o;
                    const ny = y - o;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }

                //down/right
                for (let o = 1; o <= moveDist; o++) {
                    const nx = x - o;
                    const ny = y + o;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }

                return validMoves;
            }

            function MovementEvaluator(dist, canFly, canAttackUp, movementFunction) {
                const moveDist = dist;
                const canPassToken = canFly === true;
                const canAttackLosingBattle = canAttackUp === true;
                this.getMoves = (startPos, enemyPositions, friendlyPositions, validBoardPosEvaluator) =>
                    movementFunction(startPos, enemyPositions, friendlyPositions, validBoardPosEvaluator, moveDist, canPassToken, canAttackLosingBattle);
            }

            const movementTypes = {
                orthogonal: (dist, canFly, canAttackUp) => new MovementEvaluator(dist, canFly, canAttackUp, orthogonalMovement),
                diagonal: (dist, canFly, canAttackUp) => new MovementEvaluator(dist, canFly, canAttackUp, diagonalMovement),
                trueOmnidirectional: (dist, canFly, canAttackUp) => new MovementEvaluator(dist, canFly, canAttackUp, trueOmnidirectionalMovement),
            };

            //TODO: the movement distance for the D12 true omnidirectional (and probably the special D12) need to be adjusted for smaller boards!
            const dieMovements = {
                D4: [movementTypes.orthogonal(1), movementTypes.diagonal(3, true, true)],
                D6: [movementTypes.orthogonal(2), movementTypes.diagonal(2)],
                D12: [movementTypes.trueOmnidirectional(5)],
                D20: [movementTypes.orthogonal(1)],
                SpecialD12: [movementTypes.trueOmnidirectional(5), movementTypes.diagonal(99), movementTypes.orthogonal(99)],
            };

            const dieBuilders = {
                leftD4: (o) => new D(dieFaces.leftD4, o, themeColors.leftDiceColor, themeColors.leftDiceTextColor, false),
                leftD6: (o) => new D(dieFaces.leftD6, o, themeColors.leftDiceColor, themeColors.leftDiceTextColor, false),
                leftD12: (o) => new D(dieFaces.leftD12, o, themeColors.leftDiceColor, themeColors.leftDiceTextColor, false),
                leftD20: (o) => new D(dieFaces.leftD20, o, themeColors.leftDiceColor, themeColors.leftDiceTextColor, false),
                leftSpecialD12: (o) => new D(dieFaces.leftD12, o, themeColors.leftSpecialDiceColor, themeColors.leftDiceTextColor, true),
                rightD4: (o) => new D(dieFaces.rightD4, o, themeColors.rightDiceColor, themeColors.rightDiceTextColor, false),
                rightD6: (o) => new D(dieFaces.rightD6, o, themeColors.rightDiceColor, themeColors.rightDiceTextColor, false),
                rightD12: (o) => new D(dieFaces.rightD12, o, themeColors.rightDiceColor, themeColors.rightDiceTextColor, false),
                rightD20: (o) => new D(dieFaces.rightD20, o, themeColors.rightDiceColor, themeColors.rightDiceTextColor, false),
                rightSpecialD12: (o) => new D(dieFaces.rightD12, o, themeColors.rightSpecialDiceColor, themeColors.rightDiceTextColor, true),
            };

            const gameModes = {
                kingOfTheHill: 'Conquer the Bay',
                annihilation: 'Annihilation',
                captureTheFlag: 'Capture the Princess',
            };

            const boardSizes = {
                sevenWithOne: '7x7 w/ 1',
                sevenWithTwo: '7x7 w/ 2',
                nineWithOne: '9x9 w/ 1',
                nineWithTwo: '9x9 w/ 2',
                elevenWithOne: '11x11 w/ 1',
                elevenWithTwo: '11x11 w/ 2',
                thirteenWithOne: '13x13 w/ 1',
                thirteenWithTwo: '13x13 w/ 2',
            };

            const boardDimensions = {
                sevenWithOne: 7,
                sevenWithTwo: 7,
                nineWithOne: 9,
                nineWithTwo: 9,
                elevenWithOne: 11,
                elevenWithTwo: 11,
                thirteenWithOne: 13,
                thirteenWithTwo: 13,
            };

            const boardHomeColumns = {
                sevenWithOne: 1,
                sevenWithTwo: 2,
                nineWithOne: 1,
                nineWithTwo: 2,
                elevenWithOne: 1,
                elevenWithTwo: 2,
                thirteenWithOne: 1,
                thirteenWithTwo: 2,
            };

            const armyIncludesSpecial = {
                kingOfTheHill: false,
                annihilation: true,
                captureTheFlag: false,
            };

            //TODO: these values require lots of balancing and play testing! (especially for different board sizes!)
            //TODO: add a second layer to this that is accessed by board size
            const armySizeByGameMode = {
                kingOfTheHill: 96,
                annihilation: 128,
                captureTheFlag: 64,
            };

            const playerId = {
                left: 'left',
                right: 'right',
            };

            const playerNames = {
                left: `Pirate`,
                right: `Mermaid`,
            };

            const winStates = {
                noWinner: `Game in Progress`,
                draw: `Draw`,
                leftWins: `Pirates win!`,
                rightWins: `Mermaids win!`,
            };

            const gamePhases = {
                setup: `Game Setup`,
                leftPlaceDie: `Pirate: Place Your Die`,
                rightPlaceDie: `Mermaid: Place Your Die`,
                leftPlayerTurn: `Pirate's Turn`,
                rightPlayerTurn: `Mermaid's Turn`,
                leftPlayerWins: winStates.leftWins,
                rightPlayerWins: winStates.rightWins,
                //TODO: didn't use these two? do we want to add a little game mode for the roll-off?
                leftAttacksRight: `Pirate Attacks Mermaid!`,
                rightAttacksLeft: `Mermaid Attacks Pirate!`,
            };

            const themeColors = {
                boardBorderColor: 'rgb(0,0,0)',
                boardDefaultColor: 'rgb(18,166,236)',
                leftBaseColor: 'rgb(205,98,49)',
                leftDiceColor: 'rgb(48,16,32)',
                leftSpecialDiceColor: 'rgba(48,16,32,.7)',
                leftDiceTextColor: 'rgba(255,255,255,.7)',
                rightBaseColor: 'rgb(255,96,96)',
                rightDiceColor: 'rgb(46,155,87)',
                rightSpecialDiceColor: 'rgba(46,155,87,.7)',
                rightDiceTextColor: 'rgba(0,0,0,.85)',
                centerSquareColor: 'rgb(105,232,247)',
                centerStarColor: 'rgb(205,255,208)',
                lightenColor: 'rgba(255,255,255,.7)',
                darkenColor: 'rgba(0,16,0,.7)',
                defaultHoverHighlight: 'rgba(255,255,100,.75)',
                leftHoverHighlight: 'rgba(255,255,255,.75)',
                rightHoverHighlight: 'rgba(255,186,186,.85)',
                leftValidMoveHighlight: 'rgba(255,255,255,.65)',
                rightValidMoveHighlight: 'rgba(255,186,186,.75)',
                attackValidMoveHighlight: 'rgba(255,0,0,.75)',
                defaultDiceOutline: 'rgb(0,0,0)',
                highlightedDiceOutline: 'rgb(100,100,20)',
                armySizeBarBackground: 'rgba(0,0,0,.25)',
                armySizeBarGoodForeground: 'rgb(23,248,44)',
                armySizeBarBadForeground: 'rgb(248,23,44)',
                sparkleColor1: 'rgb(255,255,255)',
                sparkleColor2: 'rgb(255,150,255)',
                sparkleColor3: 'rgb(150,255,255)',
                sparkleColor4: 'rgb(255,255,150)',
                sparkleColor5: 'rgb(255,150,150)',
                sparkleColor6: 'rgb(150,255,150)',
                sparkleColor7: 'rgb(150,150,255)',
            };

            const dieMoveAnimationTime = 500;
            const gameWidth = 800;
            const gameHeight = 800;
            let gameGridSize = 13;
            let numBaseColumns = 2;

            function drawCenteredBoldText(ctx, text, color) {
                ctx.save();
                //TODO: allow font size to be passed in?
                ctx.font = 'bold 12px Arial';
                ctx.fillStyle = color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 0, 0);
                ctx.restore();
            }

            function drawStar(ctx, x, y, radius) {
                const innerRadius = radius * 0.382; // Inner radius for a visually pleasing star
                const outerAngle = 2 * Math.PI / 5; // Angle between outer points
                const innerAngle = Math.PI / 5; // Angle between inner and outer points

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(-Math.PI/2);

                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const outerPointX = radius * Math.cos(i * outerAngle);
                    const outerPointY = radius * Math.sin(i * outerAngle);
                    const innerPointX = innerRadius * Math.cos((i * outerAngle) + innerAngle);
                    const innerPointY = innerRadius * Math.sin((i * outerAngle) + innerAngle);

                    ctx.lineTo(outerPointX, outerPointY);
                    ctx.lineTo(innerPointX, innerPointY);
                }
                ctx.closePath();
                ctx.fill(); // Fill the star with the current fillStyle
                ctx.restore();
            }

            function fillTileSquare(ctx, x, y, tileSize) {
                ctx.fillRect(x - (tileSize/2), y - (tileSize/2), tileSize, tileSize);
            }

            function drawNgon(ctx, n, radius) {
                const outerAngle = 2 * Math.PI / n;
                let rotation = -Math.PI/2;
                if (n % 2 === 0) {
                    rotation = -Math.PI/4;
                }
                if (n > 3 && n % 3 === 0) {
                    rotation = -Math.PI/3;
                }

                ctx.save();
                ctx.rotate(rotation);

                ctx.beginPath();
                ctx.moveTo(radius, 0);
                for (let i = 0; i < n; i++) {
                    const outerPointX = radius * Math.cos(i * outerAngle);
                    const outerPointY = radius * Math.sin(i * outerAngle);

                    ctx.lineTo(outerPointX, outerPointY);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }

            function drawPlus(ctx, x, y, r) {
                ctx.save();
                const p = .3 * r;
                ctx.translate(x, y);

                ctx.beginPath();
                ctx.moveTo(-p, r);
                ctx.lineTo(p, r);
                ctx.lineTo(p, p);
                ctx.lineTo(r, p);
                ctx.lineTo(r, -p);
                ctx.lineTo(p, -p);
                ctx.lineTo(p, -r);
                ctx.lineTo(-p, -r);
                ctx.lineTo(-p, -p);
                ctx.lineTo(-r, -p);
                ctx.lineTo(-r, p);
                ctx.lineTo(-p, p);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }

            function offsetToPixelPosition(offset, cx, cy, tileSize) {
                return {
                        x: cx + (tileSize * offset.x),
                        y: cy + (tileSize * offset.y)
                    };
            }

            function SparkleEffect() {
                const sparkles = [];
                const colors = [
                    themeColors.sparkleColor1,
                    themeColors.sparkleColor2,
                    themeColors.sparkleColor3,
                    themeColors.sparkleColor4,
                    themeColors.sparkleColor5,
                    themeColors.sparkleColor6,
                    themeColors.sparkleColor7,
                ];

                const makeSparkle = () => {
                    const baseSize = 1 / 6;
                    const xOff = Math.random() - .5;
                    const yOff = Math.random() - .5;
                    const width = (Math.random() * (baseSize / 2)) + (baseSize / 2);
                    const height = (Math.random() * (baseSize / 2)) + (baseSize / 2);
                    const rotation = Math.random() * Math.PI;
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    return { x: xOff, y: yOff, w: width, h: height, r: rotation, c: color };
                };

                for (let i = 0; i < 24; i++) {
                    sparkles.push(makeSparkle());
                }

                this.draw = (ctx, r) => {
                    for (const sparkle of sparkles) {
                        ctx.save();
                        ctx.translate(sparkle.x * r, sparkle.y * r);
                        ctx.rotate(sparkle.r);
                        ctx.fillStyle = sparkle.c;
                        ctx.fillRect(-((sparkle.w * r)/2), -((sparkle.h * r)/2), sparkle.w * r, sparkle.h * r);
                        ctx.restore();
                    }
                };
            }

            function D(value, gridOffset, drawDieColor, drawTextColor, isSpecial) {
                const selectedScale = 1.25;
                const liftedScale = 1.5;
                const iAmSpecial = isSpecial === true;
                const maxValue = value;
                const name = 'D' + value;
                this.getMovementType = () => isSpecial ? 'Special' + name : name;
                this.getType = () => name;
                let displayValue = 1;
                this.getFaceValue = () => displayValue;
                this.heal = () => displayValue = maxValue;
                this.dealDamage = (dmg) => displayValue -= dmg;

                let isHighlighted = false;
                this.highlight = () => isHighlighted = true;
                this.unhighlight = () => isHighlighted = false;

                let isLifted = false;
                this.lift = () => isLifted = true;
                this.setDown = () => isLifted = false;
                
                const offset = {
                    x: gridOffset.x,
                    y: gridOffset.y,
                };
                const pos = (cx, cy, tileSize) => {
                    const p = offsetToPixelPosition(offset, cx, cy, tileSize);
                    return {
                        x: p.x,
                        y: p.y,
                        r: (tileSize * 2) / 5
                    };
                };

                let animating = false;
                let animateTime = 0;
                const animateTo = {x: 0, y: 0};
                const drawPos = (cx, cy, tileSize) => {
                    const p = pos(cx, cy, tileSize);
                    if (!animating) {
                        return p;
                    }
                    const targetPos = offsetToPixelPosition(animateTo, cx, cy, tileSize);
                    const dx = targetPos.x - p.x;
                    const dy = targetPos.y - p.y;
                    const t = 1 - (animateTime/dieMoveAnimationTime);
                    const f = t * t * (3.0 - 2.0 * t);
                    
                    return {
                        x: p.x + (f * dx),
                        y: p.y + (f * dy),
                        r: (tileSize * 2) / 5
                    };
                };

                this.getOffset = (wantTargetPosition) => {
                    if (animating) {
                        return {
                            x: animateTo.x,
                            y: animateTo.y,
                            value: displayValue,
                        };
                    }
                    return {
                        x: offset.x,
                        y: offset.y,
                        value: displayValue,
                    };
                };

                const effects = [];

                const dieColor = drawDieColor;
                const textColor = drawTextColor;

                const faces = [];
                for (let i = 0; i < value; i++) {
                    faces.push(i+1);
                }

                if (iAmSpecial && name === 'D12') {
                    effects.push(new SparkleEffect());
                }

                this.moveTo = (newX, newY, animateMe) => {
                    if (!animateMe) {
                        offset.x = newX;
                        offset.y = newY;
                        isLifted = false;
                    }
                    else {
                        animating = true;
                        animateTime = dieMoveAnimationTime;
                        animateTo.x = newX;
                        animateTo.y = newY;
                    }
                };

                this.getValidMoves = (enemyPositions, friendlyPositions, validBoardPosEvaluator) => {
                    const validMoves = [];
                    for (const evaluator of dieMovements[this.getMovementType()]) {
                        const newMoves = evaluator
                            .getMoves(this.getOffset(), enemyPositions, friendlyPositions, validBoardPosEvaluator)
                            .filter(move => validMoves.filter(m => move.x === m.x && move.y === m.y).length === 0);
                        validMoves.push(...newMoves);
                    }
                    return validMoves;
                };

                this.roll = () => {
                    displayValue = faces[Math.floor(Math.random() * faces.length)];
                };

                this.update = (dt) => {
                    if (animating) {
                        animateTime -= dt;
                        if (animateTime <= 0) {
                            animating = false;
                            offset.x = animateTo.x;
                            offset.y = animateTo.y;
                            isLifted = false;
                        }
                    }
                };

                const actuallyDraw = (ctx, cx, cy, tileSize, isForcedPosition, forceX, forceY) => {
                    const p = drawPos(cx, cy, tileSize);
                    const x = isForcedPosition === true ? forceX : p.x;
                    const y = isForcedPosition === true ? forceY : p.y;
                    const r = p.r;
                    ctx.save();
                    ctx.translate(x, y);
                    let scale = 1;
                    if (isHighlighted) {
                        scale = selectedScale;
                    }
                    if (isLifted) {
                        scale = liftedScale;
                    }
                    ctx.scale(scale, scale);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = isHighlighted ? themeColors.highlightedDiceOutline : themeColors.defaultDiceOutline;
                    ctx.fillStyle = dieColor;
                    switch (name) {
                        case 'D4':
                            drawNgon(ctx, 3, r);
                            break;

                        case 'D6':
                            drawNgon(ctx, 4, r);
                            break;

                        case 'D12':
                            if (iAmSpecial) {
                                for (const effect of effects) {
                                    effect.draw(ctx, r);
                                }
                            }
                            drawNgon(ctx, 5, r);
                            break;

                        case 'D20':
                            drawNgon(ctx, 6, r);
                            break;
                    }
                    drawCenteredBoldText(ctx, displayValue, textColor);
                    ctx.restore();
                };

                this.draw = (context, centerX, centerY, ts, isForcedPosition, forceX, forceY) => {
                    const topLayerDrawCalls = [];
                    if (isLifted) {
                        topLayerDrawCalls.push((ctx, cx, cy, tileSize) => {
                            actuallyDraw(ctx, cx, cy, tileSize, isForcedPosition, forceX, forceY);
                        });
                    }
                    else {
                        actuallyDraw(context, centerX, centerY, ts, isForcedPosition, forceX, forceY);
                    }
                    return topLayerDrawCalls;
                };
            }

            function GridCell(gX, gY, gridOffset, myCellType, makeDark) {
                const col = gX;
                const row = gY;
                const offset = {
                    x: gridOffset.x,
                    y: gridOffset.y,
                };
                const dark = makeDark;
                const cellType = myCellType;

                const pos = (cx, cy, tileSize) => offsetToPixelPosition(offset, cx, cy, tileSize);

                let hoverHighlighted = false;

                const collidePoint = (px, py, cx, cy, tileSize) => {
                    const myPos = pos(cx, cy, tileSize);
                    const left = myPos.x - (tileSize/2);
                    const top = myPos.y - (tileSize/2);
                    const withinHorizontal = px > left && px < left + tileSize;
                    const withinVertical = py > top && py < top + tileSize;
                    return withinHorizontal && withinVertical;
                };

                this.isLeftHeal = () => cellType === cellTypes.leftHeal;
                this.isRightHeal = () => cellType === cellTypes.rightHeal;

                this.isSamePosition = (gridOffset) => offset.x === gridOffset.x && offset.y === gridOffset.y;
                this.getOffset = () => {
                    return {
                        x: offset.x,
                        y: offset.y,
                    };
                };

                this.checkHover = (posX, posY, cx, cy, tileSize) => {
                    hoverHighlighted = collidePoint(posX, posY, cx, cy, tileSize);
                    return hoverHighlighted ? this : null;
                };

                const fillBaseColorRect = (ctx, x, y, tileSize) => {
                    fillTileSquare(ctx, x, y, tileSize);
                    darken(ctx, x, y, tileSize);
                };

                const darken = (ctx, x, y, tileSize) => {
                    if (!dark) {
                        return;
                    }
                    ctx.save();
                    ctx.fillStyle = themeColors.darkenColor;
                    fillTileSquare(ctx, x, y, tileSize);
                    ctx.restore();
                };

                this.draw = (ctx, cx, cy, tileSize) => {
                    const myPos = pos(cx, cy, tileSize);
                    const x = myPos.x;
                    const y = myPos.y;
                    const topLayerDrawCalls = [];
                    ctx.save();

                    switch (cellType) {
                        case cellTypes.center:
                            ctx.fillStyle = themeColors.centerSquareColor;
                            fillBaseColorRect(ctx, x, y, tileSize);

                            ctx.fillStyle = themeColors.centerStarColor;
                            drawStar(ctx, x, y, (tileSize*4)/9);
                            break;

                        case cellTypes.leftBase:
                            ctx.fillStyle = themeColors.leftBaseColor;
                            fillBaseColorRect(ctx, x, y, tileSize);
                            break;

                        case cellTypes.leftHeal:
                            ctx.fillStyle = themeColors.leftBaseColor;
                            fillBaseColorRect(ctx, x, y, tileSize);
                            ctx.fillStyle = themeColors.lightenColor;
                            drawPlus(ctx, x, y, (tileSize*4)/9);
                            break;

                        case cellTypes.rightBase:
                            ctx.fillStyle = themeColors.rightBaseColor;
                            fillBaseColorRect(ctx, x, y, tileSize);
                            break;

                        case cellTypes.rightHeal:
                            ctx.fillStyle = themeColors.rightBaseColor;
                            fillBaseColorRect(ctx, x, y, tileSize);
                            ctx.fillStyle = themeColors.lightenColor;
                            drawPlus(ctx, x, y, (tileSize*4)/9);
                            break;

                        default:
                            ctx.fillStyle = themeColors.boardDefaultColor;
                            fillBaseColorRect(ctx, x, y, tileSize);
                    }
                    ctx.restore();
                    return topLayerDrawCalls;
                };

                this.drawHoverHighlight = (ctx, cx, cy, tileSize, player) => {
                    const myPos = pos(cx, cy, tileSize);
                    const x = myPos.x;
                    const y = myPos.y;
                    const w = 6;
                    const hw = w / 2;
                    ctx.save();
                    ctx.strokeStyle = themeColors.defaultHoverHighlight;
                    if (player === playerId.left) {
                        ctx.strokeStyle = themeColors.leftHoverHighlight;
                    }
                    if (player === playerId.right) {
                        ctx.strokeStyle = themeColors.rightHoverHighlight;
                    }
                    ctx.lineWidth = w;
                    ctx.beginPath();
                    ctx.roundRect(x - (tileSize/2) - hw, y - (tileSize/2) - hw, tileSize + w, tileSize + w, 8);
                    ctx.stroke();
                    ctx.restore();
                };
            }

            function Grid(numRows, numCols, baseColumns) {
                const rows = numRows;
                const cols = numCols;
                const cells = [];
                const hasCenter = (rows % 2 === 1) && (cols % 2 === 1);
                const healingSpotRowInset = 1;
                const playerBaseCols = baseColumns;
                const gridPositionOffsets = [];
                const leftPlayerBaseOffsets = [];
                const leftPlayerCaptureOffsets = [];
                const rightPlayerBaseOffsets = [];
                const rightPlayerCaptureOffsets = [];
                let minOffsetX = numCols;
                let maxOffsetX = 0;
                let minOffsetY = numRows;
                let maxOffsetY = 0;

                const leftPlayerDice = [];
                const leftPlayerCapturedDice = [];
                const rightPlayerDice = [];
                const rightPlayerCapturedDice = [];
                let player = '';

                this.setPlayer = (newPlayer) => {
                    player = newPlayer;
                };

                const isHealingRow = (r) => (r == healingSpotRowInset || r == (rows - 1) - healingSpotRowInset);

                let highlightedCell = null;
                let highlightedDie = null;

                for (let r = 0; r < rows; r++) {
                    gridPositionOffsets[r] = [];
                    for (let c = 0; c < cols; c++) {
                        let cellType = '';
                        if (hasCenter && r === Math.floor(rows/2) && c === Math.floor(cols/2)) {
                            cellType = cellTypes.center;
                        }
                        if (c < playerBaseCols) {
                            cellType = cellTypes.leftBase;
                            if (c == 0 && isHealingRow(r)) {
                                cellType = cellTypes.leftHeal;
                            }
                        }
                        if (c >= cols - playerBaseCols) {
                            cellType = cellTypes.rightBase;
                            if (c == cols - 1 && isHealingRow(r)) {
                                cellType = cellTypes.rightHeal;
                            }
                        }
                        const offset = {
                            x: (c - ((cols - 1) / 2)),
                            y: (r - ((rows - 1) / 2))
                        };
                        const makeDark = (r % 2) == (c % 2);
                        cells.push(new GridCell(c, r, offset, cellType, makeDark));
                        gridPositionOffsets[r][c] = offset;
                        if (cellType === cellTypes.leftBase || cellType === cellTypes.leftHeal) {
                            leftPlayerBaseOffsets.push(offset);
                        }
                        if (cellType === cellTypes.rightBase || cellType === cellTypes.rightHeal) {
                            rightPlayerBaseOffsets.push(offset);
                        }
                        
                        //Yes, I realize this is entirely unnecessary and the values can just be calculated.
                        //Maybe I'm doing it just for show. Maybe I'm doing it out of laziness. It's not like
                        //this code runs every frame. :)
                        minOffsetX = Math.min(minOffsetX, offset.x);
                        maxOffsetX = Math.max(maxOffsetX, offset.x);
                        minOffsetY = Math.min(minOffsetY, offset.y);
                        maxOffsetY = Math.max(maxOffsetY, offset.y);
                    }
                }

                const captureOffsetStep = 1/playerBaseCols;
                const startingLeftCaptureOffset = gridPositionOffsets[0][0];
                let capturePosX = startingLeftCaptureOffset.x - 1;
                let dY = captureOffsetStep;
                let captureStartY = startingLeftCaptureOffset.y;
                for (let i = -1; i < rows * playerBaseCols; i++) {
                    leftPlayerCaptureOffsets.push({
                        x: capturePosX,
                        y: captureStartY + (i * dY)
                    });
                }

                const startingRightCaptureOffset = gridPositionOffsets[rows-1][cols-1];
                capturePosX = startingRightCaptureOffset.x + 1;
                dY = -captureOffsetStep;
                captureStartY = startingRightCaptureOffset.y;
                for (let i = -1; i < rows * playerBaseCols; i++) {
                    rightPlayerCaptureOffsets.push({
                        x: capturePosX,
                        y: captureStartY + (i * dY)
                    });
                }

                const anyLeftDiceInPos = (checkPos) => {
                    for (const die of leftPlayerDice) {
                        const diePos = die.getOffset();
                        if (checkPos.x === diePos.x && checkPos.y === diePos.y) {
                            return true;
                        }
                    }
                    return false;
                };

                const anyRightDiceInPos = (checkPos) => {
                    for (const die of rightPlayerDice) {
                        const diePos = die.getOffset();
                        if (checkPos.x === diePos.x && checkPos.y === diePos.y) {
                            return true;
                        }
                    }
                    return false;
                };

                this.allLeftDiceArePlacedInBase = () => {
                    for (const die of leftPlayerDice) {
                        const diePos = die.getOffset(true);
                        if (leftPlayerBaseOffsets.find(pos => pos.x === diePos.x && pos.y === diePos.y) === undefined) {
                            return false;
                        }
                    }
                    return true;
                };

                this.allRightDiceArePlacedInBase = () => {
                    for (const die of rightPlayerDice) {
                        const diePos = die.getOffset(true);
                        if (rightPlayerBaseOffsets.find(pos => pos.x === diePos.x && pos.y === diePos.y) === undefined) {
                            return false;
                        }
                    }
                    return true;
                };

                let leftCounterDie = null;
                let rightCounterDie = null;

                this.generatePlayerDice = (leftPlayerArmy, rightPlayerArmy, gameMode) => {
                    const offsetPool = [];
                    const kingOfTheHillMode = gameModes[gameMode] === gameModes.kingOfTheHill;
                    for (let r = 0; r < rows; r++) {
                        for (let c = playerBaseCols; c < cols - playerBaseCols; c++) {
                            offsetPool.push(gridPositionOffsets[r][c]);
                        }
                    }
                    if (kingOfTheHillMode || gameModes[gameMode] === gameModes.captureTheFlag) {
                        leftPlayerArmy['leftSpecialD12'] = 1;
                        rightPlayerArmy['rightSpecialD12'] = 1;
                    }
                    for (const id in leftPlayerArmy) {
                        for (let i = 0; i < leftPlayerArmy[id]; i++) {
                            const offset = kingOfTheHillMode && id === 'leftSpecialD12'
                                ? {x: -1, y: gridPositionOffsets[0][0].y - 1}
                                : offsetPool.splice(Math.floor(Math.random() * offsetPool.length), 1)[0];
                            const die = dieBuilders[id](offset);
                            let addToArmy = true;
                            if (kingOfTheHillMode && id === 'leftSpecialD12') {
                                addToArmy = false;
                                die.heal();
                                leftCounterDie = die;
                            }
                            if (addToArmy) {
                                die.roll();
                                leftPlayerDice.push(die);
                            }
                        }
                    }
                    
                    for (const id in rightPlayerArmy) {
                        for (let i = 0; i < rightPlayerArmy[id]; i++) {
                            const offset = kingOfTheHillMode && id === 'rightSpecialD12'
                                ? {x: 1, y: gridPositionOffsets[0][0].y - 1}
                                : offsetPool.splice(Math.floor(Math.random() * offsetPool.length), 1)[0];
                            const die = dieBuilders[id](offset);
                            let addToArmy = true;
                            if (kingOfTheHillMode && id === 'rightSpecialD12') {
                                addToArmy = false;
                                die.heal();
                                rightCounterDie = die;
                            }
                            if (addToArmy) {
                                die.roll();
                                rightPlayerDice.push(die);
                            }
                        }
                    }
                };

                const getHighlightedDie = (army) => {
                    for (const die of army) {
                        if (highlightedCell.isSamePosition(die.getOffset())) {
                            return die;
                        }
                    }
                    return null;
                };

                let mx = 0;
                let my = 0;

                this.mouseMove = (mouseX, mouseY, x, y, tileSize) => {
                    if (movingDieIsBeingDragged) {
                        mx = mouseX;
                        my = mouseY;
                    }
                    //TODO: cursor style manipulation/replacement?
                    let currentlyHighlighted = null;
                    for (const cell of cells) {
                        currentlyHighlighted ??= cell.checkHover(mouseX, mouseY, x, y, tileSize);
                    }
                    if (highlightedCell !== currentlyHighlighted) {
                        highlightedCell = currentlyHighlighted;
                        if (highlightedDie !== null) {
                            highlightedDie.unhighlight();
                        }
                        if (highlightedCell !== null) {
                            //mouse has entered a cell
                            //TODO: disallow highlighting a die that has been placed in the player base while in the arrangement phase?
                            if (player === playerId.left) {
                                highlightedDie = getHighlightedDie(leftPlayerDice);
                            }
                            if (player === playerId.right) {
                                highlightedDie = getHighlightedDie(rightPlayerDice);
                            }
                            if (highlightedDie !== null) {
                                highlightedDie.highlight();
                            }
                        }
                        //else {
                        //    console.log('mouse has left a cell');
                        //}
                    }
                };

                this.update = (dt) => {
                    for (const die of leftPlayerDice) {
                        die.update(dt);
                    }
                    for (const die of leftPlayerCapturedDice) {
                        die.update(dt);
                    }
                    for (const die of rightPlayerDice) {
                        die.update(dt);
                    }
                    for (const die of rightPlayerCapturedDice) {
                        die.update(dt);
                    }
                };

                let validMoves = [];
                const validBoardPosEval = (pos) => 
                    pos.x >= minOffsetX
                    && pos.x <= maxOffsetX
                    && pos.y >= minOffsetY
                    && pos.y <= maxOffsetY;

                const setValidMoves = (gamePhase) => {
                    validMoves = [];
                    switch (gamePhase) {
                        case gamePhases.leftPlaceDie:
                            validMoves = leftPlayerBaseOffsets.filter(x => !anyLeftDiceInPos(x));
                            break;

                        case gamePhases.rightPlaceDie:
                            validMoves = rightPlayerBaseOffsets.filter(x => !anyRightDiceInPos(x));
                            break;
                            
                        case gamePhases.leftPlayerTurn:
                            if (movingDie !== null) {
                                validMoves = movingDie.getValidMoves(rightPlayerDice.map(d => d.getOffset()), leftPlayerDice.map(d => d.getOffset()), validBoardPosEval);
                            }
                            break;

                        case gamePhases.rightPlayerTurn:
                            if (movingDie !== null) {
                                validMoves = movingDie.getValidMoves(leftPlayerDice.map(d => d.getOffset()), rightPlayerDice.map(d => d.getOffset()), validBoardPosEval);
                            }
                            break;
                    }
                };

                const getValidMove = (gridTile) => {
                    for (const pos of validMoves) {
                        if (gridTile.isSamePosition(pos)) {
                            return pos;
                        }
                    }
                    return null;
                };

                const isValidMove = (gridTile) => {
                    for (const pos of validMoves) {
                        if (gridTile.isSamePosition(pos)) {
                            return true;
                        }
                    }
                    return false;
                };

                const indexOf = (armyDice, searchLoc) => {
                    for (let i = 0; i < armyDice.length; i++) {
                        const compareLoc = armyDice[i].getOffset();
                        if (compareLoc.x === searchLoc.x && compareLoc.y === searchLoc.y) {
                            return i;
                        }
                    }
                    return -1;
                };

                this.attemptMoveDie = () => {
                    if (movingDie === null || highlightedCell === null) {
                        return false;
                    }
                    if (!isValidMove(highlightedCell)) {
                        movingDie.setDown();
                        movingDie = null;
                        movingDieIsBeingDragged = false;
                        return false;
                    }
                    const newOffset = highlightedCell.getOffset();
                    const isAttack = getValidMove(highlightedCell).isAttack === true;
                    if (isAttack) {
                        if (player === playerId.left) {
                            const victimIndex = indexOf(rightPlayerDice, newOffset);
                            if (victimIndex > -1 && rightPlayerDice[victimIndex].getFaceValue() < movingDie.getFaceValue()) {
                                const victim = rightPlayerDice.splice(victimIndex, 1)[0];
                                const jailLocation = leftPlayerCaptureOffsets.splice(0, 1)[0];
                                victim.moveTo(jailLocation.x, jailLocation.y, true);
                                leftPlayerCapturedDice.push(victim);
                            }
                            else if (victimIndex > -1 && rightPlayerDice[victimIndex].getFaceValue() > movingDie.getFaceValue()) {
                                //TODO: should we trust that it should be an attack or verify that the attacker can do this?
                                //out of laziness, right now we'll trust the move data lol
                                rightPlayerDice[victimIndex].dealDamage(movingDie.getFaceValue());
                                const attackerIndex = indexOf(leftPlayerDice, movingDie.getOffset());
                                const deadAttacker = leftPlayerDice.splice(attackerIndex, 1)[0];
                                const jailLocation = rightPlayerCaptureOffsets.splice(0, 1)[0];
                                newOffset.x = jailLocation.x;
                                newOffset.y = jailLocation.y;
                                rightPlayerCapturedDice.push(deadAttacker);
                            }
                            else if (victimIndex > -1 && rightPlayerDice[victimIndex].getFaceValue() === movingDie.getFaceValue()) {
                                //roll the dice and whoever loses loses
                                while (rightPlayerDice[victimIndex].getFaceValue() === movingDie.getFaceValue()) {
                                    rightPlayerDice[victimIndex].roll()
                                    movingDie.roll()
                                    if (rightPlayerDice[victimIndex].getFaceValue() > movingDie.getFaceValue()) {
                                        //moving die loses
                                        const attackerIndex = indexOf(leftPlayerDice, movingDie.getOffset());
                                        const deadAttacker = leftPlayerDice.splice(attackerIndex, 1)[0];
                                        const jailLocation = rightPlayerCaptureOffsets.splice(0, 1)[0];
                                        newOffset.x = jailLocation.x;
                                        newOffset.y = jailLocation.y;
                                        rightPlayerCapturedDice.push(deadAttacker);
                                        break;
                                    }
                                    else if (rightPlayerDice[victimIndex].getFaceValue() < movingDie.getFaceValue()) {
                                        //attacked die loses
                                        const victim = rightPlayerDice.splice(victimIndex, 1)[0];
                                        const jailLocation = leftPlayerCaptureOffsets.splice(0, 1)[0];
                                        victim.moveTo(jailLocation.x, jailLocation.y, true);
                                        leftPlayerCapturedDice.push(victim);
                                        break;
                                    }
                                }
                            }
                        }
                        else if (player === playerId.right) {
                            const victimIndex = indexOf(leftPlayerDice, newOffset);
                            if (victimIndex > -1 && leftPlayerDice[victimIndex].getFaceValue() < movingDie.getFaceValue()) {
                                const victim = leftPlayerDice.splice(victimIndex, 1)[0];
                                const jailLocation = rightPlayerCaptureOffsets.splice(0, 1)[0];
                                victim.moveTo(jailLocation.x, jailLocation.y, true);
                                rightPlayerCapturedDice.push(victim);
                            }
                            else if (victimIndex > -1 && leftPlayerDice[victimIndex].getFaceValue() > movingDie.getFaceValue()) {
                                //TODO: should we trust that it should be an attack or verify that the attacker can do this?
                                //out of laziness, right now we'll trust the move data lol
                                leftPlayerDice[victimIndex].dealDamage(movingDie.getFaceValue());
                                const attackerIndex = indexOf(rightPlayerDice, movingDie.getOffset());
                                const deadAttacker = rightPlayerDice.splice(attackerIndex, 1)[0];
                                const jailLocation = leftPlayerCaptureOffsets.splice(0, 1)[0];
                                newOffset.x = jailLocation.x;
                                newOffset.y = jailLocation.y;
                                leftPlayerCapturedDice.push(deadAttacker);
                            }
                            else if (victimIndex > -1 && leftPlayerDice[victimIndex].getFaceValue() === movingDie.getFaceValue()) {
                                //roll the dice and whoever loses loses
                                while (leftPlayerDice[victimIndex].getFaceValue() === movingDie.getFaceValue()) {
                                    leftPlayerDice[victimIndex].roll()
                                    movingDie.roll()
                                    if (leftPlayerDice[victimIndex].getFaceValue() > movingDie.getFaceValue()) {
                                        //moving die loses
                                        const attackerIndex = indexOf(rightPlayerDice, movingDie.getOffset());
                                        const deadAttacker = rightPlayerDice.splice(attackerIndex, 1)[0];
                                        const jailLocation = leftPlayerCaptureOffsets.splice(0, 1)[0];
                                        newOffset.x = jailLocation.x;
                                        newOffset.y = jailLocation.y;
                                        leftPlayerCapturedDice.push(deadAttacker);
                                        break;
                                    }
                                    else if (leftPlayerDice[victimIndex].getFaceValue() < movingDie.getFaceValue()) {
                                        //attacked die loses
                                        const victim = leftPlayerDice.splice(victimIndex, 1)[0];
                                        const jailLocation = rightPlayerCaptureOffsets.splice(0, 1)[0];
                                        victim.moveTo(jailLocation.x, jailLocation.y, true);
                                        rightPlayerCapturedDice.push(victim);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    movingDie.moveTo(newOffset.x, newOffset.y, !movingDieIsBeingDragged);
                    movingDie = null;
                    movingDieIsBeingDragged = false;
                    return true;
                };

                let movingDie = null;
                let movingDieIsBeingDragged = false;

                this.lockHighlightedDie = (isDragging, gamePhase) => {
                    if (!this.highlightingDie()) {
                        return;
                    }
                    if (movingDie !== null) {
                        movingDie.setDown();
                    }
                    movingDieIsBeingDragged = isDragging === true;
                    movingDie = highlightedDie;
                    movingDie.lift();
                    setValidMoves(gamePhase);
                };

                this.highlightingDie = () => highlightedDie !== null && movingDie === null;

                const isRightPlayerTurn = () => player === playerId.right;
                const isLeftPlayerTurn = () => player === playerId.left;

                this.evaluateCellEffects = () => {
                    for (const cell of cells) {
                        const cellOffset = cell.getOffset();
                        const leftDie = leftPlayerDice.find(d => cell.isSamePosition(d.getOffset()));
                        const rightDie = rightPlayerDice.find(d => cell.isSamePosition(d.getOffset()));
                        if (leftDie && cell.isLeftHeal()) {
                            leftDie.heal();
                        }
                        if (rightDie && cell.isRightHeal()) {
                            rightDie.heal();
                        }
                        if (cellOffset.x === 0 && cellOffset.y === 0) {
                            if (isLeftPlayerTurn() && leftCounterDie !== null) {
                                if (leftDie) {
                                    leftCounterDie.dealDamage(1);
                                }
                                else {
                                    leftCounterDie.heal();
                                }
                            }
                            if (isRightPlayerTurn() && rightCounterDie !== null) {
                                if (rightDie) {
                                    rightCounterDie.dealDamage(1);
                                }
                                else {
                                    rightCounterDie.heal();
                                }
                            }
                        }
                    }
                };

                this.evaluateWinConditions = (gameMode) => {
                    const leftPlayerEliminated = leftPlayerDice.length === 0;
                    const rightPlayerEliminated = rightPlayerDice.length === 0;
                    //Note: for all gamemodes, elmination is a way to win!
                    if (leftPlayerEliminated && rightPlayerEliminated) {
                        return winStates.draw; //Note: should be impossible!
                    }
                    if (leftPlayerEliminated) {
                        return winStates.rightWins;
                    }
                    if (rightPlayerEliminated) {
                        return winStates.leftWins;
                    }
                    switch (gameModes[gameMode]) {
                        case gameModes.annihilation:
                            return winStates.noWinner;

                        case gameModes.kingOfTheHill:
                            if (leftCounterDie.getFaceValue() <= 1) {
                                return winStates.leftWins;
                            }
                            if (rightCounterDie.getFaceValue() <= 1) {
                                return winStates.rightWins;
                            }
                            return winStates.noWinner;

                        case gameModes.captureTheFlag:
                            const leftSpecialDie = leftPlayerDice.find(d => d.getMovementType() === 'SpecialD12');
                            const rightSpecialDie = rightPlayerDice.find(d => d.getMovementType() === 'SpecialD12');
                            if (!leftSpecialDie && !rightSpecialDie) {
                                return winStates.draw; //Note: again, shouldn't be possible!
                            }
                            if (leftSpecialDie && !rightSpecialDie) {
                                return winStates.leftWins;
                            }
                            if (!leftSpecialDie && rightSpecialDie) {
                                return winStates.rightWins;
                            }
                            return winStates.noWinner;
                    }
                    //TODO: should be impossible to get to this line... maybe raise some kind of error?
                    return winStates.noWinner;
                };

                const drawLeftPlayer = (ctx, x, y, tileSize) => {
                    const topLayer = [];
                    for (const captive of leftPlayerCapturedDice) {
                        const newTopLayerItems = captive.draw(ctx, x, y, tileSize);
                        topLayer.push(...newTopLayerItems);
                    }
                    for (const left of leftPlayerDice) {
                        let isBeingDragged = false;
                        if (movingDieIsBeingDragged && movingDie !== null) {
                            const lp = left.getOffset();
                            const mp = movingDie.getOffset();
                            isBeingDragged = lp.x === mp.x && lp.y === mp.y;
                        }
                        const newTopLayerItems = left.draw(ctx, x, y, tileSize, isBeingDragged, mx, my);
                        topLayer.push(...newTopLayerItems);
                    }
                    if (leftCounterDie) {
                        leftCounterDie.draw(ctx, x, y, tileSize);
                    }
                    return topLayer;
                };

                const drawRightPlayer = (ctx, x, y, tileSize) => {
                    const topLayer = [];
                    for (const captive of rightPlayerCapturedDice) {
                        const newTopLayerItems = captive.draw(ctx, x, y, tileSize);
                        topLayer.push(...newTopLayerItems);
                    }
                    for (const right of rightPlayerDice) {
                        let isBeingDragged = false;
                        if (movingDieIsBeingDragged && movingDie !== null) {
                            const rp = right.getOffset();
                            const mp = movingDie.getOffset();
                            isBeingDragged = rp.x === mp.x && rp.y === mp.y;
                        }
                        const newTopLayerItems = right.draw(ctx, x, y, tileSize, isBeingDragged, mx, my);
                        topLayer.push(...newTopLayerItems);
                    }
                    if (rightCounterDie) {
                        rightCounterDie.draw(ctx, x, y, tileSize);
                    }
                    return topLayer;
                };

                this.draw = (ctx, x, y, tileSize, showValidMoves) => {
                    const topLayer = [];
                    let newTopLayerItems = [];
                    for (const cell of cells) {
                        newTopLayerItems = cell.draw(ctx, x, y, tileSize);
                        topLayer.push(...newTopLayerItems);
                    }
                    if (showValidMoves === true) {
                        ctx.save();
                        const defaultFillStyle = (player === playerId.left)
                            ? themeColors.leftValidMoveHighlight
                            : themeColors.rightValidMoveHighlight;
                        ctx.fillStyle = defaultFillStyle;
                        for (const pos of validMoves) {
                            const isAttack = pos.hasOwnProperty('isAttack') && pos.isAttack === true;
                            if (isAttack) {
                                ctx.fillStyle = themeColors.attackValidMoveHighlight;
                            }
                            const p = offsetToPixelPosition(pos, x, y, tileSize);
                            fillTileSquare(ctx, p.x, p.y, tileSize);
                            if (isAttack) {
                                ctx.fillStyle = defaultFillStyle;
                            }
                        }
                        ctx.restore();
                    }
                    if (player === playerId.left) {
                        newTopLayerItems = drawRightPlayer(ctx, x, y, tileSize);
                        topLayer.push(...newTopLayerItems);
                        newTopLayerItems = drawLeftPlayer(ctx, x, y, tileSize);
                        topLayer.push(...newTopLayerItems);
                    }
                    else {
                        newTopLayerItems = drawLeftPlayer(ctx, x, y, tileSize);
                        topLayer.push(...newTopLayerItems);
                        newTopLayerItems = drawRightPlayer(ctx, x, y, tileSize);
                        topLayer.push(...newTopLayerItems);
                    }
                    if (highlightedCell !== null && showValidMoves && isValidMove(highlightedCell)) {
                        highlightedCell.drawHoverHighlight(ctx, x, y, tileSize, player);
                    }
                    for (const top of topLayer) {
                        top(ctx, x, y, tileSize);
                    }
                };
            }

            function Game(width, height, gridDimension, baseColumns, gameStatusContainer) {
                let w = width;
                let h = height;
                const gridSize = gridDimension;
                const statusContainer = gameStatusContainer;
                statusContainer.innerHTML = '';
                const container = createElement('div', { 'style': `width:100%;display:flex;flex-direction:row;justify-content:space-between;flex-wrap:wrap;` }, null);
                statusContainer.appendChild(container);
                const statusOutputs = {
                    gameMode: 'Game Mode',
                    gamePhase: 'Game Phase',
                    playerTurn: 'Player Turn',
                    //TODO: have the Grid supply the army information
                    //leftPlayerStatus: `${playerNames.left} Army Status`,
                    //rightPlayerStatus: `${playerNames.right} Army Status`,
                };

                for (const outputId in statusOutputs) {
                    const fs = makeFieldset(statusOutputs[outputId]);
                    statusOutputs[outputId] = new SimpleTextOutput(fs);
                    container.appendChild(fs);
                }

                const updateStatusDisplay = () => {
                    //TODO: maybe just make a status manager class and pass in the same data that we'll persist for gamesave?
                    statusOutputs.gameMode.updateText(gameModes[gameMode]);
                    statusOutputs.gamePhase.updateText(gamePhase);
                    statusOutputs.playerTurn.updateText(playerNames[currentPlayerTurn]);
                    //TODO: on win, the display should show a button that allows the user to start a new game and the player turn segment should probably be removed.
                };

                const x = () => w / 2;
                const y = () => h / 2;
                const pxTileSize = () => Math.floor(Math.min(w, h) / (gridSize + 2));

                const grid = new Grid(gridSize, gridSize, baseColumns);

                let gameMode = '';
                let gamePhase = gamePhases.setup;
                let currentPlayerTurn = '';

                const setGamePhase = (newGamePhase) => {
                    //TODO: when changing game phases, maybe have some huge text appear in the game board window? lol
                    gamePhase = newGamePhase;
                    let winState = winStates.noWinner;
                    switch (gamePhase) {
                        case gamePhases.leftPlaceDie:
                            currentPlayerTurn = playerId.left;
                            grid.setPlayer(currentPlayerTurn);
                            break;

                        case gamePhases.leftPlayerTurn:
                            grid.evaluateCellEffects();
                            winState = grid.evaluateWinConditions(gameMode);
                            if (winState === winStates.noWinner) {
                                currentPlayerTurn = playerId.left;
                                grid.setPlayer(currentPlayerTurn);
                            }
                            break;
                            
                        case gamePhases.rightPlaceDie:
                            currentPlayerTurn = playerId.right;
                            grid.setPlayer(currentPlayerTurn);
                            break;

                        case gamePhases.rightPlayerTurn:
                            grid.evaluateCellEffects();
                            winState = grid.evaluateWinConditions(gameMode);
                            if (winState === winStates.noWinner) {
                                currentPlayerTurn = playerId.right;
                                grid.setPlayer(currentPlayerTurn);
                            }
                            break;
                    }
                    //TODO: there is no gamePhase for a draw, but draws should not be possible, right? RIGHT??!?!!!?
                    switch (winState) {
                        case winStates.leftWins:
                            return setGamePhase(gamePhases.leftPlayerWins);
                            
                        case winStates.rightWins:
                            return setGamePhase(gamePhases.rightPlayerWins);
                    }
                    updateStatusDisplay();
                };

                const changeGamePhase = () => {
                    const currentGamePhase = gamePhase;
                    switch (currentGamePhase) {
                        case gamePhases.leftPlaceDie:
                            if (!grid.allRightDiceArePlacedInBase()) {
                                setGamePhase(gamePhases.rightPlaceDie);
                            }
                            else if (grid.allLeftDiceArePlacedInBase()) {
                                setGamePhase(gamePhases.rightPlayerTurn); //TODO: who really goes first?
                            }
                            break;

                        case gamePhases.rightPlaceDie:
                            if (!grid.allLeftDiceArePlacedInBase()) {
                                setGamePhase(gamePhases.leftPlaceDie);
                            }
                            else if (grid.allRightDiceArePlacedInBase()) {
                                setGamePhase(gamePhases.rightPlayerTurn); //TODO: who really goes first?
                            }
                            break;

                        case gamePhases.leftPlayerTurn:
                            setGamePhase(gamePhases.rightPlayerTurn);
                            break;

                        case gamePhases.rightPlayerTurn:
                            setGamePhase(gamePhases.leftPlayerTurn);
                            break;
                    }
                };

                this.setup = (newGameMode, leftArmyNumbers, rightArmyNumbers) => {
                    gameMode = newGameMode;
                    grid.generatePlayerDice(leftArmyNumbers, rightArmyNumbers, gameMode);
                    //TODO: Who really goes first? Right or left? Methinks right. :) Roll dice to decide? I DON'T WANT TO DECIDE THIS!
                    setGamePhase(gamePhases.rightPlaceDie);
                };

                const mouseStates = {
                    idle: 'idle',
                    down: 'down',
                    dragging: 'dragging',
                };
                let mouseState = mouseStates.idle;
                let showValidMoves = false;

                this.mouseEvent = (mouseX, mouseY, eventType) => {
                    const highlightingDie = grid.highlightingDie();
                    let changePhase = false;
                    switch (eventType) {
                        case 'mousedown':
                            mouseState = mouseStates.down;
                            showValidMoves = false;
                            break;

                        case 'mouseup':
                            if (mouseState === mouseStates.down) {
                                mouseState = mouseStates.idle;
                                if (highlightingDie) {
                                    showValidMoves = true;
                                    grid.lockHighlightedDie(false, gamePhase);
                                }
                                else {
                                    changePhase = grid.attemptMoveDie();
                                    showValidMoves = false;
                                }
                                //console.log('click event'); //put into click to place mode
                            }
                            if (mouseState === mouseStates.dragging) {
                                mouseState = mouseStates.idle;
                                changePhase = grid.attemptMoveDie();
                                showValidMoves = false;
                                //console.log('end drag');
                            }
                            break;

                        case 'contextmenu':
                            //TODO: do we want to use right-clicking for anything?
                            break;

                        case 'mousemove':
                            //TODO: might want to only begin drag if mouse has been held a certain amount of time or if it travels a minimum distance.
                            if (highlightingDie && mouseState === mouseStates.down) {
                                mouseState = mouseStates.dragging;
                                showValidMoves = true;
                                grid.lockHighlightedDie(true, gamePhase);
                                //console.log('drag event begin');
                            }
                            grid.mouseMove(mouseX, mouseY, x(), y(), pxTileSize());
                            break;

                        default:
                            //TODO: lol nothing? WHO KNOWS?!?
                            console.log(eventType);
                    }
                    if (changePhase) {
                        changeGamePhase();
                    }
                };

                this.update = (dt) => {
                    grid.update(dt);
                };

                this.draw = (ctx) => {
                    const cx = x();
                    const cy = y();
                    const tileSize = pxTileSize();
                    const boardSize = tileSize * gridSize;
                    const borderThickness = tileSize / 3;
                    const p = (boardSize / 2) + borderThickness;
                    ctx.clearRect(0, 0, w, h);
                    ctx.fillStyle = themeColors.boardBorderColor;
                    ctx.fillRect(cx - p, cy - p, p * 2, p * 2);
                    grid.draw(ctx, cx, cy, tileSize, showValidMoves);
                };
            }

            function GameSetupManager (gameSetupControls, finishFunction) {
                const autoPopulateArmyOptions = {
                    largeBalanced: 'Large Balanced',
                    mediumBalanced: 'Medium Balanced',
                    smallBalanced: 'Small Balanced',
                    clearAll: 'Clear',
                };
                const doneButton = createElement('button', {}, 'Start Game!');
                doneButton.addEventListener('click', () => finishFunction());

                const gameModeSelector = createElement('div', {}, null);
                const boardSizeSelector = createElement('div', {}, null);

                const gameSetupTop = createElement('div', { 'style': `width:100%;display:flex;flex-direction:row;justify-content:space-between;align-content:stretch;align-items:stretch;` }, null);
                gameSetupControls.appendChild(gameSetupTop);

                gameSetupTop.appendChild(gameModeSelector);
                gameSetupTop.appendChild(boardSizeSelector);
                gameSetupTop.appendChild(doneButton);

                const leftPlayerSetupFieldset = makeFieldset(`${playerNames.left} Army`);
                const leftPlayerArmySizeIndicator = new ArmySizeIndicator(leftPlayerSetupFieldset);
                const leftPlayerSetup = createElement('div', {}, null);
                leftPlayerSetupFieldset.appendChild(leftPlayerSetup);

                const quickActionButtonsFieldset = makeFieldset(`Quickies`);
                const buttonListDiv = createElement('div', { 'style': `display:flex;flex-direction:column;` }, null);
                quickActionButtonsFieldset.appendChild(buttonListDiv);
                for (const opt in autoPopulateArmyOptions) {
                    const butt = createElement('input', { 'type': 'button', 'value': autoPopulateArmyOptions[opt] }, null);
                    butt.addEventListener('click', () => setArmyLoadout(autoPopulateArmyOptions[opt]));
                    buttonListDiv.appendChild(butt);
                }

                const rightPlayerSetupFieldset = makeFieldset(`${playerNames.right} Army`);
                const rightPlayerArmySizeIndicator = new ArmySizeIndicator(rightPlayerSetupFieldset);
                const rightPlayerSetup = createElement('div', {}, null);
                rightPlayerSetupFieldset.appendChild(rightPlayerSetup);

                const playerSetupContainer = createElement('div', {'style': `display:flex;flex-direction:row;justify-content:space-between;align-content:stretch;align-items:stretch;`}, null);
                playerSetupContainer.appendChild(leftPlayerSetupFieldset);
                playerSetupContainer.appendChild(quickActionButtonsFieldset);
                playerSetupContainer.appendChild(rightPlayerSetupFieldset);
                gameSetupControls.appendChild(playerSetupContainer);

                const gameModeLabel = createElement('label', { 'for': 'gameMode' }, 'Game Mode');
                const gameModeSelect = makeSelect('gameMode', gameModes);
                gameModeSelect.addEventListener('change', () => setGameMode());
                gameModeSelector.appendChild(gameModeLabel);
                gameModeSelector.appendChild(gameModeSelect);

                const boardSizeLabel = createElement('label', { 'for': 'boardSizes' }, 'Board Size');
                const boardSizeSelect = makeSelect('boardSizes', boardSizes);
                boardSizeSelect.selectedIndex = boardSizeSelect.options.length - 1;
                boardSizeSelect.addEventListener('change', () => setBoardSize());
                boardSizeSelector.appendChild(boardSizeLabel);
                boardSizeSelector.appendChild(boardSizeSelect);

                const diceSelectors = {};
                for (const id in numDiceIncluded) {
                    diceSelectors[id] = makeNumberSelect(id, 0, numDiceIncluded[id]);
                    diceSelectors[id].addEventListener('change', () => updateArmy());
                }

                let currentGameMode = '';
                let maxArmySize = 0;
                let leftArmySize = 0;
                let leftArmyCount = 0;
                let rightArmySize = 0;
                let rightArmyCount = 0;
                const leftArmy = {};
                const rightArmy = {};

                const setArmyLoadout = (quickArmyType) => {
                    switch (quickArmyType) {
                        case autoPopulateArmyOptions.largeBalanced:
                            diceSelectors['leftD4'].selectedIndex = 6;
                            diceSelectors['leftD6'].selectedIndex = 4;
                            diceSelectors['leftD12'].selectedIndex = 2;
                            diceSelectors['leftD20'].selectedIndex = 2;
                            diceSelectors['leftSpecialD12'].selectedIndex = 1;
                            diceSelectors['rightD4'].selectedIndex = 6;
                            diceSelectors['rightD6'].selectedIndex = 4;
                            diceSelectors['rightD12'].selectedIndex = 2;
                            diceSelectors['rightD20'].selectedIndex = 2;
                            diceSelectors['rightSpecialD12'].selectedIndex = 1;
                            if (gameModeSelect.selectedIndex === 1) {
                                updateArmy();
                            }
                            else {
                                gameModeSelect.selectedIndex = 1;
                                setGameMode();
                            }
                            break;

                        case autoPopulateArmyOptions.mediumBalanced:
                            diceSelectors['leftD4'].selectedIndex = 7;
                            diceSelectors['leftD6'].selectedIndex = 4;
                            diceSelectors['leftD12'].selectedIndex = 2;
                            diceSelectors['leftD20'].selectedIndex = 1;
                            diceSelectors['leftSpecialD12'].selectedIndex = 0;
                            diceSelectors['rightD4'].selectedIndex = 7;
                            diceSelectors['rightD6'].selectedIndex = 4;
                            diceSelectors['rightD12'].selectedIndex = 2;
                            diceSelectors['rightD20'].selectedIndex = 1;
                            diceSelectors['rightSpecialD12'].selectedIndex = 0;
                            if (gameModeSelect.selectedIndex === 0) {
                                updateArmy();
                            }
                            else {
                                gameModeSelect.selectedIndex = 0;
                                setGameMode();
                            }
                            break;

                        case autoPopulateArmyOptions.smallBalanced:
                            diceSelectors['leftD4'].selectedIndex = 3;
                            diceSelectors['leftD6'].selectedIndex = 3;
                            diceSelectors['leftD12'].selectedIndex = 1;
                            diceSelectors['leftD20'].selectedIndex = 1;
                            diceSelectors['leftSpecialD12'].selectedIndex = 0;
                            diceSelectors['rightD4'].selectedIndex = 3;
                            diceSelectors['rightD6'].selectedIndex = 3;
                            diceSelectors['rightD12'].selectedIndex = 1;
                            diceSelectors['rightD20'].selectedIndex = 1;
                            diceSelectors['rightSpecialD12'].selectedIndex = 0;
                            if (gameModeSelect.selectedIndex === 2) {
                                updateArmy();
                            }
                            else {
                                gameModeSelect.selectedIndex = 2;
                                setGameMode();
                            }
                            break;

                        case autoPopulateArmyOptions.clearAll:
                            for (const id in diceSelectors) {
                                diceSelectors[id].selectedIndex = 0;
                            }
                            updateArmy();
                            break;
                    }
                }

                //TODO: for testing purposes maybe include a checkbox in the UI that can override the validation?
                //Also include some pre-made army configuration buttons for quick setup?
                let validationOverride = false;
                const validate = () => validationOverride || trueValidate();
                
                //TODO: if the player somehow exceeds the dice count max, there is currently no way to give feedback in the UI.
                const diceCountValidate = () => leftArmyCount <= gameGridSize * numBaseColumns
                                    && rightArmyCount <= gameGridSize * numBaseColumns
                                    && leftArmyCount + rightArmyCount <= ((gameGridSize * gameGridSize) - (gameGridSize * numBaseColumns * 2))

                //TODO: need different minimum requirements per game mode?
                const trueValidate = () => diceCountValidate()
                                    && leftArmySize <= maxArmySize
                                    && leftArmySize > 0
                                    && rightArmySize <= maxArmySize
                                    && rightArmySize > 0;

                const populateDiceSelectors = () => {
                    for (const id in dieDescriptions) {
                        if (id.indexOf('Special') < 0 || armyIncludesSpecial[currentGameMode] === true) {
                            const label = createElement('label', { 'for': id }, dieDescriptions[id]);
                            const container = createElement('div', {}, null);
                            container.appendChild(label);
                            container.appendChild(diceSelectors[id]);
                            if (id.indexOf('left') === 0) {
                                leftPlayerSetup.appendChild(container);
                            }
                            else {
                                rightPlayerSetup.appendChild(container);
                            }
                        }
                    }
                };

                const setGameMode = () => {
                    const newGameMode = gameModeSelect.options[gameModeSelect.selectedIndex].value;
                    if (newGameMode !== currentGameMode) {
                        currentGameMode = newGameMode;
                        leftPlayerSetup.innerHTML = '';
                        rightPlayerSetup.innerHTML = '';
                        populateDiceSelectors();
                        updateArmy();
                    }
                };

                const setBoardSize = () => {
                    const newBoardSize = boardSizeSelect.options[boardSizeSelect.selectedIndex].value;
                    gameGridSize = boardDimensions[newBoardSize];
                    numBaseColumns = boardHomeColumns[newBoardSize];
                    //TODO: this is a hammer doing the job of a screwdriver
                    //might want a more elegant way to update the board...
                    startNewGame();
                };

                const updateArmy = () => {
                    maxArmySize = armySizeByGameMode[currentGameMode];
                    leftArmySize = 0;
                    leftArmyCount = 0;
                    rightArmySize = 0;
                    rightArmyCount = 0;
                    for (const id in dieValues) {
                        if (leftArmy.hasOwnProperty(id)) {
                            delete leftArmy[id];
                        }
                        if (rightArmy.hasOwnProperty(id)) {
                            delete rightArmy[id];
                        }
                        const numDice = parseInt(diceSelectors[id].options[diceSelectors[id].selectedIndex].value);
                        const value = dieValues[id] * numDice;
                        if (id.indexOf('Special') < 0 || armyIncludesSpecial[currentGameMode] === true) {
                            if (id.indexOf('left') === 0) {
                                leftArmy[id] = numDice;
                                leftArmySize += value;
                                leftArmyCount += numDice;
                            }
                            else {
                                rightArmy[id] = numDice;
                                rightArmySize += value;
                                rightArmyCount += numDice;
                            }
                        }
                    }
                    leftPlayerArmySizeIndicator.update(leftArmySize, maxArmySize);
                    rightPlayerArmySizeIndicator.update(rightArmySize, maxArmySize);

                    doneButton.disabled = !validate();
                };

                setGameMode();

                this.isValidSetup = () => validate();

                this.getLeftArmy = () => leftArmy;
                this.getRightArmy = () => rightArmy;
                this.getCurrentGameMode = () => currentGameMode;
            }

            function ArmySizeIndicator(parent) {
                const borderRadius = '5';
                const width = 256;
                const height = 32;
                const text = createElement('span', { 'style': 'color: #000000; height: 100%; margin: auto; vertical-align: middle;'}, '&nbsp;');
                const barContainer = createElement('div', { 'style': `background-color: ${themeColors.armySizeBarBackground}; border: 1px solid black; border-radius: ${borderRadius}px; width: ${width}px; height: ${height}px;` }, null);
                const bar = createElement('div', { 'style': `border-radius: ${borderRadius}px; text-align: center; background-color: #ffffff; height:100%; width:50%` }, null);
                bar.appendChild(text);
                barContainer.appendChild(bar);
                const container = createElement('div', {}, null);
                container.appendChild(barContainer);
                container.appendChild(createElement('p', {}, 'Army Size'));
                parent.appendChild(container);
                
                this.update = (value, max) => {
                    let displayText = `${value}/${max}`;
                    if (value === 0) {
                        displayText = '&nbsp;';
                    }
                    if (value > max) {
                        displayText += ' OVER!';
                        bar.style.backgroundColor = themeColors.armySizeBarBadForeground;
                    }
                    else {
                        bar.style.backgroundColor = themeColors.armySizeBarGoodForeground;
                    }
                    bar.style.width = `${Math.floor((Math.min(value, max)/max) * 100)}%`;
                    text.innerHTML = displayText;
                };
            }

            function SimpleTextOutput(parent) {
                let value = ``;
                const me = createElement('span', {}, value);
                parent.appendChild(me);

                this.updateText = (newValue) => {
                    if (newValue !== value) {
                        value = newValue;
                        me.innerHTML = value;
                    }
                };
            }

            const gameDiv = createElement('div', {'style': `width:${gameWidth}px;height:100%;padding:0px;margin:0px auto;display:flex;flex-wrap:wrap;flex-direction:column;`}, null);
            document.body.appendChild(gameDiv);

            const canvas = createElement('canvas', {'width': gameWidth, 'height': gameHeight}, null);
            //canvas.addEventListener('click', gameMouseEvent, false);
            canvas.addEventListener('mousemove', gameMouseEvent, false);
            canvas.addEventListener('mousedown', gameMouseEvent, false);
            canvas.addEventListener('mouseup', gameMouseEvent, false);
            canvas.addEventListener('contextmenu', gameMouseEvent, false);
            const ctx = canvas.getContext('2d');
            gameDiv.appendChild(canvas);

            const gameSetupControls = makeFieldset('Game Setup');
            const setupManager = new GameSetupManager(gameSetupControls, finishSetup);

            const gameOutput = makeFieldset('Game Status');

            function gameMouseEvent(evt) {
                if (game) {
                    var rect = canvas.getBoundingClientRect();
                    evt.preventDefault();
                    game.mouseEvent(evt.clientX - rect.left, evt.clientY - rect.top, evt.type);
                }
            }

            let game = null;

            let lastUpdate = null;
            function animateGame() {
                const nowUpdate = Date.now();
                const dt = nowUpdate - lastUpdate;
                lastUpdate = nowUpdate;
                game.update(dt);
                game.draw(ctx);
                requestAnimationFrame(animateGame);
            }

            //TODO: need a way to start from a stored gamestate?
            //use localstorage to store a game state that is kept up to date, that way a refreshed page doesn't ruin an in-progress game
            //this will require never storing pixel coordinates though, so need to factor out the game x,y coords and the tileSize
            //and pass those values in for every draw call, plus we'll need a way to convert mouse position into the same offset system for the tiles
            function startNewGame() {
                game = new Game(gameWidth, gameHeight, gameGridSize, numBaseColumns, gameOutput);
                //TODO: only append if gamestate is in setup?
                gameDiv.appendChild(gameSetupControls);
                lastUpdate = Date.now();
                animateGame();
            }

            function finishSetup() {
                if (setupManager.isValidSetup()) {
                    gameDiv.removeChild(gameSetupControls);
                    game.setup(setupManager.getCurrentGameMode(), setupManager.getLeftArmy(), setupManager.getRightArmy());
                    gameDiv.appendChild(gameOutput);
                }
            }

            startNewGame();
        </script>
    </body>
<html>