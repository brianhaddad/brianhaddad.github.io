<!doctype HTML>
<html>
    <head>
        <title>Pirates vs. Mermaids</title>
        <link rel="stylesheet" href="../css/mvp.css">
    </head>
    <body>
        <script src="../scripts/html_tools.js"></script>
        <script>
            //TODO: it's getting kind of long... maybe start thinking about separate files?
            /*******************
             * Alright, here's how this is going to go:
             * D4: (spy) move 3 spaces in any? (limit to diagonals?) direction and can jump over other pieces. deals its health in damage even if it dies.
             * D6: (grunt) move 2 spaces in any direction.
             * D12: (general? commander?) take up to 5 moves during a turn, can change directions while moving but cannot jump over other pieces.
             * D20: (armored unit) move 1 space forward/back/left/right. failed attacks simply mean the die does not move. only removed from the board by failing to defend.
             * 
             * Except for the D4, you can only attack a die with equal or lesser face value.
             * When attacking equal values, no matter the types of dice, both roll. higher value wins (reroll for ties) and their new face value is kept while the loser is removed from play.
             * Example: a D6 with a face value of 4 attacks a D4 with a face value of 4. They both roll. The D6 gets 3 and the D4 gets 2. The D4 is defeated
             * but the D6 keeps its new lower value of 3.
             * 
             * The game will come with one each of a special translucent, colored D12 to match the rest of the team dice.
             * This special die is the "princess" die used for capture the princess and king of the bay.
             * When used in Annihilation mode she has the following special ability:
             * Her movement can be like a normal D12 or she has the option to move as far as she wants in any straight line (think Queen in chess)
             * 
             * game modes: (come up with better names, each has a different point allotment)
             * conquer the bay: keep a piece on the center square. use special translucent D6?D12? to count down turns until victory.
             * annihilate: annihilate the opponent. princess-die is able to participate.
             *   perhaps this has the highest point allotment?
             * capture the princess: protect your translucent princess-die and if someone else captures it they have to transport it back to their base. (her point display doesn't matter)
             *   maybe this mode has smaller armies? max 45 points? 64?
             *   can the player ever move the princess in this mode? should it operate basically like chess where the princess is the "king"?
             * 
             * questions:
             * does the center square do anything special in annihilate or capture the flag modes?
             * 
             * game phases:
             * players build their army. each die has a value (D6 = 6, obviously) and there is a maxiumum value per army (to be determined)
             * also maximum of 2x the grid height number of dice per player (26 for 13x13)
             * once they have their armies selected then the colored dice are presented to the players to be placed in their home base (the two right-most or left-most columns)
             * players take turns positioning dice, and if one player has many more to position they just keep going until all are placed.
             * (simple click to select and click to place, no repositioning allowed!)
             * once all dice are placed, the game begins. not sure if it should be like chess where one side always goes first...
             * 
             * junior version:
             * 7x7 board, no D4 or D12 (just D6 and D20), one base column
             * 
             */
            //TODO: safe spots?
            const cellTypes = {
                center: 'centerCell',
                leftBase: 'leftBase',
                leftHeal: 'leftHeal',
                rightBase: 'rightBase',
                rightHeal: 'rightHeal',
            };

            const dieNames = {
                leftD4: `Pirate Spy`,
                rightD4: `Mermaid Spy`,
                leftD6: `Pirate`,
                rightD6: `Mermaid`,
                leftD12: `Pirate Captain`,
                rightD12: `Mermaid Queen`,
                leftD20: `Pirate Brute`,
                rightD20: `Mermaid Warrior`,
                leftSpecialD12: `Pirate Princess`,
                rightSpecialD12: `Mermaid Princess`,
            };

            const dieDescriptions = {
                leftD4: dieNames.leftD4 + ' (D4)',
                rightD4: dieNames.rightD4 + ' (D4)',
                leftD6: dieNames.leftD6 + ' (D6)',
                rightD6: dieNames.rightD6 + ' (D6)',
                leftD12: dieNames.leftD12 + ' (D12)',
                rightD12: dieNames.rightD12 + ' (D12)',
                leftD20: dieNames.leftD20 + ' (D20)',
                rightD20: dieNames.rightD20 + ' (D20)',
                leftSpecialD12: dieNames.leftSpecialD12 + ' (Special D12)',
                rightSpecialD12: dieNames.rightSpecialD12 + ' (Special D12)',
            };

            const numDiceIncluded = {
                leftD4: 16,
                rightD4: 16,
                leftD6: 13,
                rightD6: 13,
                leftD12: 8,
                rightD12: 8,
                leftD20: 2,
                rightD20: 2,
                leftSpecialD12: 1,
                rightSpecialD12: 1,
            };

            const dieValues = {
                leftD4: 4,
                rightD4: 4,
                leftD6: 6,
                rightD6: 6,
                leftD12: 12,
                rightD12: 12,
                leftD20: 20,
                rightD20: 20,
                leftSpecialD12: 15,
                rightSpecialD12: 15,
            };

            const dieFaces = {
                leftD4: 4,
                rightD4: 4,
                leftD6: 6,
                rightD6: 6,
                leftD12: 12,
                rightD12: 12,
                leftD20: 20,
                rightD20: 20,
                leftSpecialD12: 12,
                rightSpecialD12: 12,
            };

            function validMove(xPos, yPos, isAnAttack) {
                return {
                    x: xPos,
                    y: yPos,
                    isAttack: isAnAttack,
                };
            }

            function addMove(validMoves, newMove) {
                if (!validMoves.find(m => m.x === newMove.x && m.y === newMove.y)) {
                    validMoves.push(newMove);
                }
            }

            function evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle) {
                const enemy = enemyPositions.find(e => e.x === nx && e.y === ny);
                if (enemy && (enemy.value <= myValue || canAttackLosingBattle)) {
                    const attackMove = validMove(nx, ny, true);
                    if (!validBoardPosEvaluation(attackMove)) {
                        return false;
                    }
                    addMove(validMoves, attackMove);
                    if (!canPassToken) {
                        return false;
                    }
                }
                if (enemy && enemy.value > myValue && !canAttackLosingBattle) {
                    return canPassToken;
                }
                const friend = friendlyPositions.find(f => f.x === nx && f.y === ny);
                if (friend) {
                    return canPassToken;
                }
                const newMove = validMove(nx, ny);
                if (!validBoardPosEvaluation(newMove)) {
                    return false;
                }
                addMove(validMoves, newMove);
                return true;
            }

            function trueOmnidirectionalMovement(startPos, enemyPositions, friendlyPositions, validBoardPosEvaluation, moveDist, canPassToken, canAttackLosingBattle) {
                //TODO: recursive flood fill of some kind, ya? Keepin' track of spots already checked, ya?
                    const validMoves = [];
                    let x = startPos.x;
                    let y = startPos.y;
                    const myValue = startPos.value;
                    return validMoves;
            }

            function orthogonalMovement(startPos, enemyPositions, friendlyPositions, validBoardPosEvaluation, moveDist, canPassToken, canAttackLosingBattle) {
                const validMoves = [];
                let x = startPos.x;
                let y = startPos.y;
                const myValue = startPos.value;

                //right
                for (let ox = 1; ox <= moveDist; ox++) {
                    const nx = x + ox;
                    const ny = y;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }
                
                //left
                for (let ox = -1; ox >= -moveDist; ox--) {
                    const nx = x + ox;
                    const ny = y;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }
                
                //down
                for (let oy = 1; oy <= moveDist; oy++) {
                    const nx = x;
                    const ny = y + oy;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }
                
                //up
                for (let oy = -1; oy >= -moveDist; oy--) {
                    const nx = x;
                    const ny = y + oy;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }

                return validMoves;
            }

            function diagonalMovement(startPos, enemyPositions, friendlyPositions, validBoardPosEvaluation, moveDist, canPassToken, canAttackLosingBattle) {
                const validMoves = [];
                let x = startPos.x;
                let y = startPos.y;
                const myValue = startPos.value;

                //down/right
                for (let o = 1; o <= moveDist; o++) {
                    const nx = x + o;
                    const ny = y + o;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }

                //up/left
                for (let o = 1; o <= moveDist; o++) {
                    const nx = x - o;
                    const ny = y - o;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }

                //up/right
                for (let o = 1; o <= moveDist; o++) {
                    const nx = x + o;
                    const ny = y - o;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }

                //down/right
                for (let o = 1; o <= moveDist; o++) {
                    const nx = x - o;
                    const ny = y + o;
                    if (!evalPosition(validMoves, nx, ny, myValue, enemyPositions, friendlyPositions, validBoardPosEvaluation, canPassToken, canAttackLosingBattle)) {
                        break;
                    }
                }

                return validMoves;
            }

            function MovementEvaluator(dist, canFly, canAttackUp, movementFunction) {
                const moveDist = dist;
                const canPassToken = canFly === true;
                const canAttackLosingBattle = canAttackUp === true;
                this.getMoves = (startPos, enemyPositions, friendlyPositions, validBoardPosEvaluator) =>
                    movementFunction(startPos, enemyPositions, friendlyPositions, validBoardPosEvaluator, moveDist, canPassToken, canAttackLosingBattle);
            }

            const movementTypes = {
                orthogonal: (dist, canFly, canAttackUp) => new MovementEvaluator(dist, canFly, canAttackUp, orthogonalMovement),
                diagonal: (dist, canFly, canAttackUp) => new MovementEvaluator(dist, canFly, canAttackUp, diagonalMovement),
                trueOmnidirectional: (dist, canFly, canAttackUp) => new MovementEvaluator(dist, canFly, canAttackUp, trueOmnidirectionalMovement),
            };

            const dieMovements = {
                D4: [movementTypes.diagonal(3, true, true)],
                D6: [movementTypes.orthogonal(2), movementTypes.diagonal(2)],
                D12: [movementTypes.trueOmnidirectional(5)],
                D20: [movementTypes.orthogonal(1)],
                SpecialD12: [movementTypes.trueOmnidirectional(5), movementTypes.diagonal(99), movementTypes.orthogonal(99)],
            };

            const dieBuilders = {
                leftD4: (o) => new D(dieFaces.leftD4, o, themeColors.leftDiceColor, themeColors.leftDiceTextColor, false),
                leftD6: (o) => new D(dieFaces.leftD6, o, themeColors.leftDiceColor, themeColors.leftDiceTextColor, false),
                leftD12: (o) => new D(dieFaces.leftD12, o, themeColors.leftDiceColor, themeColors.leftDiceTextColor, false),
                leftD20: (o) => new D(dieFaces.leftD20, o, themeColors.leftDiceColor, themeColors.leftDiceTextColor, false),
                leftSpecialD12: (o) => new D(dieFaces.leftD12, o, themeColors.leftSpecialDiceColor, themeColors.leftDiceTextColor, true),
                rightD4: (o) => new D(dieFaces.rightD4, o, themeColors.rightDiceColor, themeColors.rightDiceTextColor, false),
                rightD6: (o) => new D(dieFaces.rightD6, o, themeColors.rightDiceColor, themeColors.rightDiceTextColor, false),
                rightD12: (o) => new D(dieFaces.rightD12, o, themeColors.rightDiceColor, themeColors.rightDiceTextColor, false),
                rightD20: (o) => new D(dieFaces.rightD20, o, themeColors.rightDiceColor, themeColors.rightDiceTextColor, false),
                rightSpecialD12: (o) => new D(dieFaces.rightD12, o, themeColors.rightSpecialDiceColor, themeColors.rightDiceTextColor, true),
            };

            const gameModes = {
                kingOfTheHill: 'Conquer the Bay',
                annihilation: 'Annihilation',
                captureTheFlag: 'Capture the Princess',
            };

            const armyIncludesSpecial = {
                kingOfTheHill: false,
                annihilation: true,
                captureTheFlag: false,
            };

            //TODO: these values require lots of balancing and play testing!
            const armySizeByGameMode = {
                kingOfTheHill: 96,
                annihilation: 128,
                captureTheFlag: 64,
            };

            const playerId = {
                left: 'left',
                right: 'right',
            };

            const playerNames = {
                left: `Pirate`,
                right: `Mermaid`,
            };

            const gamePhases = {
                setup: `Game Setup`,
                leftPlaceDie: `Pirate: Place Your Die`,
                rightPlaceDie: `Mermaid: Place Your Die`,
                leftPlayerTurn: `Pirate's Turn`,
                rightPlayerTurn: `Mermaid's Turn`,
                leftAttacksRight: `Pirate Attacks Mermaid!`,
                rightAttacksLeft: `Mermaid Attacks Pirate!`,
            };

            const themeColors = {
                boardBorderColor: 'rgb(0,0,0)',
                boardDefaultColor: 'rgb(18,166,236)',
                leftBaseColor: 'rgb(205,98,49)',
                leftDiceColor: 'rgb(48,16,32)',
                leftSpecialDiceColor: 'rgba(48,16,32,.5)',
                leftDiceTextColor: 'rgba(255,255,255,.7)',
                rightBaseColor: 'rgb(255,96,96)',
                rightDiceColor: 'rgb(46,155,87)',
                rightSpecialDiceColor: 'rgba(46,155,87,.5)',
                rightDiceTextColor: 'rgba(0,0,0,.85)',
                centerSquareColor: 'rgb(25,67,112)',
                centerStarColor: 'rgb(255,255,0)',
                lightenColor: 'rgba(255,255,255,.7)',
                darkenColor: 'rgba(0,0,0,.7)',
                defaultHoverHighlight: 'rgba(255,255,100,.75)',
                leftHoverHighlight: 'rgba(255,255,255,.75)',
                rightHoverHighlight: 'rgba(255,186,186,.85)',
                leftValidMoveHighlight: 'rgba(255,255,255,.65)',
                rightValidMoveHighlight: 'rgba(255,186,186,.75)',
                attackValidMoveHighlight: 'rgba(255,0,0,.75)',
                defaultDiceOutline: 'rgb(0,0,0)',
                highlightedDiceOutline: 'rgb(100,100,20)',
                armySizeBarBackground: 'rgba(0,0,0,.25)',
                armySizeBarGoodForeground: 'rgb(23,248,44)',
                armySizeBarBadForeground: 'rgb(248,23,44)',
                sparkleColor1: 'rgb(255,255,255)',
                sparkleColor2: 'rgb(255,150,255)',
                sparkleColor3: 'rgb(150,255,255)',
                sparkleColor4: 'rgb(255,255,150)',
                sparkleColor5: 'rgb(255,150,150)',
                sparkleColor6: 'rgb(150,255,150)',
                sparkleColor7: 'rgb(150,150,255)',
            };

            const gameWidth = 800;
            const gameHeight = 800;
            const gameGridSize = 13;

            function drawCenteredBoldText(ctx, text, color) {
                ctx.save();
                //TODO: allow font size to be passed in?
                ctx.font = 'bold 12px Arial';
                ctx.fillStyle = color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 0, 0);
                ctx.restore();
            }

            function drawStar(ctx, x, y, radius) {
                const innerRadius = radius * 0.382; // Inner radius for a visually pleasing star
                const outerAngle = 2 * Math.PI / 5; // Angle between outer points
                const innerAngle = Math.PI / 5; // Angle between inner and outer points

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(-Math.PI/2);

                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const outerPointX = radius * Math.cos(i * outerAngle);
                    const outerPointY = radius * Math.sin(i * outerAngle);
                    const innerPointX = innerRadius * Math.cos((i * outerAngle) + innerAngle);
                    const innerPointY = innerRadius * Math.sin((i * outerAngle) + innerAngle);

                    ctx.lineTo(outerPointX, outerPointY);
                    ctx.lineTo(innerPointX, innerPointY);
                }
                ctx.closePath();
                ctx.fill(); // Fill the star with the current fillStyle
                ctx.restore();
            }

            function fillTileSquare(ctx, x, y, tileSize) {
                ctx.fillRect(x - (tileSize/2), y - (tileSize/2), tileSize, tileSize);
            }

            function drawNgon(ctx, n, radius) {
                const outerAngle = 2 * Math.PI / n;
                let rotation = -Math.PI/2;
                if (n % 2 === 0) {
                    rotation = -Math.PI/4;
                }
                if (n > 3 && n % 3 === 0) {
                    rotation = -Math.PI/3;
                }

                ctx.save();
                ctx.rotate(rotation);

                ctx.beginPath();
                ctx.moveTo(radius, 0);
                for (let i = 0; i < n; i++) {
                    const outerPointX = radius * Math.cos(i * outerAngle);
                    const outerPointY = radius * Math.sin(i * outerAngle);

                    ctx.lineTo(outerPointX, outerPointY);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }

            function drawPlus(ctx, x, y, r) {
                ctx.save();
                const p = .3 * r;
                ctx.translate(x, y);

                ctx.beginPath();
                ctx.moveTo(-p, r);
                ctx.lineTo(p, r);
                ctx.lineTo(p, p);
                ctx.lineTo(r, p);
                ctx.lineTo(r, -p);
                ctx.lineTo(p, -p);
                ctx.lineTo(p, -r);
                ctx.lineTo(-p, -r);
                ctx.lineTo(-p, -p);
                ctx.lineTo(-r, -p);
                ctx.lineTo(-r, p);
                ctx.lineTo(-p, p);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }

            function offsetToPixelPosition(offset, cx, cy, tileSize) {
                return {
                        x: cx + (tileSize * offset.x),
                        y: cy + (tileSize * offset.y)
                    };
            }

            function SparkleEffect() {
                const sparkles = [];
                const colors = [
                    themeColors.sparkleColor1,
                    themeColors.sparkleColor2,
                    themeColors.sparkleColor3,
                    themeColors.sparkleColor4,
                    themeColors.sparkleColor5,
                    themeColors.sparkleColor6,
                    themeColors.sparkleColor7,
                ];

                const makeSparkle = () => {
                    const baseSize = 1 / 6;
                    const xOff = Math.random() - .5;
                    const yOff = Math.random() - .5;
                    const width = (Math.random() * (baseSize / 2)) + (baseSize / 2);
                    const height = (Math.random() * (baseSize / 2)) + (baseSize / 2);
                    const rotation = Math.random() * Math.PI;
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    return { x: xOff, y: yOff, w: width, h: height, r: rotation, c: color };
                };

                for (let i = 0; i < 24; i++) {
                    sparkles.push(makeSparkle());
                }

                this.draw = (ctx, r) => {
                    for (const sparkle of sparkles) {
                        ctx.save();
                        ctx.translate(sparkle.x * r, sparkle.y * r);
                        ctx.rotate(sparkle.r);
                        ctx.fillStyle = sparkle.c;
                        ctx.fillRect(-((sparkle.w * r)/2), -((sparkle.h * r)/2), sparkle.w * r, sparkle.h * r);
                        ctx.restore();
                    }
                };
            }

            function D(value, gridOffset, drawDieColor, drawTextColor, isSpecial) {
                const selectedScale = 1.25;
                const liftedScale = 1.5;
                const iAmSpecial = isSpecial === true;
                const maxValue = value;
                const name = 'D' + value;
                const getMovementType = () => isSpecial ? 'Special' + name : name;
                this.getType = () => name;
                let displayValue = 1;
                this.getFaceValue = () => displayValue;
                this.heal = () => displayValue = maxValue;
                this.dealDamage = (dmg) => displayValue -= dmg;

                let isHighlighted = false;
                this.highlight = () => isHighlighted = true;
                this.unhighlight = () => isHighlighted = false;

                let isLifted = false;
                this.lift = () => isLifted = true;
                this.setDown = () => isLifted = false;
                
                const offset = {
                    x: gridOffset.x,
                    y: gridOffset.y,
                };
                const pos = (cx, cy, tileSize) => {
                    const p = offsetToPixelPosition(offset, cx, cy, tileSize);
                    return {
                        x: p.x,
                        y: p.y,
                        r: (tileSize * 2) / 5
                    };
                };

                this.getOffset = () => {
                    return {
                        x: offset.x,
                        y: offset.y,
                        value: displayValue,
                    };
                };

                const effects = [];

                const dieColor = drawDieColor;
                const textColor = drawTextColor;

                const faces = [];
                for (let i = 0; i < value; i++) {
                    faces.push(i+1);
                }

                if (iAmSpecial && name === 'D12') {
                    effects.push(new SparkleEffect());
                }

                //TODO: ANIMATE! use a target offset variable...
                //include an animation pixelspace offset and once the animation is done then
                //the offset location is updated to the target location
                this.moveTo = (newX, newY, animateMe) => {
                    if (!animateMe) {
                        offset.x = newX;
                        offset.y = newY;
                        isLifted = false;
                    }
                    else {
                        //TODO: if animateMe is true, set up the animation (won't animate if dragging)
                        offset.x = newX;
                        offset.y = newY;
                        isLifted = false;
                    }
                };

                this.getValidMoves = (enemyPositions, friendlyPositions, validBoardPosEvaluator) => {
                    const validMoves = [];
                    for (const evaluator of dieMovements[getMovementType()]) {
                        const newMoves = evaluator
                            .getMoves(this.getOffset(), enemyPositions, friendlyPositions, validBoardPosEvaluator)
                            .filter(move => validMoves.filter(m => move.x === m.x && move.y === m.y).length === 0);
                        validMoves.push(...newMoves);
                    }
                    return validMoves;
                };

                this.roll = () => {
                    displayValue = faces[Math.floor(Math.random() * faces.length)];
                };

                this.draw = (ctx, cx, cy, tileSize, isForcedPosition, forceX, forceY) => {
                    const p = pos(cx, cy, tileSize);
                    const x = isForcedPosition === true ? forceX : p.x;
                    const y = isForcedPosition === true ? forceY : p.y;
                    const r = p.r;
                    ctx.save();
                    ctx.translate(x, y);
                    let scale = 1;
                    if (isHighlighted) {
                        scale = selectedScale;
                    }
                    if (isLifted) {
                        scale = liftedScale;
                    }
                    ctx.scale(scale, scale);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = isHighlighted ? themeColors.highlightedDiceOutline : themeColors.defaultDiceOutline;
                    ctx.fillStyle = dieColor;
                    switch (name) {
                        case 'D4':
                            drawNgon(ctx, 3, r);
                            break;

                        case 'D6':
                            drawNgon(ctx, 4, r);
                            break;

                        case 'D12':
                            if (iAmSpecial) {
                                for (const effect of effects) {
                                    effect.draw(ctx, r);
                                }
                            }
                            drawNgon(ctx, 5, r);
                            break;

                        case 'D20':
                            drawNgon(ctx, 6, r);
                            break;
                    }
                    drawCenteredBoldText(ctx, displayValue, textColor);
                    ctx.restore();
                };
            }

            function GridCell(gX, gY, gridOffset, myCellType, makeDark) {
                const col = gX;
                const row = gY;
                const offset = {
                    x: gridOffset.x,
                    y: gridOffset.y,
                };
                const dark = makeDark;
                const cellType = myCellType;

                const pos = (cx, cy, tileSize) => offsetToPixelPosition(offset, cx, cy, tileSize);

                let hoverHighlighted = false;

                const collidePoint = (px, py, cx, cy, tileSize) => {
                    const myPos = pos(cx, cy, tileSize);
                    const left = myPos.x - (tileSize/2);
                    const top = myPos.y - (tileSize/2);
                    const withinHorizontal = px > left && px < left + tileSize;
                    const withinVertical = py > top && py < top + tileSize;
                    return withinHorizontal && withinVertical;
                };

                this.isLeftHeal = () => cellType === cellTypes.leftHeal;
                this.isRightHeal = () => cellType === cellTypes.rightHeal;

                this.isSamePosition = (gridOffset) => offset.x === gridOffset.x && offset.y === gridOffset.y;
                this.getOffset = () => {
                    return {
                        x: offset.x,
                        y: offset.y,
                    };
                };

                this.checkHover = (posX, posY, cx, cy, tileSize) => {
                    hoverHighlighted = collidePoint(posX, posY, cx, cy, tileSize);
                    return hoverHighlighted ? this : null;
                };

                const fillBaseColorRect = (ctx, x, y, tileSize) => {
                    fillTileSquare(ctx, x, y, tileSize);
                    darken(ctx, x, y, tileSize);
                };

                const darken = (ctx, x, y, tileSize) => {
                    if (!dark) {
                        return;
                    }
                    ctx.save();
                    ctx.fillStyle = themeColors.darkenColor;
                    fillTileSquare(ctx, x, y, tileSize);
                    ctx.restore();
                };

                this.draw = (ctx, cx, cy, tileSize) => {
                    const myPos = pos(cx, cy, tileSize);
                    const x = myPos.x;
                    const y = myPos.y;
                    const topLayerDrawCalls = [];
                    ctx.save();

                    switch (cellType) {
                        case cellTypes.center:
                            ctx.fillStyle = themeColors.centerSquareColor;
                            fillBaseColorRect(ctx, x, y, tileSize);

                            ctx.fillStyle = themeColors.centerStarColor;
                            drawStar(ctx, x, y, (tileSize*4)/9);
                            break;

                        case cellTypes.leftBase:
                            ctx.fillStyle = themeColors.leftBaseColor;
                            fillBaseColorRect(ctx, x, y, tileSize);
                            break;

                        case cellTypes.leftHeal:
                            ctx.fillStyle = themeColors.leftBaseColor;
                            fillBaseColorRect(ctx, x, y, tileSize);
                            ctx.fillStyle = themeColors.lightenColor;
                            drawPlus(ctx, x, y, (tileSize*4)/9);
                            break;

                        case cellTypes.rightBase:
                            ctx.fillStyle = themeColors.rightBaseColor;
                            fillBaseColorRect(ctx, x, y, tileSize);
                            break;

                        case cellTypes.rightHeal:
                            ctx.fillStyle = themeColors.rightBaseColor;
                            fillBaseColorRect(ctx, x, y, tileSize);
                            ctx.fillStyle = themeColors.lightenColor;
                            drawPlus(ctx, x, y, (tileSize*4)/9);
                            break;

                        default:
                            ctx.fillStyle = themeColors.boardDefaultColor;
                            fillBaseColorRect(ctx, x, y, tileSize);
                    }
                    //TODO: keep this for effects that need to go over the main board:
                    //if (hoverHighlighted) {
                    //    topLayerDrawCalls.push((ctx) => {
                    //    });
                    //    topLayerDrawCalls.push((ctx) => {
                    //    });
                    //}
                    ctx.restore();
                    return topLayerDrawCalls;
                };

                this.drawHoverHighlight = (ctx, cx, cy, tileSize, player) => {
                    const myPos = pos(cx, cy, tileSize);
                    const x = myPos.x;
                    const y = myPos.y;
                    const w = 6;
                    const hw = w / 2;
                    ctx.save();
                    ctx.strokeStyle = themeColors.defaultHoverHighlight;
                    if (player === playerId.left) {
                        ctx.strokeStyle = themeColors.leftHoverHighlight;
                    }
                    if (player === playerId.right) {
                        ctx.strokeStyle = themeColors.rightHoverHighlight;
                    }
                    ctx.lineWidth = w;
                    ctx.beginPath();
                    ctx.roundRect(x - (tileSize/2) - hw, y - (tileSize/2) - hw, tileSize + w, tileSize + w, 8);
                    ctx.stroke();
                    ctx.restore();
                };
            }

            function Grid(numRows, numCols) {
                const rows = numRows;
                const cols = numCols;
                const cells = [];
                const hasCenter = (rows % 2 === 1) && (cols % 2 === 1);
                const healingSpotRowInset = 1;
                const playerBaseCols = 2;
                const gridPositionOffsets = [];
                const leftPlayerBaseOffsets = [];
                const leftPlayerCaptureOffsets = [];
                const rightPlayerBaseOffsets = [];
                const rightPlayerCaptureOffsets = [];
                let minOffsetX = numCols;
                let maxOffsetX = 0;
                let minOffsetY = numRows;
                let maxOffsetY = 0;

                const leftPlayerDice = [];
                const leftPlayerCapturedDice = [];
                const rightPlayerDice = [];
                const rightPlayerCapturedDice = [];
                let player = '';

                this.setPlayer = (newPlayer) => {
                    player = newPlayer;
                };

                const isHealingRow = (r) => (r == healingSpotRowInset || r == (rows - 1) - healingSpotRowInset);

                let highlightedCell = null;
                let highlightedDie = null;

                for (let r = 0; r < rows; r++) {
                    gridPositionOffsets[r] = [];
                    for (let c = 0; c < cols; c++) {
                        let cellType = '';
                        if (hasCenter && r === Math.floor(rows/2) && c === Math.floor(cols/2)) {
                            cellType = cellTypes.center;
                        }
                        if (c < playerBaseCols) {
                            cellType = cellTypes.leftBase;
                            if (c == 0 && isHealingRow(r)) {
                                cellType = cellTypes.leftHeal;
                            }
                        }
                        if (c >= cols - playerBaseCols) {
                            cellType = cellTypes.rightBase;
                            if (c == cols - 1 && isHealingRow(r)) {
                                cellType = cellTypes.rightHeal;
                            }
                        }
                        const offset = {
                            x: (c - ((cols - 1) / 2)),
                            y: (r - ((rows - 1) / 2))
                        };
                        const makeDark = (r % 2) == (c % 2);
                        cells.push(new GridCell(c, r, offset, cellType, makeDark));
                        gridPositionOffsets[r][c] = offset;
                        if (cellType === cellTypes.leftBase || cellType === cellTypes.leftHeal) {
                            leftPlayerBaseOffsets.push(offset);
                        }
                        if (cellType === cellTypes.rightBase || cellType === cellTypes.rightHeal) {
                            rightPlayerBaseOffsets.push(offset);
                        }
                        
                        //Yes, I realize this is entirely unnecessary and the values can just be calculated.
                        //Maybe I'm doing it just for show. Maybe I'm doing it out of laziness. It's not like
                        //this code runs every frame. :)
                        minOffsetX = Math.min(minOffsetX, offset.x);
                        maxOffsetX = Math.max(maxOffsetX, offset.x);
                        minOffsetY = Math.min(minOffsetY, offset.y);
                        maxOffsetY = Math.max(maxOffsetY, offset.y);
                    }
                }

                const captureOffsetStep = 1/playerBaseCols;
                const startingLeftCaptureOffset = gridPositionOffsets[0][0];
                let capturePosX = startingLeftCaptureOffset.x - 1;
                let dY = captureOffsetStep;
                let captureStartY = startingLeftCaptureOffset.y;
                for (let i = -1; i < rows * playerBaseCols; i++) {
                    leftPlayerCaptureOffsets.push({
                        x: capturePosX,
                        y: captureStartY + (i * dY)
                    });
                }

                const startingRightCaptureOffset = gridPositionOffsets[rows-1][cols-1];
                capturePosX = startingRightCaptureOffset.x + 1;
                dY = -captureOffsetStep;
                captureStartY = startingRightCaptureOffset.y;
                for (let i = -1; i < rows * playerBaseCols; i++) {
                    rightPlayerCaptureOffsets.push({
                        x: capturePosX,
                        y: captureStartY + (i * dY)
                    });
                }

                const anyLeftDiceInPos = (checkPos) => {
                    for (const die of leftPlayerDice) {
                        const diePos = die.getOffset();
                        if (checkPos.x === diePos.x && checkPos.y === diePos.y) {
                            return true;
                        }
                    }
                    return false;
                };

                const anyRightDiceInPos = (checkPos) => {
                    for (const die of rightPlayerDice) {
                        const diePos = die.getOffset();
                        if (checkPos.x === diePos.x && checkPos.y === diePos.y) {
                            return true;
                        }
                    }
                    return false;
                };

                this.allLeftDiceArePlacedInBase = () => {
                    for (const die of leftPlayerDice) {
                        const diePos = die.getOffset();
                        if (leftPlayerBaseOffsets.find(pos => pos.x === diePos.x && pos.y === diePos.y) === undefined) {
                            return false;
                        }
                    }
                    return true;
                };

                this.allRightDiceArePlacedInBase = () => {
                    for (const die of rightPlayerDice) {
                        const diePos = die.getOffset();
                        if (rightPlayerBaseOffsets.find(pos => pos.x === diePos.x && pos.y === diePos.y) === undefined) {
                            return false;
                        }
                    }
                    return true;
                };

                this.generatePlayerDice = (leftPlayerArmy, rightPlayerArmy, gameMode) => {
                    //TODO: temporary? We're going to place the armies randomly in the ocean to be placed in their bases.
                    //The trouble might be detecting when all dice have been placed within their respective base.
                    //If that becomes too difficult, might need to pivot to just showing the player one of their dice and having them
                    //click a spot in their base to put it.
                    //Going with this for now though because it will force me to write the movement code for moving the dice around. :)
                    const offsetPool = [];
                    for (let r = 0; r < rows; r++) {
                        for (let c = playerBaseCols; c < cols - playerBaseCols; c++) {
                            offsetPool.push(gridPositionOffsets[r][c]);
                        }
                    }
                    //TODO: for king of the hill the special die should be held in a separate variable and drawn off grid... maybe in the game object?
                    if (gameModes[gameMode] === gameModes.captureTheFlag) {
                        leftPlayerArmy['leftSpecialD12'] = 1;
                        rightPlayerArmy['rightSpecialD12'] = 1;
                    }
                    for (const id in leftPlayerArmy) {
                        for (let i = 0; i < leftPlayerArmy[id]; i++) {
                            const offset = offsetPool.splice(Math.floor(Math.random() * offsetPool.length), 1)[0];
                            const die = dieBuilders[id](offset);
                            die.roll();
                            leftPlayerDice.push(die);
                        }
                    }
                    
                    for (const id in rightPlayerArmy) {
                        for (let i = 0; i < rightPlayerArmy[id]; i++) {
                            const offset = offsetPool.splice(Math.floor(Math.random() * offsetPool.length), 1)[0];
                            const die = dieBuilders[id](offset);
                            die.roll();
                            rightPlayerDice.push(die);
                        }
                    }
                };

                const getHighlightedDie = (army) => {
                    for (const die of army) {
                        if (highlightedCell.isSamePosition(die.getOffset())) {
                            return die;
                        }
                    }
                    return null;
                };

                let mx = 0;
                let my = 0;

                this.mouseMove = (mouseX, mouseY, x, y, tileSize) => {
                    if (movingDieIsBeingDragged) {
                        mx = mouseX;
                        my = mouseY;
                    }
                    //TODO: cursor style manipulation/replacement?
                    let currentlyHighlighted = null;
                    for (const cell of cells) {
                        currentlyHighlighted ??= cell.checkHover(mouseX, mouseY, x, y, tileSize);
                    }
                    if (highlightedCell !== currentlyHighlighted) {
                        highlightedCell = currentlyHighlighted;
                        if (highlightedDie !== null) {
                            highlightedDie.unhighlight();
                        }
                        if (highlightedCell !== null) {
                            //mouse has entered a cell
                            //TODO: disallow highlighting a die that has been placed in the player base while in the arrangement phase?
                            if (player === playerId.left) {
                                highlightedDie = getHighlightedDie(leftPlayerDice);
                            }
                            if (player === playerId.right) {
                                highlightedDie = getHighlightedDie(rightPlayerDice);
                            }
                            if (highlightedDie !== null) {
                                highlightedDie.highlight();
                            }
                        }
                        //else {
                        //    console.log('mouse has left a cell');
                        //}
                    }
                };

                this.update = (dt) => {
                    //
                };

                const isHighlightedDie = (checkDie) => {
                    if (highlightedDie !== null || movingDie !== null) {
                        const interestedDie = movingDie === null ? highlightedDie : movingDie;
                        const highlightLoc = interestedDie.getOffset();
                        const checkLoc = checkDie.getOffset();
                        return highlightLoc.x === checkLoc.x && highlightLoc.y === checkLoc.y;
                    }
                    return false;
                };

                let validMoves = [];
                const validBoardPosEval = (pos) => 
                    pos.x >= minOffsetX
                    && pos.x <= maxOffsetX
                    && pos.y >= minOffsetY
                    && pos.y <= maxOffsetY;

                const setValidMoves = (gamePhase) => {
                    validMoves = [];
                    switch (gamePhase) {
                        case gamePhases.leftPlaceDie:
                            validMoves = leftPlayerBaseOffsets.filter(x => !anyLeftDiceInPos(x));
                            break;

                        case gamePhases.rightPlaceDie:
                            validMoves = rightPlayerBaseOffsets.filter(x => !anyRightDiceInPos(x));
                            break;
                            
                        case gamePhases.leftPlayerTurn:
                            if (movingDie !== null) {
                                validMoves = movingDie.getValidMoves(rightPlayerDice.map(d => d.getOffset()), leftPlayerDice.map(d => d.getOffset()), validBoardPosEval);
                            }
                            break;

                        case gamePhases.rightPlayerTurn:
                            if (movingDie !== null) {
                                validMoves = movingDie.getValidMoves(leftPlayerDice.map(d => d.getOffset()), rightPlayerDice.map(d => d.getOffset()), validBoardPosEval);
                            }
                            break;
                    }
                };

                const getValidMove = (gridTile) => {
                    for (const pos of validMoves) {
                        if (gridTile.isSamePosition(pos)) {
                            return pos;
                        }
                    }
                    return null;
                };

                const isValidMove = (gridTile) => {
                    for (const pos of validMoves) {
                        if (gridTile.isSamePosition(pos)) {
                            return true;
                        }
                    }
                    return false;
                };

                const indexOf = (armyDice, searchLoc) => {
                    for (let i = 0; i < armyDice.length; i++) {
                        const compareLoc = armyDice[i].getOffset();
                        if (compareLoc.x === searchLoc.x && compareLoc.y === searchLoc.y) {
                            return i;
                        }
                    }
                    return -1;
                };

                this.attemptMoveDie = () => {
                    if (movingDie === null || highlightedCell === null) {
                        return false;
                    }
                    if (!isValidMove(highlightedCell)) {
                        movingDie.setDown();
                        movingDie = null;
                        movingDieIsBeingDragged = false;
                        return false;
                    }
                    const newOffset = highlightedCell.getOffset();
                    const isAttack = getValidMove(highlightedCell).isAttack === true;
                    if (isAttack) {
                        if (player === playerId.left) {
                            const victimIndex = indexOf(rightPlayerDice, newOffset);
                            if (victimIndex > -1 && rightPlayerDice[victimIndex].getFaceValue() < movingDie.getFaceValue()) {
                                const victim = rightPlayerDice.splice(victimIndex, 1)[0];
                                const jailLocation = leftPlayerCaptureOffsets.splice(0, 1)[0];
                                victim.moveTo(jailLocation.x, jailLocation.y);
                                leftPlayerCapturedDice.push(victim);
                            }
                            else if (victimIndex > -1 && rightPlayerDice[victimIndex].getFaceValue() > movingDie.getFaceValue()) {
                                //TODO: should we trust that it should be an attack or verify that the attacker can do this?
                                //out of laziness, right now we'll trust the move data lol
                                rightPlayerDice[victimIndex].dealDamage(movingDie.getFaceValue());
                                const attackerIndex = indexOf(leftPlayerDice, movingDie.getOffset());
                                const deadAttacker = leftPlayerDice.splice(attackerIndex, 1)[0];
                                const jailLocation = rightPlayerCaptureOffsets.splice(0, 1)[0];
                                newOffset.x = jailLocation.x;
                                newOffset.y = jailLocation.y;
                                rightPlayerCapturedDice.push(deadAttacker);
                            }
                            else if (victimIndex > -1 && rightPlayerDice[victimIndex].getFaceValue() === movingDie.getFaceValue()) {
                                //TODO: add an interface and animate this maybe?
                                //roll the dice and whoever loses loses
                                while (rightPlayerDice[victimIndex].getFaceValue() === movingDie.getFaceValue()) {
                                    rightPlayerDice[victimIndex].roll()
                                    movingDie.roll()
                                    if (rightPlayerDice[victimIndex].getFaceValue() > movingDie.getFaceValue()) {
                                        //moving die loses
                                        const attackerIndex = indexOf(leftPlayerDice, movingDie.getOffset());
                                        const deadAttacker = leftPlayerDice.splice(attackerIndex, 1)[0];
                                        const jailLocation = rightPlayerCaptureOffsets.splice(0, 1)[0];
                                        newOffset.x = jailLocation.x;
                                        newOffset.y = jailLocation.y;
                                        rightPlayerCapturedDice.push(deadAttacker);
                                    }
                                    else if (rightPlayerDice[victimIndex].getFaceValue() < movingDie.getFaceValue()) {
                                        //attacked die loses
                                        const victim = rightPlayerDice.splice(victimIndex, 1)[0];
                                        const jailLocation = leftPlayerCaptureOffsets.splice(0, 1)[0];
                                        victim.moveTo(jailLocation.x, jailLocation.y);
                                        leftPlayerCapturedDice.push(victim);
                                    }
                                }
                            }
                        }
                        if (player === playerId.right) {
                            const victimIndex = indexOf(leftPlayerDice, newOffset);
                            if (victimIndex > -1 && leftPlayerDice[victimIndex].getFaceValue() < movingDie.getFaceValue()) {
                                const victim = leftPlayerDice.splice(victimIndex, 1)[0];
                                const jailLocation = rightPlayerCaptureOffsets.splice(0, 1)[0];
                                victim.moveTo(jailLocation.x, jailLocation.y);
                                rightPlayerCapturedDice.push(victim);
                            }
                            else if (victimIndex > -1 && leftPlayerDice[victimIndex].getFaceValue() > movingDie.getFaceValue()) {
                                //TODO: should we trust that it should be an attack or verify that the attacker can do this?
                                //out of laziness, right now we'll trust the move data lol
                                leftPlayerDice[victimIndex].dealDamage(movingDie.getFaceValue());
                                const attackerIndex = indexOf(rightPlayerDice, movingDie.getOffset());
                                const deadAttacker = rightPlayerDice.splice(attackerIndex, 1)[0];
                                const jailLocation = leftPlayerCaptureOffsets.splice(0, 1)[0];
                                newOffset.x = jailLocation.x;
                                newOffset.y = jailLocation.y;
                                leftPlayerCapturedDice.push(deadAttacker);
                            }
                            else if (victimIndex > -1 && leftPlayerDice[victimIndex].getFaceValue() === movingDie.getFaceValue()) {
                                //TODO: add an interface and animate this maybe?
                                //roll the dice and whoever loses loses
                                while (leftPlayerDice[victimIndex].getFaceValue() === movingDie.getFaceValue()) {
                                    leftPlayerDice[victimIndex].roll()
                                    movingDie.roll()
                                    if (leftPlayerDice[victimIndex].getFaceValue() > movingDie.getFaceValue()) {
                                        //moving die loses
                                        const attackerIndex = indexOf(rightPlayerDice, movingDie.getOffset());
                                        const deadAttacker = rightPlayerDice.splice(attackerIndex, 1)[0];
                                        const jailLocation = leftPlayerCaptureOffsets.splice(0, 1)[0];
                                        newOffset.x = jailLocation.x;
                                        newOffset.y = jailLocation.y;
                                        leftPlayerCapturedDice.push(deadAttacker);
                                    }
                                    else if (leftPlayerDice[victimIndex].getFaceValue() < movingDie.getFaceValue()) {
                                        //attacked die loses
                                        const victim = leftPlayerDice.splice(victimIndex, 1)[0];
                                        const jailLocation = rightPlayerCaptureOffsets.splice(0, 1)[0];
                                        victim.moveTo(jailLocation.x, jailLocation.y);
                                        rightPlayerCapturedDice.push(victim);
                                    }
                                }
                            }
                        }
                    }
                    movingDie.moveTo(newOffset.x, newOffset.y, !movingDieIsBeingDragged);
                    movingDie = null;
                    movingDieIsBeingDragged = false;
                    return true;
                };

                let movingDie = null;
                let movingDieIsBeingDragged = false;

                this.lockHighlightedDie = (isDragging, gamePhase) => {
                    if (!this.highlightingDie()) {
                        return;
                    }
                    if (movingDie !== null) {
                        movingDie.setDown();
                    }
                    movingDieIsBeingDragged = isDragging === true;
                    movingDie = highlightedDie;
                    movingDie.lift();
                    setValidMoves(gamePhase);
                };

                this.highlightingDie = () => highlightedDie !== null && movingDie === null;

                this.evaluateCellEffects = () => {
                    for (const cell of cells) {
                        const leftDie = leftPlayerDice.find(d => cell.isSamePosition(d.getOffset()));
                        const rightDie = rightPlayerDice.find(d => cell.isSamePosition(d.getOffset()));
                        if (leftDie && cell.isLeftHeal()) {
                            leftDie.heal();
                        }
                        if (rightDie && cell.isRightHeal()) {
                            rightDie.heal();
                        }
                    }
                };

                const drawLeftPlayer = (ctx, x, y, tileSize) => {
                    for (const captive of leftPlayerCapturedDice) {
                        captive.draw(ctx, x, y, tileSize);
                    }
                    for (const left of leftPlayerDice) {
                        if (!isHighlightedDie(left)) {
                            left.draw(ctx, x, y, tileSize);
                        }
                    }
                };

                const drawRightPlayer = (ctx, x, y, tileSize) => {
                    for (const captive of rightPlayerCapturedDice) {
                        captive.draw(ctx, x, y, tileSize);
                    }
                    for (const right of rightPlayerDice) {
                        if (!isHighlightedDie(right)) {
                            right.draw(ctx, x, y, tileSize);
                        }
                    }
                };

                this.draw = (ctx, x, y, tileSize, showValidMoves) => {
                    const topLayer = [];
                    for (const cell of cells) {
                        const newTopLayerItems = cell.draw(ctx, x, y, tileSize);
                        topLayer.push(...newTopLayerItems);
                    }
                    for (const top of topLayer) {
                        top(ctx, x, y, tileSize);
                    }
                    //TODO: should dice go under or over the top layer that comes back from the grid draw call??
                    if (showValidMoves === true) {
                        ctx.save();
                        const defaultFillStyle = (player === playerId.left)
                            ? themeColors.leftValidMoveHighlight
                            : themeColors.rightValidMoveHighlight;
                        ctx.fillStyle = defaultFillStyle;
                        for (const pos of validMoves) {
                            const isAttack = pos.hasOwnProperty('isAttack') && pos.isAttack === true;
                            if (isAttack) {
                                ctx.fillStyle = themeColors.attackValidMoveHighlight;
                            }
                            const p = offsetToPixelPosition(pos, x, y, tileSize);
                            fillTileSquare(ctx, p.x, p.y, tileSize);
                            if (isAttack) {
                                ctx.fillStyle = defaultFillStyle;
                            }
                        }
                        ctx.restore();
                    }
                    
                    if (player === playerId.left) {
                        drawRightPlayer(ctx, x, y, tileSize);
                        drawLeftPlayer(ctx, x, y, tileSize);
                    }
                    else {
                        drawLeftPlayer(ctx, x, y, tileSize);
                        drawRightPlayer(ctx, x, y, tileSize);
                    }
                    if (highlightedCell !== null && showValidMoves && isValidMove(highlightedCell)) {
                        highlightedCell.drawHoverHighlight(ctx, x, y, tileSize, player);
                    }
                    if (!movingDieIsBeingDragged && highlightedDie !== null) {
                        highlightedDie.draw(ctx, x, y, tileSize);
                    }
                    if (!movingDieIsBeingDragged && movingDie !== null) {
                        movingDie.draw(ctx, x, y, tileSize);
                    }
                    if (movingDieIsBeingDragged && movingDie !== null) {
                        movingDie.draw(ctx, 0, 0, tileSize, true, mx, my);
                    }
                };
            }

            function Game(width, height, gridDimension, gameStatusContainer) {
                let w = width;
                let h = height;
                const gridSize = gridDimension;
                const statusContainer = gameStatusContainer;
                const container = createElement('div', { 'style': `width:100%;display:flex;flex-direction:row;justify-content:space-between;flex-wrap:wrap;` }, null);
                statusContainer.appendChild(container);
                const statusOutputs = {
                    gameMode: 'Game Mode',
                    gamePhase: 'Game Phase',
                    playerTurn: 'Player Turn',
                    //TODO: have the Grid supply the army information
                    //leftPlayerStatus: `${playerNames.left} Army Status`,
                    //rightPlayerStatus: `${playerNames.right} Army Status`,
                };

                for (const outputId in statusOutputs) {
                    const fs = makeFieldset(statusOutputs[outputId]);
                    statusOutputs[outputId] = new SimpleTextOutput(fs);
                    container.appendChild(fs);
                }

                const updateStatusDisplay = () => {
                    statusOutputs.gameMode.updateText(gameModes[gameMode]);
                    statusOutputs.gamePhase.updateText(gamePhase);
                    statusOutputs.playerTurn.updateText(playerNames[currentPlayerTurn]);
                };

                const x = () => w / 2;
                const y = () => h / 2;
                const pxTileSize = () => Math.floor(Math.min(w, h) / (gridSize + 2));

                const grid = new Grid(gridSize, gridSize);

                let gameMode = '';
                let gamePhase = gamePhases.setup;
                let currentPlayerTurn = '';

                const setGamePhase = (newGamePhase) => {
                    gamePhase = newGamePhase;
                    switch (gamePhase) {
                        case gamePhases.leftPlaceDie:
                            currentPlayerTurn = playerId.left;
                            break;

                        case gamePhases.leftPlayerTurn:
                            grid.evaluateCellEffects();
                            currentPlayerTurn = playerId.left;
                            break;
                            
                        case gamePhases.rightPlaceDie:
                            currentPlayerTurn = playerId.right;
                            break;

                        case gamePhases.rightPlayerTurn:
                            grid.evaluateCellEffects();
                            currentPlayerTurn = playerId.right;
                            break;
                    }
                    grid.setPlayer(currentPlayerTurn);
                    updateStatusDisplay();
                };

                const changeGamePhase = () => {
                    const currentGamePhase = gamePhase;
                    switch (currentGamePhase) {
                        case gamePhases.leftPlaceDie:
                            if (!grid.allRightDiceArePlacedInBase()) {
                                setGamePhase(gamePhases.rightPlaceDie);
                            }
                            else if (grid.allLeftDiceArePlacedInBase()) {
                                setGamePhase(gamePhases.rightPlayerTurn); //TODO: who really goes first?
                            }
                            break;

                        case gamePhases.rightPlaceDie:
                            if (!grid.allLeftDiceArePlacedInBase()) {
                                setGamePhase(gamePhases.leftPlaceDie);
                            }
                            else if (grid.allRightDiceArePlacedInBase()) {
                                setGamePhase(gamePhases.rightPlayerTurn); //TODO: who really goes first?
                            }
                            break;

                        case gamePhases.leftPlayerTurn:
                            //TODO: based on gamemode, check for win condition
                            setGamePhase(gamePhases.rightPlayerTurn);
                            break;

                        case gamePhases.rightPlayerTurn:
                            //TODO: based on gamemode, check for win condition
                            setGamePhase(gamePhases.leftPlayerTurn);
                            break;
                    }
                };

                this.setup = (newGameMode, leftArmyNumbers, rightArmyNumbers) => {
                    gameMode = newGameMode;
                    grid.generatePlayerDice(leftArmyNumbers, rightArmyNumbers, gameMode);
                    //TODO: Who really goes first? Right or left? Methinks right. :) Roll dice to decide? I DON'T WANT TO DECIDE THIS!
                    setGamePhase(gamePhases.rightPlaceDie);
                };

                const mouseStates = {
                    idle: 'idle',
                    down: 'down',
                    dragging: 'dragging',
                };
                let mouseState = mouseStates.idle;
                let showValidMoves = false;

                this.mouseEvent = (mouseX, mouseY, eventType) => {
                    const highlightingDie = grid.highlightingDie();
                    let changePhase = false;
                    switch (eventType) {
                        case 'mousedown':
                            mouseState = mouseStates.down;
                            showValidMoves = false;
                            break;

                        case 'mouseup':
                            if (mouseState === mouseStates.down) {
                                mouseState = mouseStates.idle;
                                if (highlightingDie) {
                                    showValidMoves = true;
                                    grid.lockHighlightedDie(false, gamePhase);
                                }
                                else {
                                    changePhase = grid.attemptMoveDie();
                                    showValidMoves = false;
                                }
                                //console.log('click event'); //put into click to place mode
                            }
                            if (mouseState === mouseStates.dragging) {
                                mouseState = mouseStates.idle;
                                changePhase = grid.attemptMoveDie();
                                showValidMoves = false;
                                //console.log('end drag');
                            }
                            break;

                        case 'contextmenu':
                            //TODO: this is right clicking!
                            break;

                        case 'mousemove':
                            //TODO: might want to only begin drag if mouse has been held a certain amount of time or if it travels a minimum distance.
                            if (highlightingDie && mouseState === mouseStates.down) {
                                mouseState = mouseStates.dragging;
                                showValidMoves = true;
                                grid.lockHighlightedDie(true, gamePhase);
                                //console.log('drag event begin');
                            }
                            grid.mouseMove(mouseX, mouseY, x(), y(), pxTileSize());
                            break;

                        default:
                            //TODO: lol nothing? WHO KNOWS?!?
                            console.log(eventType);
                    }
                    if (changePhase) {
                        changeGamePhase();
                    }
                };

                this.update = (dt) => {
                    //TODO: game logic (might just be passing this up to the dice for animation purposes lol)
                    grid.update(dt);
                };

                this.draw = (ctx) => {
                    const cx = x();
                    const cy = y();
                    const tileSize = pxTileSize();
                    const boardSize = tileSize * gridSize;
                    const borderThickness = tileSize / 3;
                    const p = (boardSize / 2) + borderThickness;
                    ctx.clearRect(0, 0, w, h);
                    ctx.fillStyle = themeColors.boardBorderColor;
                    ctx.fillRect(cx - p, cy - p, p * 2, p * 2);
                    grid.draw(ctx, cx, cy, tileSize, showValidMoves);
                };
            }

            function GameSetupManager (gameSetupControls, finishFunction) {
                const autoPopulateArmyOptions = {
                    largeBalanced: 'Large Balanced',
                    mediumBalanced: 'Medium Balanced',
                    smallBalanced: 'Small Balanced',
                    clearAll: 'Clear',
                };
                const doneButton = createElement('button', {}, 'Start Game!');
                doneButton.addEventListener('click', () => finishFunction());

                const gameModeSelector = createElement('div', {}, null);

                const gameSetupTop = createElement('div', { 'style': `width:100%;display:flex;flex-direction:row;justify-content:space-between;align-content:stretch;align-items:stretch;` }, null);
                gameSetupControls.appendChild(gameSetupTop);

                gameSetupTop.appendChild(gameModeSelector);
                //TODO: a third dropdown for board size? (just for testing purposes?) junior mode?
                gameSetupTop.appendChild(doneButton);

                const leftPlayerSetupFieldset = makeFieldset(`${playerNames.left} Army`);
                const leftPlayerArmySizeIndicator = new ArmySizeIndicator(leftPlayerSetupFieldset);
                const leftPlayerSetup = createElement('div', {}, null);
                leftPlayerSetupFieldset.appendChild(leftPlayerSetup);

                const quickActionButtonsFieldset = makeFieldset(`Quickies`);
                const buttonListDiv = createElement('div', { 'style': `display:flex;flex-direction:column;` }, null);
                quickActionButtonsFieldset.appendChild(buttonListDiv);
                for (const opt in autoPopulateArmyOptions) {
                    const butt = createElement('input', { 'type': 'button', 'value': autoPopulateArmyOptions[opt] }, null);
                    butt.addEventListener('click', () => setArmyLoadout(autoPopulateArmyOptions[opt]));
                    buttonListDiv.appendChild(butt);
                }

                const rightPlayerSetupFieldset = makeFieldset(`${playerNames.right} Army`);
                const rightPlayerArmySizeIndicator = new ArmySizeIndicator(rightPlayerSetupFieldset);
                const rightPlayerSetup = createElement('div', {}, null);
                rightPlayerSetupFieldset.appendChild(rightPlayerSetup);

                const playerSetupContainer = createElement('div', {'style': `display:flex;flex-direction:row;justify-content:space-between;align-content:stretch;align-items:stretch;`}, null);
                playerSetupContainer.appendChild(leftPlayerSetupFieldset);
                playerSetupContainer.appendChild(quickActionButtonsFieldset);
                playerSetupContainer.appendChild(rightPlayerSetupFieldset);
                gameSetupControls.appendChild(playerSetupContainer);

                const gameModeLabel = createElement('label', { 'for': 'gameMode' }, 'Game Mode');
                const gameModeSelect = makeSelect('gameMode', gameModes);
                gameModeSelect.addEventListener('change', () => setGameMode());
                gameModeSelector.appendChild(gameModeLabel);
                gameModeSelector.appendChild(gameModeSelect);

                const diceSelectors = {};
                for (const id in numDiceIncluded) {
                    diceSelectors[id] = makeNumberSelect(id, 0, numDiceIncluded[id]);
                    diceSelectors[id].addEventListener('change', () => updateArmy());
                }

                let currentGameMode = '';
                let maxArmySize = 0;
                let leftArmySize = 0;
                let leftArmyCount = 0;
                let rightArmySize = 0;
                let rightArmyCount = 0;
                const leftArmy = {};
                const rightArmy = {};

                const setArmyLoadout = (quickArmyType) => {
                    switch (quickArmyType) {
                        case autoPopulateArmyOptions.largeBalanced:
                            diceSelectors['leftD4'].selectedIndex = 6;
                            diceSelectors['leftD6'].selectedIndex = 4;
                            diceSelectors['leftD12'].selectedIndex = 2;
                            diceSelectors['leftD20'].selectedIndex = 2;
                            diceSelectors['leftSpecialD12'].selectedIndex = 1;
                            diceSelectors['rightD4'].selectedIndex = 6;
                            diceSelectors['rightD6'].selectedIndex = 4;
                            diceSelectors['rightD12'].selectedIndex = 2;
                            diceSelectors['rightD20'].selectedIndex = 2;
                            diceSelectors['rightSpecialD12'].selectedIndex = 1;
                            if (gameModeSelect.selectedIndex === 1) {
                                updateArmy();
                            }
                            else {
                                gameModeSelect.selectedIndex = 1;
                                setGameMode();
                            }
                            break;

                        case autoPopulateArmyOptions.mediumBalanced:
                            diceSelectors['leftD4'].selectedIndex = 7;
                            diceSelectors['leftD6'].selectedIndex = 4;
                            diceSelectors['leftD12'].selectedIndex = 2;
                            diceSelectors['leftD20'].selectedIndex = 1;
                            diceSelectors['leftSpecialD12'].selectedIndex = 0;
                            diceSelectors['rightD4'].selectedIndex = 7;
                            diceSelectors['rightD6'].selectedIndex = 4;
                            diceSelectors['rightD12'].selectedIndex = 2;
                            diceSelectors['rightD20'].selectedIndex = 1;
                            diceSelectors['rightSpecialD12'].selectedIndex = 0;
                            if (gameModeSelect.selectedIndex === 0) {
                                updateArmy();
                            }
                            else {
                                gameModeSelect.selectedIndex = 0;
                                setGameMode();
                            }
                            break;

                        case autoPopulateArmyOptions.smallBalanced:
                            diceSelectors['leftD4'].selectedIndex = 3;
                            diceSelectors['leftD6'].selectedIndex = 3;
                            diceSelectors['leftD12'].selectedIndex = 1;
                            diceSelectors['leftD20'].selectedIndex = 1;
                            diceSelectors['leftSpecialD12'].selectedIndex = 0;
                            diceSelectors['rightD4'].selectedIndex = 3;
                            diceSelectors['rightD6'].selectedIndex = 3;
                            diceSelectors['rightD12'].selectedIndex = 1;
                            diceSelectors['rightD20'].selectedIndex = 1;
                            diceSelectors['rightSpecialD12'].selectedIndex = 0;
                            if (gameModeSelect.selectedIndex === 2) {
                                updateArmy();
                            }
                            else {
                                gameModeSelect.selectedIndex = 2;
                                setGameMode();
                            }
                            break;

                        case autoPopulateArmyOptions.clearAll:
                            for (const id in diceSelectors) {
                                diceSelectors[id].selectedIndex = 0;
                            }
                            updateArmy();
                            break;
                    }
                }

                //TODO: for testing purposes maybe include a checkbox in the UI that can override the validation?
                //Also include some pre-made army configuration buttons for quick setup?
                let validationOverride = false;
                const validate = () => validationOverride || trueValidate();
                
                //TODO: need different minimum requirements per game mode?
                //TODO: if the player somehow exceeds the dice count max, there is currently no way to give feedback in the UI.
                const trueValidate = () => leftArmySize <= maxArmySize
                                    && leftArmySize > 0
                                    && leftArmyCount <= gameGridSize * 2
                                    && rightArmySize <= maxArmySize
                                    && rightArmySize > 0
                                    && rightArmyCount <= gameGridSize * 2;

                const populateDiceSelectors = () => {
                    for (const id in dieDescriptions) {
                        if (id.indexOf('Special') < 0 || armyIncludesSpecial[currentGameMode] === true) {
                            const label = createElement('label', { 'for': id }, dieDescriptions[id]);
                            const container = createElement('div', {}, null);
                            container.appendChild(label);
                            container.appendChild(diceSelectors[id]);
                            if (id.indexOf('left') === 0) {
                                leftPlayerSetup.appendChild(container);
                            }
                            else {
                                rightPlayerSetup.appendChild(container);
                            }
                        }
                    }
                };

                const setGameMode = () => {
                    const newGameMode = gameModeSelect.options[gameModeSelect.selectedIndex].value;
                    if (newGameMode !== currentGameMode) {
                        currentGameMode = newGameMode;
                        leftPlayerSetup.innerHTML = '';
                        rightPlayerSetup.innerHTML = '';
                        populateDiceSelectors();
                        updateArmy();
                    }
                };

                const updateArmy = () => {
                    maxArmySize = armySizeByGameMode[currentGameMode];
                    leftArmySize = 0;
                    leftArmyCount = 0;
                    rightArmySize = 0;
                    rightArmyCount = 0;
                    for (const id in dieValues) {
                        if (leftArmy.hasOwnProperty(id)) {
                            delete leftArmy[id];
                        }
                        if (rightArmy.hasOwnProperty(id)) {
                            delete rightArmy[id];
                        }
                        const numDice = parseInt(diceSelectors[id].options[diceSelectors[id].selectedIndex].value);
                        const value = dieValues[id] * numDice;
                        if (id.indexOf('Special') < 0 || armyIncludesSpecial[currentGameMode] === true) {
                            if (id.indexOf('left') === 0) {
                                leftArmy[id] = numDice;
                                leftArmySize += value;
                                leftArmyCount += numDice;
                            }
                            else {
                                rightArmy[id] = numDice;
                                rightArmySize += value;
                                rightArmyCount += numDice;
                            }
                        }
                    }
                    leftPlayerArmySizeIndicator.update(leftArmySize, maxArmySize);
                    rightPlayerArmySizeIndicator.update(rightArmySize, maxArmySize);

                    doneButton.disabled = !validate();
                };

                setGameMode();

                this.isValidSetup = () => validate();

                this.getLeftArmy = () => leftArmy;
                this.getRightArmy = () => rightArmy;
                this.getCurrentGameMode = () => currentGameMode;
            }

            function ArmySizeIndicator(parent) {
                const borderRadius = '5';
                const width = 256;
                const height = 32;
                const text = createElement('span', { 'style': 'color: #000000; height: 100%; margin: auto; vertical-align: middle;'}, '&nbsp;');
                const barContainer = createElement('div', { 'style': `background-color: ${themeColors.armySizeBarBackground}; border: 1px solid black; border-radius: ${borderRadius}px; width: ${width}px; height: ${height}px;` }, null);
                const bar = createElement('div', { 'style': `border-radius: ${borderRadius}px; text-align: center; background-color: #ffffff; height:100%; width:50%` }, null);
                bar.appendChild(text);
                barContainer.appendChild(bar);
                const container = createElement('div', {}, null);
                container.appendChild(barContainer);
                container.appendChild(createElement('p', {}, 'Army Size'));
                parent.appendChild(container);
                
                this.update = (value, max) => {
                    let displayText = `${value}/${max}`;
                    if (value === 0) {
                        displayText = '&nbsp;';
                    }
                    if (value > max) {
                        displayText += ' OVER!';
                        bar.style.backgroundColor = themeColors.armySizeBarBadForeground;
                    }
                    else {
                        bar.style.backgroundColor = themeColors.armySizeBarGoodForeground;
                    }
                    bar.style.width = `${Math.floor((Math.min(value, max)/max) * 100)}%`;
                    text.innerHTML = displayText;
                };
            }

            function SimpleTextOutput(parent) {
                let value = ``;
                const me = createElement('span', {}, value);
                parent.appendChild(me);

                this.updateText = (newValue) => {
                    if (newValue !== value) {
                        value = newValue;
                        me.innerHTML = value;
                    }
                };
            }

            const gameDiv = createElement('div', {'style': `width:${gameWidth}px;height:100%;padding:0px;margin:0px auto;display:flex;flex-wrap:wrap;flex-direction:column;`}, null);
            document.body.appendChild(gameDiv);

            const canvas = createElement('canvas', {'width': gameWidth, 'height': gameHeight}, null);
            //canvas.addEventListener('click', gameMouseEvent, false);
            canvas.addEventListener('mousemove', gameMouseEvent, false);
            canvas.addEventListener('mousedown', gameMouseEvent, false);
            canvas.addEventListener('mouseup', gameMouseEvent, false);
            canvas.addEventListener('contextmenu', gameMouseEvent, false);
            const ctx = canvas.getContext('2d');
            gameDiv.appendChild(canvas);

            const gameSetupControls = makeFieldset('Game Setup');
            const setupManager = new GameSetupManager(gameSetupControls, finishSetup);

            const gameOutput = makeFieldset('Game Status');

            function gameMouseEvent(evt) {
                if (game) {
                    var rect = canvas.getBoundingClientRect();
                    evt.preventDefault();
                    game.mouseEvent(evt.clientX - rect.left, evt.clientY - rect.top, evt.type);
                }
            }

            let game = null;

            let lastUpdate = null;
            function animateGame() {
                const nowUpdate = Date.now();
                const dt = nowUpdate - lastUpdate;
                lastUpdate = nowUpdate;
                game.update(dt);
                game.draw(ctx);
                requestAnimationFrame(animateGame);
            }

            //TODO: need a way to start from a stored gamestate?
            //use localstorage to store a game state that is kept up to date, that way a refreshed page doesn't ruin an in-progress game
            //this will require never storing pixel coordinates though, so need to factor out the game x,y coords and the tileSize
            //and pass those values in for every draw call, plus we'll need a way to convert mouse position into the same offset system for the tiles
            function startNewGame() {
                game = new Game(gameWidth, gameHeight, gameGridSize, gameOutput);
                //TODO: only append if gamestate is in setup?
                gameDiv.appendChild(gameSetupControls);
                lastUpdate = Date.now();
                animateGame();
            }

            function finishSetup() {
                if (setupManager.isValidSetup()) {
                    gameDiv.removeChild(gameSetupControls);
                    game.setup(setupManager.getCurrentGameMode(), setupManager.getLeftArmy(), setupManager.getRightArmy());
                    gameDiv.appendChild(gameOutput);
                }
            }

            startNewGame();
        </script>
    </body>
<html>