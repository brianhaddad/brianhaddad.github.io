<!doctype HTML>
<html>
    <head>
        <title>Pirates vs. Mermaids</title>
        <link rel="stylesheet" href="../css/mvp.css">
    </head>
    <body>
        <script src="../scripts/html_tools.js"></script>
        <script>
            //TODO: it's getting kind of long... maybe start thinking about separate files?
            /*******************
             * Alright, here's how this is going to go:
             * D4: (spy) move 3 spaces in any direction and can jump over other pieces. deals its health in damage even if it dies.
             * D6: (grunt) move 2 spaces in any direction.
             * D12: (general? commander?) take up to 5 moves during a turn, can change directions while moving but cannot jump over other pieces.
             * D20: (armored unit) move 1 space forward/back/left/right. failed attacks simply mean the die does not move. only removed from the board by failing to defend.
             * 
             * Except for the D4, you can only attack a die with equal or lesser face value.
             * When attacking equal values, no matter the types of dice, both roll. higher value wins (reroll for ties) and their new face value is kept while the loser is removed from play.
             * Example: a D6 with a face value of 4 attacks a D4 with a face value of 4. They both roll. The D6 gets 3 and the D4 gets 2. The D4 is defeated
             * but the D6 keeps its new lower value of 3.
             * 
             * The game will come with one each of a special translucent, colored D12 to match the rest of the team dice.
             * This special die is the "princess" die used for capture the princess and king of the bay.
             * When used in Annihilation mode she has the following special ability:
             * Her movement can be like a normal D12 or she has the option to move as far as she wants in any straight line (think Queen in chess)
             * 
             * game modes: (come up with better names, each has a different point allotment)
             * conquer the bay: keep a piece on the center square. use special translucent D6?D12? to count down turns until victory.
             * annihilate: annihilate the opponent. princess-die is able to participate.
             *   perhaps this has the highest point allotment?
             * capture the princess: protect your translucent princess-die and if someone else captures it they have to transport it back to their base. (her point display doesn't matter)
             *   maybe this mode has smaller armies? max 45 points? 64?
             * 
             * questions:
             * does the center square do anything special in annihilate or capture the flag modes?
             * 
             * game phases:
             * players build their army. each die has a value (D6 = 6, obviously) and there is a maxiumum value per army (to be determined)
             * also maximum of 2x the grid height number of dice per player (26 for 13x13)
             * once they have their armies selected then the colored dice are presented to the players to be placed in their home base (the two right-most or left-most columns)
             * players take turns positioning dice, and if one player has many more to position they just keep going until all are placed.
             * (simple click to select and click to place, no repositioning allowed!)
             * once all dice are placed, the game begins. not sure if it should be like chess where one side always goes first...
             * 
             */
            //TODO: safe spots?
            const cellTypes = {
                center: 'centerCell',
                leftBase: 'leftBase',
                leftHeal: 'leftHeal',
                rightBase: 'rightBase',
                rightHeal: 'rightHeal',
            };

            const dieNames = {
                leftD4: `Pirate Spy`,
                rightD4: `Mermaid Spy`,
                leftD6: `Pirate`,
                rightD6: `Mermaid`,
                leftD12: `Pirate Captain`,
                rightD12: `Mermaid Queen`,
                leftD20: `Pirate Brute`,
                rightD20: `Mermaid Warrior`,
                leftSpecialD12: `Pirate Princess`,
                rightSpecialD12: `Mermaid Princess`,
            };

            const dieDescriptions = {
                leftD4: dieNames.leftD4 + ' (D4)',
                rightD4: dieNames.rightD4 + ' (D4)',
                leftD6: dieNames.leftD6 + ' (D6)',
                rightD6: dieNames.rightD6 + ' (D6)',
                leftD12: dieNames.leftD12 + ' (D12)',
                rightD12: dieNames.rightD12 + ' (D12)',
                leftD20: dieNames.leftD20 + ' (D20)',
                rightD20: dieNames.rightD20 + ' (D20)',
                leftSpecialD12: dieNames.leftSpecialD12 + ' (Special D12)',
                rightSpecialD12: dieNames.rightSpecialD12 + ' (Special D12)',
            };

            const numDiceIncluded = {
                leftD4: 16,
                rightD4: 16,
                leftD6: 13,
                rightD6: 13,
                leftD12: 8,
                rightD12: 8,
                leftD20: 2,
                rightD20: 2,
                leftSpecialD12: 1,
                rightSpecialD12: 1,
            };

            const dieValues = {
                leftD4: 4,
                rightD4: 4,
                leftD6: 6,
                rightD6: 6,
                leftD12: 12,
                rightD12: 12,
                leftD20: 20,
                rightD20: 20,
                leftSpecialD12: 15,
                rightSpecialD12: 15,
            };

            const dieFaces = {
                leftD4: 4,
                rightD4: 4,
                leftD6: 6,
                rightD6: 6,
                leftD12: 12,
                rightD12: 12,
                leftD20: 20,
                rightD20: 20,
                leftSpecialD12: 12,
                rightSpecialD12: 12,
            };

            const dieSize = (tileSize) => (tileSize * 2) / 5;
            const dieX = (x, tileSize, offset) => x + (offset.x * tileSize);
            const dieY = (y, tileSize, offset) => y + (offset.y * tileSize);

            const dieBuilders = {
                leftD4: (x, y, o, t) => new D(dieFaces.leftD4, dieX(x, t, o), dieY(y, t, o), dieSize(t), themeColors.leftDiceColor, themeColors.leftDiceTextColor),
                leftD6: (x, y, o, t) => new D(dieFaces.leftD6, dieX(x, t, o), dieY(y, t, o), dieSize(t), themeColors.leftDiceColor, themeColors.leftDiceTextColor),
                leftD12: (x, y, o, t) => new D(dieFaces.leftD12, dieX(x, t, o), dieY(y, t, o), dieSize(t), themeColors.leftDiceColor, themeColors.leftDiceTextColor),
                leftD20: (x, y, o, t) => new D(dieFaces.leftD20, dieX(x, t, o), dieY(y, t, o), dieSize(t), themeColors.leftDiceColor, themeColors.leftDiceTextColor),
                leftSpecialD12: (x, y, o, t) => new D(dieFaces.leftD12, dieX(x, t, o), dieY(y, t, o), dieSize(t), themeColors.leftSpecialDiceColor, themeColors.leftDiceTextColor, true),
                rightD4: (x, y, o, t) => new D(dieFaces.rightD4, dieX(x, t, o), dieY(y, t, o), dieSize(t), themeColors.rightDiceColor, themeColors.rightDiceTextColor),
                rightD6: (x, y, o, t) => new D(dieFaces.rightD6, dieX(x, t, o), dieY(y, t, o), dieSize(t), themeColors.rightDiceColor, themeColors.rightDiceTextColor),
                rightD12: (x, y, o, t) => new D(dieFaces.rightD12, dieX(x, t, o), dieY(y, t, o), dieSize(t), themeColors.rightDiceColor, themeColors.rightDiceTextColor),
                rightD20: (x, y, o, t) => new D(dieFaces.rightD20, dieX(x, t, o), dieY(y, t, o), dieSize(t), themeColors.rightDiceColor, themeColors.rightDiceTextColor),
                rightSpecialD12: (x, y, o, t) => new D(dieFaces.rightD12, dieX(x, t, o), dieY(y, t, o), dieSize(t), themeColors.rightSpecialDiceColor, themeColors.rightDiceTextColor, true),
            };

            const gameModes = {
                kingOfTheHill: 'Conquer the Bay',
                annihilation: 'Annihilation',
                captureTheFlag: 'Capture the Princess',
            };

            const armyIncludesSpecial = {
                kingOfTheHill: false,
                annihilation: true,
                captureTheFlag: false,
            };

            //TODO: these values require lots of balancing and play testing!
            const armySizeByGameMode = {
                kingOfTheHill: 96,
                annihilation: 128,
                captureTheFlag: 64,
            };

            const playerNames = {
                leftPlayer: `Pirate`,
                rightPlayer: `Mermaid`,
            };

            const gamePhases = {
                setup: `Game Setup`,
                leftPlaceDie: `Pirate: Place Your Die`,
                rightPlaceDie: `Mermaid: Place Your Die`,
                leftPlayerTurn: `Pirate's Turn`,
                rightPlayerTurn: `Mermaid's Turn`,
                leftAttacksRight: `Pirate Attacks Mermaid!`,
                rightAttacksLeft: `Mermaid Attacks Pirate!`,
            };

            const themeColors = {
                boardDefaultColor: 'rgb(18,166,236)',
                leftBaseColor: 'rgb(205,98,49)',
                leftDiceColor: 'rgb(48,16,32)',
                leftSpecialDiceColor: 'rgba(48,16,32,.5)',
                leftDiceTextColor: 'rgba(255,255,255,.7)',
                rightBaseColor: 'rgb(255,96,96)',
                rightDiceColor: 'rgb(46,155,87)',
                rightSpecialDiceColor: 'rgba(46,155,87,.5)',
                rightDiceTextColor: 'rgba(0,0,0,.85)',
                centerSquareColor: 'rgb(0,0,0)',
                centerStarColor: 'rgb(255,255,0)',
                lightenColor: 'rgba(255,255,255,.7)',
                darkenColor: 'rgba(0,0,0,.7)',
                defaultHoverHighlight: 'rgba(255,255,100,.75)',
                defaultDiceOutline: 'rgb(0,0,0)',
                tableBackgroundColor: 'rgb(44,178,66)',
                armySizeBarBackground: 'rgba(0,0,0,.25)',
                armySizeBarGoodForeground: 'rgb(23,248,44)',
                armySizeBarBadForeground: 'rgb(248,23,44)',
                sparkleColor1: 'rgb(255,255,255)',
                sparkleColor2: 'rgb(255,150,255)',
                sparkleColor3: 'rgb(150,255,255)',
                sparkleColor4: 'rgb(255,255,150)',
                sparkleColor5: 'rgb(255,150,150)',
                sparkleColor6: 'rgb(150,255,150)',
                sparkleColor7: 'rgb(150,150,255)',
            };

            const gameWidth = 800;
            const gameHeight = 600;
            const gameGridSize = 13;

            function drawCenteredBoldText(ctx, text, x, y, color) {
                ctx.save();
                ctx.translate(x, y);
                //TODO: allow font size to be passed in?
                ctx.font = 'bold 12px Arial';
                ctx.fillStyle = color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 0, 0);
                ctx.restore();
            }

            function drawStar(ctx, x, y, radius) {
                const innerRadius = radius * 0.382; // Inner radius for a visually pleasing star
                const outerAngle = 2 * Math.PI / 5; // Angle between outer points
                const innerAngle = Math.PI / 5; // Angle between inner and outer points

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(-Math.PI/2);

                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const outerPointX = radius * Math.cos(i * outerAngle);
                    const outerPointY = radius * Math.sin(i * outerAngle);
                    const innerPointX = innerRadius * Math.cos((i * outerAngle) + innerAngle);
                    const innerPointY = innerRadius * Math.sin((i * outerAngle) + innerAngle);

                    ctx.lineTo(outerPointX, outerPointY);
                    ctx.lineTo(innerPointX, innerPointY);
                }
                ctx.closePath();
                ctx.fill(); // Fill the star with the current fillStyle
                ctx.restore();
            }

            function drawNgon(ctx, x, y, n, radius) {
                //TODO: option to include an outline?
                const outerAngle = 2 * Math.PI / n;
                let rotation = -Math.PI/2;
                if (n % 2 === 0) {
                    rotation = -Math.PI/4;
                }
                if (n > 3 && n % 3 === 0) {
                    rotation = -Math.PI/3;
                }

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);

                ctx.beginPath();
                ctx.moveTo(radius, 0);
                for (let i = 0; i < n; i++) {
                    const outerPointX = radius * Math.cos(i * outerAngle);
                    const outerPointY = radius * Math.sin(i * outerAngle);

                    ctx.lineTo(outerPointX, outerPointY);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }

            function drawPlus(ctx, x, y, r) {
                ctx.save();
                const p = .3 * r;
                ctx.translate(x, y);

                ctx.beginPath();
                ctx.moveTo(-p, r);
                ctx.lineTo(p, r);
                ctx.lineTo(p, p);
                ctx.lineTo(r, p);
                ctx.lineTo(r, -p);
                ctx.lineTo(p, -p);
                ctx.lineTo(p, -r);
                ctx.lineTo(-p, -r);
                ctx.lineTo(-p, -p);
                ctx.lineTo(-r, -p);
                ctx.lineTo(-r, p);
                ctx.lineTo(-p, p);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }

            function SparkleEffect(r) {
                const sparkles = [];
                const radius = r;
                const colors = [
                    themeColors.sparkleColor1,
                    themeColors.sparkleColor2,
                    themeColors.sparkleColor3,
                    themeColors.sparkleColor4,
                    themeColors.sparkleColor5,
                    themeColors.sparkleColor6,
                    themeColors.sparkleColor7,
                ];

                const getSparkle = () => {
                    const baseSize = radius / 3;
                    const xOff = Math.floor(Math.random() * 2 * radius) - radius;
                    const yOff = Math.floor(Math.random() * 2 * radius) - radius;
                    const width = (Math.random() * (baseSize / 2)) + (baseSize / 2);
                    const height = (Math.random() * (baseSize / 2)) + (baseSize / 2);
                    const rotation = Math.random() * Math.PI;
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    return { x: xOff, y: yOff, w: width, h: height, r: rotation, c: color };
                };

                for (let i = 0; i < 10; i++) {
                    sparkles.push(getSparkle());
                }

                this.draw = (ctx, x, y) => {
                    for (const sparkle of sparkles) {
                        ctx.save();
                        ctx.translate(x + sparkle.x, y + sparkle.y);
                        ctx.rotate(sparkle.r);
                        ctx.fillStyle = sparkle.c;
                        ctx.fillRect(-(sparkle.w/2), -(sparkle.h/2), sparkle.w, sparkle.h);
                        ctx.restore();
                    }
                };
            }

            function D(value, posX, posY, drawRadius, drawDieColor, drawTextColor, isSpecial) {
                //TODO: maybe stroke is determined by hover/highlight?
                //Draw a little bigger on highlight and while moving to a new position?
                const iAmSpecial = isSpecial === true;
                const name = 'D' + value; 
                this.getType = () => name;
                let displayValue = 1;
                this.getFaceValue = () => displayValue;

                const effects = [];

                const x = Math.floor(posX);
                const y = Math.floor(posY);
                const r = Math.floor(drawRadius);

                const dieColor = drawDieColor;
                const textColor = drawTextColor;

                const faces = [];
                for (let i = 0; i < value; i++) {
                    faces.push(i+1);
                }

                if (iAmSpecial && name === 'D12') {
                    effects.push(new SparkleEffect(r / 2));
                }

                //TODO: methods for moving, including animating a move to a new location

                this.roll = () => {
                    displayValue = faces[Math.floor(Math.random() * faces.length)];
                };

                this.draw = (ctx) => {
                    ctx.save();
                    ctx.fillStyle = dieColor;
                    switch (name) {
                        case 'D4':
                            drawNgon(ctx, x, y, 3, r);
                            break;

                        case 'D6':
                            drawNgon(ctx, x, y, 4, r);
                            break;

                        case 'D12':
                            if (iAmSpecial) {
                                for (const effect of effects) {
                                    effect.draw(ctx, x, y);
                                }
                            }
                            drawNgon(ctx, x, y, 5, r);
                            break;

                        case 'D20':
                            drawNgon(ctx, x, y, 6, r);
                            break;
                    }
                    drawCenteredBoldText(ctx, displayValue, x, y, textColor);
                    ctx.restore();
                }
            }

            function GridCell(gX, gY, posX, posY, pxTileSize, cellType, makeDark) {
                const col = gX;
                const row = gY;
                const x = Math.floor(posX);
                const y = Math.floor(posY);
                const tileSize = pxTileSize;
                const dark = makeDark;

                let hoverHighlighted = false;

                const collidePoint = (px, py) => {
                    const left = x - (tileSize/2);
                    const top = y - (tileSize/2);
                    const withinHorizontal = px > left && px < left + tileSize;
                    const withinVertical = py > top && py < top + tileSize;
                    return withinHorizontal && withinVertical;
                };

                this.checkHover = (posX, posY) => {
                    hoverHighlighted = collidePoint(posX, posY);
                    return hoverHighlighted ? this : null;
                };

                const fillBaseColorRect = (ctx) => {
                    fillTileSquare(ctx);
                    darken(ctx);
                };

                const fillTileSquare = (ctx) => {
                    ctx.fillRect(x - (tileSize/2), y - (tileSize/2), tileSize, tileSize);
                };

                const darken = (ctx) => {
                    if (!dark) {
                        return;
                    }
                    ctx.save();
                    ctx.fillStyle = themeColors.darkenColor;
                    fillTileSquare(ctx);
                    ctx.restore();
                };

                this.draw = (ctx) => {
                    //TODO: maybe cell types that get drawn differently?
                    const topLayerDrawCalls = [];
                    ctx.save();

                    switch (cellType) {
                        case cellTypes.center:
                            ctx.fillStyle = themeColors.centerSquareColor;
                            fillBaseColorRect(ctx);

                            ctx.fillStyle = themeColors.centerStarColor;
                            drawStar(ctx, x, y, (tileSize*4)/9);
                            break;

                        case cellTypes.leftBase:
                            ctx.fillStyle = themeColors.leftBaseColor;
                            fillBaseColorRect(ctx);
                            break;

                        case cellTypes.leftHeal:
                            ctx.fillStyle = themeColors.leftBaseColor;
                            fillBaseColorRect(ctx);
                            ctx.fillStyle = themeColors.lightenColor;
                            drawPlus(ctx, x, y, (tileSize*4)/9);
                            break;

                        case cellTypes.rightBase:
                            ctx.fillStyle = themeColors.rightBaseColor;
                            fillBaseColorRect(ctx);
                            break;

                        case cellTypes.rightHeal:
                            ctx.fillStyle = themeColors.rightBaseColor;
                            fillBaseColorRect(ctx);
                            ctx.fillStyle = themeColors.lightenColor;
                            drawPlus(ctx, x, y, (tileSize*4)/9);
                            break;

                        default:
                            ctx.fillStyle = themeColors.boardDefaultColor;
                            fillBaseColorRect(ctx);
                    }
                    //TODO: keep this for effects that need to go over the main board:
                    //if (hoverHighlighted) {
                    //    topLayerDrawCalls.push((ctx) => {
                    //    });
                    //    topLayerDrawCalls.push((ctx) => {
                    //    });
                    //}
                    ctx.restore();
                    return topLayerDrawCalls;
                };

                this.drawHoverHighlight = (ctx) => {
                    //TODO: draw a different color depending on the player?
                    const w = 6;
                    const hw = w / 2;
                    ctx.save();
                    ctx.strokeStyle = themeColors.defaultHoverHighlight;
                    ctx.lineWidth = w;
                    ctx.beginPath();
                    ctx.roundRect(x - (tileSize/2) - hw, y - (tileSize/2) - hw, tileSize + w, tileSize + w, 8);
                    ctx.stroke();
                    ctx.restore();
                    //TODO: optional?
                    //drawCenteredBoldText(ctx, `${col}, ${row}`, x, y);
                };
            }

            function Grid(posX, posY, numRows, numCols, pxTileSize) {
                //TODO: need a way to resize/scale the tileSize?
                const x = Math.floor(posX);
                const y = Math.floor(posY);
                const rows = numRows;
                const cols = numCols;
                const tileSize = pxTileSize;
                const cells = [];
                const hasCenter = (rows % 2 === 1) && (cols % 2 === 1);
                const healingSpotRowInset = 1;
                const gridPositionOffsets = [];

                const leftPlayerDice = [];
                const rightPlayerDice = [];

                const isHealingRow = (r) => (r == healingSpotRowInset || r == (rows - 1) - healingSpotRowInset);

                let highlightedCell = null;

                //TODO: need to allow reflow of the layout for resizing?
                for (let r = 0; r < rows; r++) {
                    gridPositionOffsets[r] = [];
                    for (let c = 0; c < cols; c++) {
                        let cellType = '';
                        if (hasCenter && r === Math.floor(rows/2) && c === Math.floor(cols/2)) {
                            cellType = cellTypes.center;
                        }
                        if (c < 2) {
                            cellType = cellTypes.leftBase;
                            if (c == 0 && isHealingRow(r)) {
                                cellType = cellTypes.leftHeal;
                            }
                        }
                        if (c >= cols - 2) {
                            cellType = cellTypes.rightBase;
                            if (c == cols - 1 && isHealingRow(r)) {
                                cellType = cellTypes.rightHeal;
                            }
                        }
                        const offset = {
                            x: (c - ((cols - 1) / 2)),
                            y: (r - ((rows - 1) / 2))
                        };
                        const posX = x + (tileSize * offset.x);
                        const posY = y + (tileSize * offset.y);
                        const makeDark = (r % 2) == (c % 2);
                        cells.push(new GridCell(c, r, posX, posY, tileSize, cellType, makeDark));
                        gridPositionOffsets[r][c] = offset; //TODO: might move to using this for more things
                    }
                }

                this.generatePlayerDice = (leftPlayerArmy, rightPlayerArmy) => {
                    //TODO: remove r/c
                    //TODO: place them out of bounds or in some kind of holding position off grid (generate new offsets?)
                    //even better, place them randomly in the ocean? :P
                    //TODO: need to detect and highligh mouseover for dice!
                    //TODO: for capture the flag game mode we still need to add the special die!
                    //TODO: for king of the hill the special die should be held in a separate variable and drawn off grid... maybe in the game object?
                    let r = 0;
                    let c = 0;
                    for (const id in leftPlayerArmy) {
                        for (let i = 0; i < leftPlayerArmy[id]; i++) {
                            //TODO: offset needs to be handled differently at first
                            const offset = gridPositionOffsets[r][c];
                            const die = dieBuilders[id](x, y, offset, tileSize);
                            die.roll();
                            leftPlayerDice.push(die);
                            //TODO: temporary code
                            c++;
                            if (c >= cols) {
                                c = 0;
                                r++;
                                if (r >= rows) {
                                    r = 0;
                                    //TODO: also we're in trouble
                                }
                            }
                        }
                    }
                    
                    for (const id in rightPlayerArmy) {
                        for (let i = 0; i < rightPlayerArmy[id]; i++) {
                            //TODO: offset needs to be handled differently at first
                            const offset = gridPositionOffsets[r][c];
                            const die = dieBuilders[id](x, y, offset, tileSize);
                            die.roll();
                            rightPlayerDice.push(die);
                            //TODO: temporary code
                            c++;
                            if (c >= cols) {
                                c = 0;
                                r++;
                                if (r >= rows) {
                                    r = 0;
                                    //TODO: also we're in trouble
                                }
                            }
                        }
                    }
                };

                this.mouseMove = (mouseX, mouseY) => {
                    //TODO: temp? Just a proof of concept placeholder...
                    let currentlyHighlighted = null;
                    for (const cell of cells) {
                        currentlyHighlighted ??= cell.checkHover(mouseX, mouseY);
                    }
                    if (highlightedCell !== currentlyHighlighted) {
                        highlightedCell = currentlyHighlighted;
                        //TODO: events for mouse entering/leaving cells?
                        //if (highlightedCell !== null) {
                        //    console.log('entered a new cell');
                        //}
                        //else {
                        //    console.log('left a cell');
                        //}
                    }
                };

                this.update = (dt) => {
                    //
                };

                this.draw = (ctx) => {
                    //TODO: Grid needs different layers beyond the tiles/cells.
                    const topLayer = [];
                    for (const cell of cells) {
                        const newTopLayerItems = cell.draw(ctx);
                        topLayer.push(...newTopLayerItems);
                    }
                    for (const top of topLayer) {
                        top(ctx);
                    }
                    //TODO: should dice go under or over the top layer that comes back from the grid draw call??
                    //TODO: also, draw whoever's turn it is first! maybe put these calls in their own functions.
                    
                    //TODO: move the styles into the dice themselves to allow for the special translucent "princess" die for each team.
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = themeColors.defaultDiceOutline;
                    for (const red of leftPlayerDice) {
                        red.draw(ctx);
                    }
                    for (const blue of rightPlayerDice) {
                        blue.draw(ctx);
                    }
                    //TODO: need a way to only draw highlighting when an action can be taken
                    //eventually valid moves should highlight while invalid moves should not
                    //also before selecting a piece to move, empty tiles and tiles with enemy pieces should not highlight
                    if (highlightedCell) {
                        highlightedCell.drawHoverHighlight(ctx);
                    }
                };
            }

            function Game(width, height, gridDimension) {
                const w = width;
                const h = height;
                const x = w / 2;
                const y = h / 2;

                const gridSize = gridDimension;
                const grid = new Grid(x, y, gridSize, gridSize, Math.floor(Math.min(w, h) / (gridSize + 2)));

                let gameMode = '';
                let gamePhase = gamePhases.setup;

                this.setup = (newGameMode, leftArmyNumbers, rightArmyNumbers) => {
                    gameMode = newGameMode;
                    grid.generatePlayerDice(leftArmyNumbers, rightArmyNumbers);
                    //TODO: need to implement phase logic! Also, who goes first? Right or left? Methinks right. :)
                    gamePhase = gamePhases.rightPlaceDie;
                };

                this.mouseEvent = (mouseX, mouseY, eventType) => {
                    switch (eventType) {
                        case 'click':
                            //TODO: left click
                            //If something was already highlighted (identified as the item the mouse is over)
                            //maybe just have that item activate after confirming that the new coordinate is still
                            //inside?
                            break;

                        case 'contextmenu':
                            //TODO: this is right clicking!
                            break;

                        case 'mousemove':
                            //TODO: pass the mouse position around looking for something to highlight?
                            grid.mouseMove(mouseX, mouseY);
                            break;

                        default:
                            //TODO: lol nothing? WHO KNOWS?!?
                            console.log(eventType);
                    }
                };

                this.update = (dt) => {
                    //TODO: game logic
                    grid.update(dt);
                };

                this.draw = (ctx) => {
                    ctx.clearRect(0, 0, w, h);
                    //TODO: trace a border around the board?
                    //ctx.fillStyle = themeColors.tableBackgroundColor;
                    //ctx.fillRect(0, 0, w, h);
                    grid.draw(ctx);
                };
            }

            function GameSetupManager (gameSetupControls, finishFunction) {
                const doneButton = createElement('button', {}, 'Start Game!');
                doneButton.addEventListener('click', () => finishFunction());

                const gameModeSelector = createElement('div', {}, null);

                const gameSetupTop = createElement('div', { 'style': `width:100%;display:flex;flex-direction:row;justify-content:space-between;align-content:stretch;align-items:stretch;` }, null);
                gameSetupControls.appendChild(gameSetupTop);

                gameSetupTop.appendChild(gameModeSelector);
                //TODO: a third dropdown for board size? (just for testing purposes?)
                gameSetupTop.appendChild(doneButton);

                const leftPlayerSetupFieldset = makeFieldset(`${playerNames.leftPlayer} Army`);
                const leftPlayerArmySizeIndicator = new ArmySizeIndicator(leftPlayerSetupFieldset);
                const leftPlayerSetup = createElement('div', {}, null);
                leftPlayerSetupFieldset.appendChild(leftPlayerSetup);

                const rightPlayerSetupFieldset = makeFieldset(`${playerNames.rightPlayer} Army`);
                const rightPlayerArmySizeIndicator = new ArmySizeIndicator(rightPlayerSetupFieldset);
                const rightPlayerSetup = createElement('div', {}, null);
                rightPlayerSetupFieldset.appendChild(rightPlayerSetup);

                const playerSetupContainer = createElement('div', {'style': `display:flex;flex-direction:row;justify-content:space-between;align-content:stretch;align-items:stretch;`}, null);
                playerSetupContainer.appendChild(leftPlayerSetupFieldset);
                playerSetupContainer.appendChild(rightPlayerSetupFieldset);
                gameSetupControls.appendChild(playerSetupContainer);

                const gameModeLabel = createElement('label', { 'for': 'gameMode' }, 'Game Mode');
                const gameModeSelect = makeSelect('gameMode', gameModes);
                gameModeSelect.addEventListener('change', () => setGameMode());
                gameModeSelector.appendChild(gameModeLabel);
                gameModeSelector.appendChild(gameModeSelect);

                const diceSelectors = {};
                for (const id in numDiceIncluded) {
                    diceSelectors[id] = makeNumberSelect(id, 0, numDiceIncluded[id]);
                    diceSelectors[id].addEventListener('change', () => updateArmy());
                }

                let currentGameMode = '';
                let maxArmySize = 0;
                let leftArmySize = 0;
                let leftArmyCount = 0;
                let rightArmySize = 0;
                let rightArmyCount = 0;
                const leftArmy = {};
                const rightArmy = {};

                //TODO: need different minimum requirements per game mode?
                //TODO: if the player somehow exceeds the dice count max, there is currently no way to give feedback in the UI.
                const validate = () => leftArmySize <= maxArmySize
                                    && leftArmySize > 0
                                    && leftArmyCount <= gameGridSize * 2
                                    && rightArmySize <= maxArmySize
                                    && rightArmySize > 0
                                    && rightArmyCount <= gameGridSize * 2;

                const populateDiceSelectors = () => {
                    for (const id in dieDescriptions) {
                        if (id.indexOf('Special') < 0 || armyIncludesSpecial[currentGameMode] === true) {
                            const label = createElement('label', { 'for': id }, dieDescriptions[id]);
                            const container = createElement('div', {}, null);
                            container.appendChild(label);
                            container.appendChild(diceSelectors[id]);
                            if (id.indexOf('left') === 0) {
                                leftPlayerSetup.appendChild(container);
                            }
                            else {
                                rightPlayerSetup.appendChild(container);
                            }
                        }
                    }
                };

                const setGameMode = () => {
                    const newGameMode = gameModeSelect.options[gameModeSelect.selectedIndex].value;
                    if (newGameMode !== currentGameMode) {
                        currentGameMode = newGameMode;
                        leftPlayerSetup.innerHTML = '';
                        rightPlayerSetup.innerHTML = '';
                        populateDiceSelectors();
                        updateArmy();
                    }
                };

                const updateArmy = () => {
                    maxArmySize = armySizeByGameMode[currentGameMode];
                    leftArmySize = 0;
                    leftArmyCount = 0;
                    rightArmySize = 0;
                    rightArmyCount = 0;
                    for (const id in dieValues) {
                        if (leftArmy.hasOwnProperty(id)) {
                            delete leftArmy[id];
                        }
                        if (rightArmy.hasOwnProperty(id)) {
                            delete rightArmy[id];
                        }
                        const numDice = parseInt(diceSelectors[id].options[diceSelectors[id].selectedIndex].value);
                        const value = dieValues[id] * numDice;
                        if (id.indexOf('Special') < 0 || armyIncludesSpecial[currentGameMode] === true) {
                            if (id.indexOf('left') === 0) {
                                leftArmy[id] = numDice;
                                leftArmySize += value;
                                leftArmyCount += numDice;
                            }
                            else {
                                rightArmy[id] = numDice;
                                rightArmySize += value;
                                rightArmyCount += numDice;
                            }
                        }
                    }
                    leftPlayerArmySizeIndicator.update(leftArmySize, maxArmySize);
                    rightPlayerArmySizeIndicator.update(rightArmySize, maxArmySize);

                    doneButton.disabled = !validate();
                };

                setGameMode();

                this.isValidSetup = () => validate();

                this.getLeftArmy = () => leftArmy;
                this.getRightArmy = () => rightArmy;
                this.getCurrentGameMode = () => currentGameMode;
            }

            function ArmySizeIndicator(parent) {
                const borderRadius = '5';
                const width = 256;
                const height = 32;
                const text = createElement('span', { 'style': 'color: #000000; height: 100%; margin: auto; vertical-align: middle;'}, '&nbsp;');
                const barContainer = createElement('div', { 'style': `background-color: ${themeColors.armySizeBarBackground}; border: 1px solid black; border-radius: ${borderRadius}px; width: ${width}px; height: ${height}px;` }, null);
                const bar = createElement('div', { 'style': `border-radius: ${borderRadius}px; text-align: center; background-color: #ffffff; height:100%; width:50%` }, null);
                bar.appendChild(text);
                barContainer.appendChild(bar);
                const container = createElement('div', {}, null);
                container.appendChild(barContainer);
                container.appendChild(createElement('p', {}, 'Army Size'));
                parent.appendChild(container);
                
                this.update = (value, max) => {
                    let displayText = `${value}/${max}`;
                    if (value === 0) {
                        displayText = '&nbsp;';
                    }
                    if (value > max) {
                        displayText += ' OVER!';
                        bar.style.backgroundColor = themeColors.armySizeBarBadForeground;
                    }
                    else {
                        bar.style.backgroundColor = themeColors.armySizeBarGoodForeground;
                    }
                    bar.style.width = `${Math.floor((Math.min(value, max)/max) * 100)}%`;
                    text.innerHTML = displayText;
                };
            }

            const gameDiv = createElement('div', {'style': `width:${gameWidth}px;height:100%;padding:0px;margin:0px auto;display:flex;flex-wrap:wrap;flex-direction:column;`}, null);
            document.body.appendChild(gameDiv);

            const canvas = createElement('canvas', {'width': gameWidth, 'height': gameHeight}, null);
            canvas.addEventListener('click', gameMouseEvent, false);
            canvas.addEventListener('mousemove', gameMouseEvent, false);
            canvas.addEventListener('contextmenu', gameMouseEvent, false);
            const ctx = canvas.getContext('2d');
            gameDiv.appendChild(canvas);

            const gameSetupControls = makeFieldset('Game Setup');
            const setupManager = new GameSetupManager(gameSetupControls, finishSetup);

            function gameMouseEvent(evt) {
                if (game) {
                    var rect = canvas.getBoundingClientRect();
                    evt.preventDefault();
                    game.mouseEvent(evt.clientX - rect.left, evt.clientY - rect.top, evt.type);
                }
            }

            let game = null;

            let lastUpdate = null;
            function animateGame() {
                const nowUpdate = Date.now();
                const dt = nowUpdate - lastUpdate;
                lastUpdate = nowUpdate;
                game.update(dt);
                game.draw(ctx);
                requestAnimationFrame(animateGame);
            }

            //TODO: need a way to start from a stored gamestate?
            //use localstorage to store a game state that is kept up to date, that way a refreshed page doesn't ruin an in-progress game
            //this will require never storing pixel coordinates though, so need to factor out the game x,y coords and the tileSize
            //and pass those values in for every draw call, plus we'll need a way to convert mouse position into the same offset system for the tiles
            function startNewGame() {
                game = new Game(gameWidth, gameHeight, gameGridSize);
                //TODO: only append if gamestate is in setup?
                gameDiv.appendChild(gameSetupControls);
                //on submit with the start buton, do this:
                lastUpdate = Date.now();
                animateGame();
            }

            function finishSetup() {
                if (setupManager.isValidSetup()) {
                    gameDiv.removeChild(gameSetupControls);
                    game.setup(setupManager.getCurrentGameMode(), setupManager.getLeftArmy(), setupManager.getRightArmy());
                    //TODO: need controls for in-game?
                }
            }

            startNewGame();
        </script>
    </body>
<html>