<!DOCTYPE html>
<html color-mode="user">
    <head>
        <title>Picker</title>
        <link rel="stylesheet" href="../../css/mvp.css">
    </head>
    <body>
        <script src="../../scripts/html_tools.js"></script>
        <script src="../../scripts/string_tools.js"></script>
        <script>
            //Note: this will actually be useful for more than just names if I am right about its final design.
            //Really it's just a general "draw from a hat" contraption.
            //TODO: the rest of the owl
            //Use localstorage as temp database for names
            //Get names from tons of sources and enter them (maybe have a bulk name insert tool?)
            //each name containing a collection of tags including active time periods, genders, etc.

            //TODO: create a file containing the base "names" collection and allow the user to "restore" to that collection for initialization or repair.
            //Do the same for tags and anything else required to get this up and running.

            function TagSelector(parent, name) {
                const subscribers = {};
                const selectedList = [];
                const selectedItemsContainer = createElement('div', { 'style': `display:flex; flex-direction:row; gap:8px;` }, null);

                this.registerSubscriber = (subscriberName, subscriberAction) => {
                    subscribers[subscriberName] = subscriberAction;
                };

                const updateSubscribers = () => {
                    for (const sub in subscribers) {
                        subscribers[sub]();
                    }
                };

                this.getSelectedList = () => [...selectedList];

                const label = createElement('label', {'for': name}, 'Tag Filters');
                const selector = makeSelect(name);

                const makeSelection = () => {
                    const i = selector.selectedIndex;
                    const v = selector.options[i].value;
                    selectedList.push(v);
                    selector.options.remove(i);
                    addSelectedItem(v);
                    updateSubscribers();
                };

                const addSelectedItem = (tag) => {
                    const item = createElement('input', {'type': 'button', 'value': tag, 'style': `width:fit-content;`}, null);
                    const removeMe = () => {
                        selectedItemsContainer.removeChild(item);
                        this.unselect(tag);
                    }
                    item.addEventListener('click', removeMe);
                    selectedItemsContainer.appendChild(item);
                    selector.selectedIndex = 0;
                };

                selector.addEventListener('change', () => makeSelection());
                
                //TODO: might not need this one
                this.updateTagList = () => {
                    populateTagList();
                };

                this.unselect = (value) => {
                    selectedList.splice(selectedList.indexOf(value), 1);
                    populateTagList();
                };

                this.resetAll = () => {
                    selectedList.splice(0, selectedList.length);
                    while (selectedItemsContainer.children.length > 0) {
                        selectedItemsContainer.removeChild(selectedItemsContainer.children[0]);
                    }
                    populateTagList();
                };

                const populateTagList = () => {
                    //TODO: read in tags from saved data, but not every time?
                    const tempTags = [
                        'male',
                        'female',
                        'contemporary',
                        'medieval',
                    ];
                    let tags = [...tempTags];

                    while (selector.options.length > 0) {
                        selector.options.remove(0);
                    }

                    const placeholder = createElement('option', {'value': null, 'disabled': true, 'selected': true}, 'Select a Tag...');
                    selector.appendChild(placeholder);
                    for (const tag of tags) {
                        if (selectedList.indexOf(tag) < 0) {
                            const option = createElement('option', { 'value': tag }, tag);
                            selector.appendChild(option);
                        }
                    }
                    updateSubscribers();
                };

                parent.appendChild(label);
                parent.appendChild(selector);
                parent.appendChild(selectedItemsContainer);
                populateTagList();
            }

            function DataSource() {
                //TODO: read in data from saved data
                let data = [];
                //TODO: is this collection strictly necessary? Should it reset every now and then?
                const idsUsedThisSession = [];

                const getNextId = () => {
                    if (data.length === 0) {
                        return 0;
                    }
                    return Math.max(...data.map(d => d['id'])) + 1;
                };

                const newEntry = (name, tags) => {
                    return {
                        'id': getNextId(),
                        'name': name,
                        'tags': [...tags],
                        'timesPicked': 0,
                    };
                };

                data.push(newEntry('Brandon', ['contemporary', 'male']));
                data.push(newEntry('Peter', ['contemporary', 'medieval', 'male']));
                data.push(newEntry('Bartholomew', ['medieval', 'male']));
                data.push(newEntry('Pat', ['contemporary', 'male', 'female']));
                data.push(newEntry('Megan', ['contemporary', 'female']));
                data.push(newEntry('Hildegard', ['medieval', 'female']));
                data.push(newEntry('Mary', ['contemporary', 'medieval', 'female']));

                const meetsFilterCriteria = (itemTags, filterTags) => {
                    for (const filter of filterTags) {
                        if (itemTags.indexOf(filter) < 0) {
                            return false;
                        }
                    }
                    return true;
                };

                const getData = (filterList) => {
                    const unusedData = data.filter(d => idsUsedThisSession.indexOf(d['id']) < 0);
                    if (!filterList || filterList.length === 0) {
                        return unusedData;
                    }

                    return unusedData.filter(d => meetsFilterCriteria(d['tags'], filterList));
                };

                this.getFilteredValues = (filterList) => getData(filterList).map(d => d['name']);

                this.pickOne = (filterList) => {
                    const options = getData(filterList);
                    const maxTimesPicked = Math.max(...options.map(d => d['timesPicked']));
                    const hat = [];
                    for (const option of options) {
                        console.log(option);
                        const num = (maxTimesPicked - option['timesPicked']) + 1;
                        for (let i = 0; i < num; i++) {
                            hat.push(option);
                        }
                    }
                    console.log(hat);
                    const selection = hat[Math.floor(Math.random() * hat.length)];
                    selection['timesPicked']++;
                    idsUsedThisSession.push(selection['id']);
                    //TODO: return an object with the name and an ID so that the user can choose to unselect it?
                    return selection['name'];
                };
            }

            function Picker(parent, dataSource) {
                const pickerContents = createElement('div', {}, null);
                const data = dataSource;
                const tagSelector = new TagSelector(pickerContents, 'picker-tag-selector');
                const pickButton = createElement('button', {'type': 'submit'}, `Pick!`);
                //TODO: pretty formatting?
                const selectedItems = createElement('div', {}, null);

                const tagsUpdated = () => {
                    const latestTags = tagSelector.getSelectedList();
                    console.log(latestTags);
                    const previewList = data.getFilteredValues(latestTags);
                    console.log(previewList);
                    //TODO: update a preview to show the user?
                    pickButton.disabled = previewList.length === 0;
                };

                const addSelectedResult = (item) => {
                    //For now, item is just a text string
                    //TODO: may take in an object instead?
                    selectedItems.appendChild(createElement('h2', {}, item));
                };

                const pickButtonClick = () => {
                    const result = data.pickOne(tagSelector.getSelectedList());
                    console.log(result);
                    addSelectedResult(result);
                    tagSelector.updateTagList();
                };
                
                tagSelector.registerSubscriber('parent_selector', tagsUpdated);

                pickButton.addEventListener('click', pickButtonClick);
                pickerContents.appendChild(pickButton);

                pickerContents.appendChild(selectedItems);

                //TODO: the 'true' here indicates it defaults to being open
                //do we want to store/track that value?
                const pickerDetail = makeDetail(`Picker`, pickerContents, true);
                parent.appendChild(pickerDetail);

                this.updateTags = () => {
                    tagSelector.updateTagList();
                };
            }

            const main = createElement('main', {}, null);
            document.body.appendChild(main);

            const dataSource = new DataSource();
            const picker = new Picker(main, dataSource);
            //TODO: editor for the tag list
            //TODO: editor for the data source
        </script>
    </body>
</html>